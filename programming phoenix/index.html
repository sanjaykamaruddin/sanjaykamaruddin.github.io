<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="style.css" rel="stylesheet" type="text/css" /><title>Programming Phoenix 1.4</title></head><body><div class="calibre1" id="calibre_link-294"><div id="calibre_link-332" class="calibre2"><h1 class="titlepage">Programming Phoenix ≥ 1.4</h1>
<h3 class="titlepage1">Productive |&gt; Reliable |&gt; Fast</h3>
<h3 class="titlepage2">by Chris McCord, Bruce Tate, José Valim</h3>
<div class="titlepage3">Version: P1.0 (October 2019)</div>
</div>



  </div>


<div class="calibre1" id="calibre_link-11"><div id="calibre_link-333" class="calibre2"><section class="pp-chunk"><p class="calibre3">Copyright © 2019 The Pragmatic Programmers, LLC.
        This book is licensed to
        the individual who purchased it. We don't copy-protect it
        because that would limit your ability to use it for your
        own purposes. Please don't break this trust&mdash;you can use
        this across all of your devices but please do not share this copy
        with other members of your team, with friends, or via
        file sharing services.  Thanks.
        </p><p class="calibre3">
             Many of the designations used by manufacturers and
             sellers to distinguish their products are claimed as
             trademarks. Where those designations appear in this book,
             and The Pragmatic Programmers, LLC was aware of a
             trademark claim, the designations have been printed in
             initial capital letters or in all capitals. The Pragmatic
             Starter Kit, The Pragmatic Programmer, Pragmatic
             Programming, Pragmatic Bookshelf and the linking <i class="calibre4">g</i>
             device are trademarks of The Pragmatic Programmers,
             LLC.
         </p><p class="calibre3">
           Every precaution was taken in the preparation of this book.
           However, the publisher assumes no responsibility for errors
           or omissions, or for damages that may result from the use
           of information (including program listings) contained
           herein.
         </p>


<section class="about-pb"><h2 class="pp-no-chunk">About the Pragmatic Bookshelf</h2><p class="calibre3">
           The Pragmatic Bookshelf is an agile publishing company.
           We’re here because we want to improve the lives of developers.
           We do this by creating timely, practical titles, written by programmers for programmers.
         </p><p class="calibre3">
           Our Pragmatic courses, workshops, and other products can
           help you and your team create better software and have more
           fun. For more information, as well as the latest Pragmatic
           titles, please visit us at <a href="http://pragprog.com" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">http://pragprog.com</a>.
         </p><p class="calibre3">
           Our ebooks do not contain any Digital Restrictions
           Management, and have always been DRM-free. We pioneered the
           beta book concept, where you can purchase and read a book
           while it’s still being written, and provide feedback to the
           author to help make a better book for everyone. Free
           resources for all purchasers include source code downloads
           (if applicable), errata and discussion forums, all
           available on the book's home page at pragprog.com. We’re
           here to make your life easier.
         </p><h3 class="calibre6">New Book Announcements</h3><p class="calibre3">
           Want to keep up on our latest titles and announcements, and
           occasional special offers? Just create an account on
           <a href="https://pragprog.com" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">pragprog.com</a> (an email address and a password is all it takes)
           and select the checkbox to receive newsletters. You can
           also follow us on twitter as @pragprog.
         </p><h3 class="calibre6">About Ebook Formats</h3><p class="calibre3">
             If you buy directly from
           <a href="https://pragprog.com" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">pragprog.com</a>, you get
           ebooks in all available formats for one price. You can
           synch your ebooks amongst all your devices (including
           iPhone/iPad, Android, laptops, etc.) via Dropbox.
           You get free updates for the life of the edition. And, of
           course, you can always come back and re-download your books
           when needed. Ebooks bought from the Amazon Kindle store are
           subject to Amazon's polices. Limitations in Amazon's file
           format may cause ebooks to display differently on different
           devices. For more information, please see our FAQ at
           <a href="https://pragprog.com/frequently-asked-questions/ebooks" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">pragprog.com/frequently-asked-questions/ebooks</a>. To learn
           more about this book and access the free resources, go to
           <a href="https://pragprog.com/book/phoenix14" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://pragprog.com/book/phoenix14</a>, the book's homepage.</p><p class="calibre3">
           Thanks for your continued support,
         </p><p class="calibre3">
           Andy Hunt<br class="about-pb" />
           The Pragmatic Programmers
         </p></section><section class="about-pb"><p class="calibre3">The team that produced this book includes: <span class="pcalibre4 production">Andy Hunt (Publisher)</span><span class="pcalibre4 production">Janet Furlow (VP of Operations)</span><span class="pcalibre4 production">Susan Conant (Managing Editor)</span><span class="pcalibre4 production">Jacquelyn Carter (Development Editor)</span><span class="pcalibre4 production">Jasmine Kwityn (Copy Editor)</span><span class="pcalibre4 production">Potomac Indexing, LLC (Indexing)</span><span class="pcalibre5 production">Gilson Graphics (Layout)</span></p><p class="calibre3">
             For customer support, please contact
             <a href="mailto:support@pragprog.com" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">support@pragprog.com</a>.
           </p><p class="calibre3">
             For international rights, please contact
             <a href="mailto:rights@pragprog.com" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">rights@pragprog.com</a>.
           </p></section></section>
</div>



  </div>


<div class="calibre1" id="calibre_link-57"><div id="calibre_link-334" class="calibre2"><nav type="toc" class="about-pb"><h1 class="pp-no-chunk1">Table of Contents</h1><ol class="calibre7"><li class="toc-chap"><a href="#calibre_link-58" class="pcalibre calibre8 pcalibre3 pcalibre1 pcalibre2"><span class="toc-secnum">&nbsp;</span>Acknowledgments</a><ol class="calibre7"><li class="toc-sect"><a href="#calibre_link-59" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">José Valim</a></li><li class="toc-sect"><a href="#calibre_link-60" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Bruce Tate</a></li><li class="toc-sect"><a href="#calibre_link-61" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Chris McCord</a></li></ol></li><li class="toc-chap"><a href="#calibre_link-62" class="pcalibre calibre8 pcalibre3 pcalibre1 pcalibre2"><span class="toc-secnum">&nbsp;</span>Preface</a><ol class="calibre7"><li class="toc-sect"><a href="#calibre_link-63" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Is This Book for You?</a></li><li class="toc-sect"><a href="#calibre_link-64" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">About this Book</a></li><li class="toc-sect"><a href="#calibre_link-65" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Online Resources</a></li></ol></li><li class="toc-chap"><a href="#calibre_link-66" class="pcalibre calibre8 pcalibre3 pcalibre1 pcalibre2"><span class="toc-secnum">1. </span>Introducing Phoenix</a><ol class="calibre7"><li class="toc-sect"><a href="#calibre_link-67" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Productive</a></li><li class="toc-sect"><a href="#calibre_link-68" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Concurrent</a></li><li class="toc-sect"><a href="#calibre_link-69" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Beautiful Code</a></li><li class="toc-sect"><a href="#calibre_link-70" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Interactive</a></li><li class="toc-sect"><a href="#calibre_link-71" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Reliable</a></li></ol></li><li class="toc-chap"><a href="#calibre_link-72" class="calibre10 pcalibre pcalibre3 pcalibre1 pcalibre2">Part I. Building with Functional MVC</a><ol class="calibre7"><li class="toc-chap"><a href="#calibre_link-73" class="pcalibre calibre8 pcalibre3 pcalibre1 pcalibre2"><span class="toc-secnum">2. </span>The Lay of the Land</a><ol class="calibre7"><li class="toc-sect"><a href="#calibre_link-74" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Simple Functions</a></li><li class="toc-sect"><a href="#calibre_link-75" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Installing Your Development Environment</a></li><li class="toc-sect"><a href="#calibre_link-76" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Creating a Throwaway Project</a></li><li class="toc-sect"><a href="#calibre_link-77" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Building a Feature</a></li><li class="toc-sect"><a href="#calibre_link-78" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Going Deeper: The Request Pipeline</a></li><li class="toc-sect"><a href="#calibre_link-79" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Wrapping Up</a></li></ol></li><li class="toc-chap"><a href="#calibre_link-80" class="pcalibre calibre8 pcalibre3 pcalibre1 pcalibre2"><span class="toc-secnum">3. </span>Controllers</a><ol class="calibre7"><li class="toc-sect"><a href="#calibre_link-81" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Understanding Controllers</a></li><li class="toc-sect"><a href="#calibre_link-82" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Building a Controller</a></li><li class="toc-sect"><a href="#calibre_link-83" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Coding Views</a></li><li class="toc-sect"><a href="#calibre_link-84" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Using Helpers</a></li><li class="toc-sect"><a href="#calibre_link-85" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Showing a User</a></li><li class="toc-sect"><a href="#calibre_link-86" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Wrapping Up</a></li></ol></li><li class="toc-chap"><a href="#calibre_link-87" class="pcalibre calibre8 pcalibre3 pcalibre1 pcalibre2"><span class="toc-secnum">4. </span>Ecto and Changesets</a><ol class="calibre7"><li class="toc-sect"><a href="#calibre_link-88" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Understanding Ecto</a></li><li class="toc-sect"><a href="#calibre_link-89" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Defining the User Schema and Migration</a></li><li class="toc-sect"><a href="#calibre_link-90" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Using the Repository to Add Data</a></li><li class="toc-sect"><a href="#calibre_link-91" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Building Forms</a></li><li class="toc-sect"><a href="#calibre_link-92" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Creating Resources</a></li><li class="toc-sect"><a href="#calibre_link-93" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Wrapping Up</a></li></ol></li><li class="toc-chap"><a href="#calibre_link-94" class="pcalibre calibre8 pcalibre3 pcalibre1 pcalibre2"><span class="toc-secnum">5. </span>Authenticating Users</a><ol class="calibre7"><li class="toc-sect"><a href="#calibre_link-95" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Preparing for Authentication</a></li><li class="toc-sect"><a href="#calibre_link-96" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Managing Registration Changesets</a></li><li class="toc-sect"><a href="#calibre_link-97" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Creating Users</a></li><li class="toc-sect"><a href="#calibre_link-98" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">The Anatomy of a Plug</a></li><li class="toc-sect"><a href="#calibre_link-99" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Writing an Authentication Plug</a></li><li class="toc-sect"><a href="#calibre_link-100" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Implementing Login and Logout</a></li><li class="toc-sect"><a href="#calibre_link-101" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Presenting User Account Links</a></li><li class="toc-sect"><a href="#calibre_link-102" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Wrapping Up</a></li></ol></li><li class="toc-chap"><a href="#calibre_link-103" class="pcalibre calibre8 pcalibre3 pcalibre1 pcalibre2"><span class="toc-secnum">6. </span>Generators and Relationships</a><ol class="calibre7"><li class="toc-sect"><a href="#calibre_link-104" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Using Generators</a></li><li class="toc-sect"><a href="#calibre_link-105" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Building Relationships</a></li><li class="toc-sect"><a href="#calibre_link-106" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Managing Related Data</a></li><li class="toc-sect"><a href="#calibre_link-107" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">In-context Relationships</a></li><li class="toc-sect"><a href="#calibre_link-108" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Wrapping Up</a></li></ol></li><li class="toc-chap"><a href="#calibre_link-109" class="pcalibre calibre8 pcalibre3 pcalibre1 pcalibre2"><span class="toc-secnum">7. </span>Ecto Queries and Constraints</a><ol class="calibre7"><li class="toc-sect"><a href="#calibre_link-110" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Seeding and Associating Categories</a></li><li class="toc-sect"><a href="#calibre_link-111" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Diving Deeper into Ecto Queries</a></li><li class="toc-sect"><a href="#calibre_link-112" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Constraints</a></li><li class="toc-sect"><a href="#calibre_link-113" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Wrapping Up</a></li></ol></li><li class="toc-chap"><a href="#calibre_link-114" class="pcalibre calibre8 pcalibre3 pcalibre1 pcalibre2"><span class="toc-secnum">8. </span>Testing MVC</a><ol class="calibre7"><li class="toc-sect"><a href="#calibre_link-115" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Understanding ExUnit</a></li><li class="toc-sect"><a href="#calibre_link-116" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Testing Contexts</a></li><li class="toc-sect"><a href="#calibre_link-117" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Using Ecto Sandbox for Test Isolation and Concurrency</a></li><li class="toc-sect"><a href="#calibre_link-118" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Integration Tests</a></li><li class="toc-sect"><a href="#calibre_link-119" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Unit-Testing Plugs</a></li><li class="toc-sect"><a href="#calibre_link-120" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Testing Views and Templates</a></li><li class="toc-sect"><a href="#calibre_link-121" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Wrapping Up</a></li></ol></li></ol></li><li class="toc-chap"><a href="#calibre_link-122" class="calibre10 pcalibre pcalibre3 pcalibre1 pcalibre2">Part II. Writing Interactive and Maintainable Applications</a><ol class="calibre7"><li class="toc-chap"><a href="#calibre_link-123" class="pcalibre calibre8 pcalibre3 pcalibre1 pcalibre2"><span class="toc-secnum">9. </span>Watching Videos</a><ol class="calibre7"><li class="toc-sect"><a href="#calibre_link-124" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Watching Videos</a></li><li class="toc-sect"><a href="#calibre_link-125" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Adding JavaScript</a></li><li class="toc-sect"><a href="#calibre_link-126" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Creating Slugs</a></li><li class="toc-sect"><a href="#calibre_link-127" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Wrapping Up</a></li></ol></li><li class="toc-chap"><a href="#calibre_link-128" class="pcalibre calibre8 pcalibre3 pcalibre1 pcalibre2"><span class="toc-secnum">10. </span>Using Channels</a><ol class="calibre7"><li class="toc-sect"><a href="#calibre_link-129" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">The Channel</a></li><li class="toc-sect"><a href="#calibre_link-130" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Phoenix Clients with ES6</a></li><li class="toc-sect"><a href="#calibre_link-131" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Preparing Our Server for the Channel</a></li><li class="toc-sect"><a href="#calibre_link-132" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Creating the Channel</a></li><li class="toc-sect"><a href="#calibre_link-133" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Sending and Receiving Events</a></li><li class="toc-sect"><a href="#calibre_link-134" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Socket Authentication</a></li><li class="toc-sect"><a href="#calibre_link-135" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Persisting Annotations</a></li><li class="toc-sect"><a href="#calibre_link-136" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Handling Disconnects</a></li><li class="toc-sect"><a href="#calibre_link-137" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Tracking Presence on a Channel</a></li><li class="toc-sect"><a href="#calibre_link-138" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Wrapping Up</a></li></ol></li><li class="toc-chap"><a href="#calibre_link-139" class="pcalibre calibre8 pcalibre3 pcalibre1 pcalibre2"><span class="toc-secnum">11. </span>Observer and Umbrellas</a><ol class="calibre7"><li class="toc-sect"><a href="#calibre_link-140" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Introspecting Applications with Observer</a></li><li class="toc-sect"><a href="#calibre_link-141" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Using Umbrellas</a></li><li class="toc-sect"><a href="#calibre_link-142" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Extracting Rumbl and RumblWeb</a></li><li class="toc-sect"><a href="#calibre_link-143" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Wrapping Up</a></li></ol></li><li class="toc-chap"><a href="#calibre_link-144" class="pcalibre calibre8 pcalibre3 pcalibre1 pcalibre2"><span class="toc-secnum">12. </span>OTP</a><ol class="calibre7"><li class="toc-sect"><a href="#calibre_link-145" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Managing State with Processes</a></li><li class="toc-sect"><a href="#calibre_link-146" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Building GenServers for OTP</a></li><li class="toc-sect"><a href="#calibre_link-147" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Designing an Information System with OTP</a></li><li class="toc-sect"><a href="#calibre_link-148" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Building the Wolfram Info System</a></li><li class="toc-sect"><a href="#calibre_link-149" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Integrating OTP Services with Channels</a></li><li class="toc-sect"><a href="#calibre_link-150" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Wrapping Up</a></li></ol></li><li class="toc-chap"><a href="#calibre_link-45" class="pcalibre calibre8 pcalibre3 pcalibre1 pcalibre2"><span class="toc-secnum">13. </span>Testing Channels and OTP</a><ol class="calibre7"><li class="toc-sect"><a href="#calibre_link-151" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Testing the Information System</a></li><li class="toc-sect"><a href="#calibre_link-152" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Isolating Wolfram</a></li><li class="toc-sect"><a href="#calibre_link-153" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Adding Tests to Channels</a></li><li class="toc-sect"><a href="#calibre_link-154" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Authenticating a Test Socket</a></li><li class="toc-sect"><a href="#calibre_link-155" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Communicating with a Test Channel</a></li><li class="toc-sect"><a href="#calibre_link-156" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Wrapping Up</a></li></ol></li><li class="toc-chap"><a href="#calibre_link-157" class="pcalibre calibre8 pcalibre3 pcalibre1 pcalibre2"><span class="toc-secnum">14. </span>What’s Next?</a><ol class="calibre7"><li class="toc-sect"><a href="#calibre_link-158" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Other Interesting Features</a></li><li class="toc-sect"><a href="#calibre_link-159" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Phoenix LiveView</a></li><li class="toc-sect"><a href="#calibre_link-160" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Phoenix PubSub 2.0</a></li><li class="toc-sect"><a href="#calibre_link-161" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Phoenix and Telemetry Integration</a></li><li class="toc-sect"><a href="#calibre_link-162" class="calibre9 pcalibre pcalibre3 pcalibre1 pcalibre2">Good Luck!</a></li></ol></li></ol></li></ol></nav><div class="copyright">Copyright © 2020, The Pragmatic Bookshelf.</div>
</div>



  </div>


<div class="calibre1" id="calibre_link-218"><div id="calibre_link-335" class="calibre2"><h1 class="calibre11">
    Early Praise for <em class="calibre12">Programming Phoenix 1.4</em></h1><div class="calibre13"><div class="praise">
<p id="calibre_link-336" class="calibre14">
 
        <em class="calibre4">Programming Phoenix</em> offers a very engaging hands-on approach without compromising depth in content, making it a balanced source of knowledge for beginners and hackers alike. The authors’ credibility comes not only from the fact that they are creators of Elixir and Phoenix, but for their experience in the field designing, building, and scaling big apps&mdash;and that completely shows in this book.
      </p></div><table class="praise1"><tr class="calibre15"><td class="calibre16">→ </td><td class="calibre17"> João Augusto B.C. Alves</td></tr><tr class="calibre15"><td class="calibre17">
</td><td class="calibre17">Software Consultant, Plataformatec</td></tr></table></div><div class="calibre13"><div class="praise">
<p id="calibre_link-337" class="calibre14">
        <em class="calibre4">Programming Phoenix</em> will provide you with the most in-depth, cutting-edge insights into how to harness the full power of the Phoenix framework. If you want to be the best, learn from the best.
      </p></div><table class="praise1"><tr class="calibre15"><td class="calibre16">→ </td><td class="calibre17">Tetiana Dushenkivska</td></tr><tr class="calibre15"><td class="calibre17">
</td><td class="calibre17">Creator of ElixirCards, Clever Bunny</td></tr></table></div><div class="calibre13"><div class="praise">
<p id="calibre_link-338" class="calibre14">
        I write Elixir for a living, and <em class="calibre4">Programming Phoenix</em> was exactly what I needed. It filled in the sticky details, like how to tie authentication into web applications and channels. It also showed me how to layer services with OTP. The experience of Chris and José makes all of the difference in the world.
      </p></div><table class="praise1"><tr class="calibre15"><td class="calibre16">→ </td><td class="calibre17">Eric Meadows-Jönsson</td></tr><tr class="calibre15"><td class="calibre17">
</td><td class="calibre17">Elixir Core Team</td></tr></table></div><div class="calibre13"><div class="praise">
<p id="calibre_link-339" class="calibre14">
        Phoenix gives you all the tools needed to handle very complex problems in a very elegant way. <em class="calibre4">Programming Phoenix</em> gives you all the tips you need to solve such problems. It’s a must have.
      </p></div><table class="praise1"><tr class="calibre15"><td class="calibre16">→ </td><td class="calibre17">Marcos Ramos</td></tr><tr class="calibre15"><td class="calibre17">
</td><td class="calibre17">Senior Elixir Developer, Plataformatec</td></tr></table></div><div class="calibre13"><div class="praise">
<p id="calibre_link-340" class="calibre14">
        Even if you have no current plans to write a Phoenix web app, you need to read <em class="calibre4">Programming Phoenix</em>. The insights this book gives into Elixir, Erlang, and OTP&mdash;their strengths, and the corresponding thoughtful design patterns that went into the Phoenix framework&mdash;are invaluable to any developer in the Elixir/Erlang ecosystem.

      </p></div><table class="praise1"><tr class="calibre15"><td class="calibre16">→ </td><td class="calibre17">Mike Binns</td></tr><tr class="calibre15"><td class="calibre17">
</td><td class="calibre17">Senior Software Engineer, Dockyard</td></tr></table></div>


</div>



  </div>


<div class="calibre1" id="calibre_link-246"><div id="calibre_link-341" class="calibre2"><h1 class="pcalibre6 chapter-title" id="calibre_link-58"><span class="chapter-number"></span><br class="calibre18" /><span class="chapter-name">Acknowledgments</span></h1>

<p id="calibre_link-342" class="calibre19">Most of this book is written in a collective voice, but acknowledgments are deep and personal things. We’ll speak a little here as a team before expressing some individual gratitude. You’ll notice that of the three of us Chris has the most to say, which is fitting since he is the creator of Phoenix and has been invested in it from the very beginning.</p>
<p id="calibre_link-343" class="calibre19">The endeavor of writing a book touches each author in their own way. Writing a beta book means this process often happens in the public eye so each author’s job is made simultaneously more difficult. Criticisms are levied against an unfinished product, but adjustments can be made in real time resulting in a better book and surprising interactions with readers. Thanks to all of our beta readers who waited with patience as Chris released two versions of Phoenix and LiveView.</p>
<p id="calibre_link-344" class="calibre19">As a team, we’d like to thank this production crew. It’s been the finest any of us have ever worked with. Potomac Indexing, LLC, handled our indexing, Jasmine Kwityn did our copyedit, and Janet Furlow managed the endless production details.</p>
<p id="calibre_link-345" class="calibre19">These contributions were invaluable, but we’d also like to single one out for deeper praise. Jackie Carter is more than an editor. After working with us year after year, the relationship has transcended mere editorial advice. She’s a friend and mentor. This book was trying but your voice shaped it reliably and skillfully.</p>
<p id="calibre_link-346" class="calibre19">Our reviewers worked hard to provide excellent feedback, even though the code serving as the foundation for this book was constantly shifting. Of course, we had our formal technical reviews. We’d like to thank Lance Halvorsen, Doug Yun, Marcos Ramos, Elaine Watanabe,
Luke Imhoff, Mike Binns, and João Britto for providing excellent feedback.</p>
<p id="calibre_link-347" class="calibre19">This book spent a long time in beta; perhaps too long. You will ultimately benefit from that with a better book. The advice and care our beta readers took to fill in errors and make suggestions was fantastic. Finally, thanks to all of the folks who have supported us with reviews, kind words, and meaningful conversations.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-276"><div id="calibre_link-348" class="calibre2"><h2 id="calibre_link-59" class="calibre20">José Valim</h2>
<p id="calibre_link-349" class="calibre19">Elixir has been a labor of love and a project that has exceeded my wildest expectations. Elixir wouldn’t exist without the support of my partners at Plataformatec. They were the first to believe Elixir could make a dent in the world, and their investments in the community have helped Elixir grow with strength and grace.</p>
<p id="calibre_link-350" class="calibre19">Getting this far wouldn’t have been possible without the unconditional support of my wife, Ma<span class="calibre21">ł</span>gosia. Most of Elixir was written on a small desk placed in the corner of our bedroom. Of all the corners in the world, I can’t imagine a better one.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-0"><div id="calibre_link-351" class="calibre2"><h2 id="calibre_link-60" class="calibre20">Bruce Tate</h2>
<p id="calibre_link-352" class="calibre19">A completed book fills a hole on many bookshelves but leaves other holes behind. Thanks to Maggie, my joy and inspiration, for sharing me with a smile. Introducing a new language to the world is demanding. Sharing our home with this metaphorical guest (which led to more than a few corporal guests) is going above and beyond. What can I say besides thank you? Julia and Kayla, it’s been a joy raising you and knowing that you are growing from the two wide-eyed does watching the world change to two tigresses doing the changing. Get ready, world!</p>
<p id="calibre_link-353" class="calibre19">Thanks to José and Chris for taking this journey with me; to Francesco for your friendship and companionship; to Brett Wise who has become an extension of me for the great things we want to do in the world. Thanks to JEG2 and Chris K. for being contrarian voices in a world of sameness.</p>
<p id="calibre_link-354" class="calibre19">To my mentees, especially Doc, Grace, and Ram (Richard to those who might not know him well), thanks for believing in me and working to be the best people you can. You inspire me.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-47"><div id="calibre_link-355" class="calibre2"><h2 id="calibre_link-61" class="calibre20">Chris McCord</h2>
<p id="calibre_link-356" class="calibre19">First, I would like to thank José Valim for creating Elixir, for his contributions to Phoenix, and for building a community that has been such a pleasure to be a part of. It goes without saying that Phoenix wouldn’t be possible without his work on Elixir, but it goes deeper than that. He has my deepest gratitude for setting in motion my dream career, sharing his wisdom on running large open source projects, and being a helpful friend in between hectic releases. He has shared with the world a true gift, and I can’t wait to see where his creativity leads.</p>
<p id="calibre_link-357" class="calibre19">Thanks also go to Bruce Tate for contributing his superb writing skills, helping to form the abstractions behind Phoenix, and encouraging me to seek out José’s help with the project. His craftsmanship in this book really shows, and it’s been a pleasure having him on the team.</p>
<p id="calibre_link-358" class="calibre19">I extend my warmest thanks to Brian Cardarella and DockYard, for making early bets on Phoenix, supporting the project’s development to get to where we are today, and giving me the chance to work with some of the finest folks in the industry.</p>
<p id="calibre_link-359" class="calibre19">Behind many of the open source projects or books you reference day to day is an understanding spouse who bears late nights and all too much laptop time. My deepest love and appreciation goes out to my lovely wife, Jaclyn, for all her support and encouragement throughout the years along the path to Phoenix and writing this book. A life with you is a truly happy one.</p>
<p id="calibre_link-360" class="calibre19">And finally, to the community for this great project, I extend both heartfelt appreciation and bright hope that we might continue to build something special, together.</p>

<div class="copyright">Copyright © 2020, The Pragmatic Bookshelf.</div>




</div>



  </div>


<div class="calibre1" id="calibre_link-197"><div id="calibre_link-361" class="calibre2"><h1 class="pcalibre6 chapter-title" id="calibre_link-62"><span class="chapter-number"></span><br class="calibre18" /><span class="chapter-name">Preface</span></h1>

<p id="calibre_link-362" class="calibre19">



It doesn’t seem possible, but it’s been three years since we released the first edition of this book.  Indeed, the Phoenix team has been busy. The additions of Channel Presence and LiveView are changing the way all programmers think about web development. The underlying directories have changed, having a rippling impact on all of the code in this book. Ecto has also produced a major release.</p>
<p id="calibre_link-363" class="calibre19">Through it all, one thing remains constant. Phoenix is still positioned as one of the most productive and scalable web development platforms available anywhere. From cryptocurrencies to media companies to commerce, Elixir developers are using Phoenix to push the boundaries of what’s possible. In this book, the same folks who built Elixir and Phoenix will show you how you can do the same.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-238"><div id="calibre_link-364" class="calibre2"><h2 id="calibre_link-63" class="calibre20">Is This Book for You?</h2>
<p id="calibre_link-365" class="calibre19">

If you’ve followed Phoenix for any period of time, you already know that this book is the definitive resource for Phoenix programming. If you’re using Phoenix or are seriously considering doing professional Elixir development, you’re going to want this book. It’s packed with insights from the team that created it. Find just one tip in these pages, and the book will pay for itself many times over. This section seeks to answer a different question, though. Beyond folks who’ve already decided to make an investment in Phoenix, who should buy this book?</p><h3 class="calibre22">Programmers Embracing the Functional Paradigm</h3>
<p id="calibre_link-366" class="calibre19">

Every twenty years or so, new programming paradigms emerge. The industry is currently in the midst of a shift from object-oriented programming to functional programming. If you’ve noticed this trend, you know that a half dozen or so functional languages are competing for mindshare. The best way to understand a programming language is to go beyond basic online tutorials to see how to approach nontrivial programs.</p>
<p id="calibre_link-367" class="calibre19">With <span class="calibre4">Programming Phoenix</span>, we don’t shy away from difficult problems such as customizing authentication, designing for scale, or creating interactive web pages. As you explore the language, you’ll learn how the pieces fit together to solve difficult problems and how functional programming helps us do it elegantly. When you’re done, you might not choose Phoenix, but you’ll at least understand the critical pieces that make it popular and if those pieces are likely to work for you.</p><h3 class="calibre22">Developers Seeking to Modernize</h3>
<p id="calibre_link-368" class="calibre19">


Developers from many web frameworks written in many languages can find something here. Phoenix measures response times in microseconds, and it has been shown to handle millions of concurrent WebSocket connections on a single machine without sacrificing the productivity we’ve come to appreciate. If you’re pushing your favorite framework to be more scalable or more interactive, you’re not alone. You’re going to find Phoenix powerful and interesting. And if you are trying to build single page apps or provide a more consistent or interactive experience for your user, you’ll find Elixir one of the best available languages for solving that problem, period.</p><h3 class="calibre22">Dynamic Programmers Looking for a Mature Environment</h3>
<p id="calibre_link-369" class="calibre19">




Like the authors of this book, you may be a fan of dynamic languages like JavaScript, Python, and Ruby. You may have used them in production or even contributed to those ecosystems. Many developers like us are looking for similar flexibility but with a more robust runtime experience. We may love the programming experience in those languages, but we often find ourselves worn out by the many compromises we have to make for performance, concurrency, and maintainability. Phoenix resonates with us because many of the creators of this ecosystem built it to solve these problems.</p>
<p id="calibre_link-370" class="calibre19">

Elixir is a modern dynamic language built on the three-decades-old, battle-tested Erlang runtime. Elixir macros bring a lot of the flexibility that Ruby, Python, and JavaScript developers came to love, but those dynamic features are quarantined to compile time. With Elixir, during runtime, you have a consistent system with great type support that’s generally unseen in other dynamic languages.</p>
<p id="calibre_link-371" class="calibre19">Mix these features with the concurrency power, and you’ll see why Phoenix provides such excellent performance for everything on the web, and beyond.</p><h3 class="calibre22">Java Developers Seeking More</h3>
<p id="calibre_link-372" class="calibre19">
When Java emerged twenty years ago, it had everything a frustrated C++ community was missing. It was object-oriented, secure, ready for the Internet, and simple, especially when compared to other C++ alternatives at the time. As the Java community flourished and consolidated, the tools and support came. Just about everyone supported Java, and that ubiquity led to a language dominance that we’d never seen before.</p>
<p id="calibre_link-373" class="calibre19">

As Java has aged, it’s lost some of that luster. As the committees that shaped Java compromised, Java lost some of the edge and leadership that the small leadership team provided in early versions. Backward compatibility means that the language evolves slowly as new solutions emerge. You might find that all of that early ubiquity has led to an experience that’s more fragmented or bloated than you like it. You may enjoy the extra punch of emerging languages like Elixir. The Java concurrency story <span class="calibre4">does</span> place plenty of burden on the developer, leaving libraries that may or may not be safe for production systems to cope with increasingly parallel designs.</p>
<p id="calibre_link-374" class="calibre19">If you’re a Java developer looking for where to go next, or a JVM-language developer looking for a better concurrency story, Phoenix would mean leaving the JVM behind. Maybe that’s a good thing. You’ll find a unified, integrated story in Phoenix with sound abstractions on top. The choice is up to you.</p><h3 class="calibre22">Erlang Developers Doing Integrated Web Development</h3>
<p id="calibre_link-375" class="calibre19">



As time goes on, the number of Erlang developers who also gain proficiency in Elixir is growing. The toolchain for Phoenix is spectacular, and many of the tools that exist for Erlang can work in this ecosystem as well. If you’re an Erlang developer, you may want to take advantage of Mix’s excellent scripting for the development, build, and testing workflow. You may like the package management in Hex, or the neat composition of concerns in the Plug library. You may want to use macros to extend the language for your business, or test with greater leverage. You’ll have new programming features like protocols or structs.</p>
<p id="calibre_link-376" class="calibre19">


If you do decide to embrace Elixir, that doesn’t mean you need to leave Erlang behind. You’ll still be able to use the Erlang libraries you enjoy today, including the Erlang process model and full OTP integration. You’ll be able to access your OTP ‘GenServer‘s directly from the Elixir environment, and directly call libraries without the need for extra complex syntax. If these terms aren’t familiar to you, don’t worry. We’ll explore each of them over the course of the book.</p><h3 class="calibre22">Heat Seekers</h3>
<p id="calibre_link-377" class="calibre19">

As web demands grow, an increasing number of developers require infrastructure that will serve more users reliably. If you need raw power supported by a rich language, we have a solution and the numbers to back it up. You’ll have to work for it, but you’ll get much better speed and reliability when you’re done. We’ve run a single chat room on one box supporting two million users. That means that each new message had to go out two million times. Phoenix performs well out of the box and our numbers improve as more cores are added. If you need speed, we have the tonic for what ails you.</p><h3 class="calibre22">Others</h3>
<p id="calibre_link-378" class="calibre19">Certainly, this book isn’t for everyone. We do think that if you’re in one of these groups, you’ll find something you like here. We’re equally confident that folks that we haven’t described will pick up this book and find something valuable. If you’re one of those types, let us know your story.


</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-268"><div id="calibre_link-379" class="calibre2"><h2 id="calibre_link-64" class="calibre20">About this Book</h2>
<p id="calibre_link-380" class="calibre19">This book is about building web applications with the primary web framework for the Elixir language, Phoenix. In its pages we will walk you through building a web application, piece by piece.</p>
<p id="calibre_link-381" class="calibre19">In Part I, we will show you how to build a traditional model-view-controller (MVC) application. We’ll guide you through the Phoenix landscape, showing you in intimate detail how things are stitched together. We will show you how to build a controller and how to organize your business logic into modules called contexts. Along the way, we’ll build our own authentication and build database-backed code with a database library called Ecto.</p>
<p id="calibre_link-382" class="calibre19">In Part II, we will explore channels and presence, Phoenix features that allow a highly interactive experience. Then we’ll learn to tie those interactive features into Elixir’s extensive OTP, a framework for building concurrent, self-healing projects. We will focus on techniques for productively writing code that will be easier to maintain in the future.</p>
<p id="calibre_link-383" class="calibre19">To illustrate both parts of this book fully, we will build a web application together. The application will let users take videos and annotate them with real-time events.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-312"><div id="calibre_link-384" class="calibre2"><h2 id="calibre_link-65" class="calibre20">Online Resources</h2>
<p id="calibre_link-385" class="calibre19">


The apps and examples shown in this book can be found at the Pragmatic Programmers website for this book.<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-314" href="#calibre_link-313">[1]</a></sup> You’ll also find the errata-submission form, where you can report problems with the text or make suggestions for future versions.</p>
<p id="calibre_link-386" class="calibre19">When you’re ready, turn the page and we’ll get started. Let’s build something together!</p>

<div class="footnotes">
<h4 class="calibre24">Footnotes</h4>
<dl class="calibre25">
<dt class="footnote-number"><a id="calibre_link-313" href="#calibre_link-314" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[1]</a></dt><dd class="calibre26">
<p id="calibre_link-387" class="calibre27"><a href="http://pragprog.com/book/phoenix14/" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">http://pragprog.com/book/phoenix14/</a></p></dd></dl></div>
<div class="copyright">Copyright © 2020, The Pragmatic Bookshelf.</div>




</div>



  </div>


<div class="calibre1" id="calibre_link-231"><div id="calibre_link-388" class="calibre2"><h1 class="pcalibre6 chapter-title" id="calibre_link-66"><span class="chapter-number">
            Chapter
            1</span><br class="calibre18" /><span class="chapter-name">Introducing Phoenix</span></h1>

<p id="calibre_link-389" class="calibre19">
The web has gone real time. The days of clicking links to load full pages are over. Websites are as interactive as desktop applications these days, if not more so. Servers manipulate widgets on a page with small data exchanges. Pages ship form data up piece by piece as it becomes available instead of waiting for one massive update. Today’s web developers need a framework designed from the ground up around a real-time architecture, and Phoenix is that framework.</p>
<p id="calibre_link-390" class="calibre19">Ironically, most of the individual pieces from Phoenix can also be found in other places. You’ll find metaprogramming capabilities that remind you of Lisp and domain-specific languages (DSLs) that remind you at times of Ruby. Our method of composing services with a series of functional transformations is reminiscent of Clojure’s Ring. We achieved high throughput and reliability by climbing onto the shoulders of Erlang. Similarly, some of the groundbreaking features like channels and reactive-friendly APIs combine the best features of some of the best JavaScript frameworks but Phoenix makes it work at scale. This precise cocktail of features, where each feature multiplies the impact of the next, can’t be found elsewhere and that’s what makes Phoenix stand out. <span class="calibre4">Phoenix just feels right</span>.</p>
<p id="calibre_link-391" class="calibre19">After using (and writing about) frameworks spanning a half dozen languages across a couple of decades, we think the precise bundle of goodness that we’ll share is powerful enough for the most serious problems you throw at it, beautiful enough to be maintainable for years to come, and&mdash;most important&mdash;fun to code. Give us a couple of pages and you’ll find that the framework represents a great philosophy, one that leverages the reliability and grace of Elixir. You’ll have a front-row seat to understand how we made the decisions that define Phoenix and how best to use them to your advantage.</p>
<p id="calibre_link-392" class="calibre19">Simply put, Phoenix is about productive, concurrent, beautiful, interactive, and reliable applications. Let’s break each of these claims down.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-257"><div id="calibre_link-393" class="calibre2"><h2 id="calibre_link-67" class="calibre20">Productive</h2>
<p id="calibre_link-394" class="calibre19">Phoenix makes programmers productive. Right out of the box, Phoenix gives you everything you’d expect from a web framework:
</p><ul class="calibre28"><li class="calibre29">A base architecture for your application</li><li class="calibre29">A database access and management library for connecting to databases</li><li class="calibre29">A routing layer for connecting web requests to your code</li><li class="calibre29">A templating language and helpers for you to write HTML</li><li class="calibre29">Flexible and performant JSON encoding and decoding for external APIs</li><li class="calibre29">Internationalization strategies for taking your application to the world</li><li class="calibre29">All the breadth and power behind Erlang and Elixir so you can grow</li></ul>
<p id="calibre_link-395" class="calibre19">Like all web frameworks, Phoenix provides a good cross section of features as functions so users don’t have to code their own. However, features are not enough.</p><h3 class="calibre22">Productivity vs. Maintainability</h3>
<p id="calibre_link-396" class="calibre19">


All framework designers must walk a tightrope.
Frameworks must anticipate change by allowing customization, but presenting customization options introduces complexity. Each new feature simply makes the high wire act more treacherous. Let’s call one side of the line <span class="calibre4">productivity</span> and the other <span class="calibre4">maintainability</span>.</p>
<p id="calibre_link-397" class="calibre19">When developers have to learn too much too soon, they must slow down to absorb information. One way to keep developers productive early on is hiding details. When a framework designer leans too far this way, developers must pay a price because at some point, the framework will hide information their users need to solve a critical problem. Unusual customizations lead to hours of tedious searching for some mystery incantation to make things work.</p>
<p id="calibre_link-398" class="calibre19">Use such a framework long enough and you’ll inevitably make changes that cause your application to drift away from the designers’ intentions, setting yourself up for an eternal upstream battle against the framework. Whether it’s a conflicting upgrade or an optimization that isn’t compatible with your change doesn’t matter. The framework developer’s desire for short-term productivity has cost users long-term maintainability. You can find plenty of stale issues inside the issue trackers for both private and commercial web frameworks, telling this tale with stark clarity.</p>
<p id="calibre_link-399" class="calibre19">Sometimes, understanding this limitation, framework designers lean too far in the opposite direction. Too many options in too many places can also have rippling consequences. Options presented in the wrong way force users to make early uninformed decisions. Crippling detail work slowly starves users of the time they need at the beginning of a project, when productivity is the most important.</p>
<p id="calibre_link-400" class="calibre19">
Phoenix takes a slightly different approach as it walks this tightrope. Phoenix is an opinionated framework that favors convention over configuration. But rather than <span class="calibre4">hiding complexity</span>, it <span class="calibre4">layers complexity</span>, providing details piece by piece.</p>
<p id="calibre_link-401" class="calibre19">Phoenix lets users see exactly what’s happening by providing an explicit list of every bit of code a specific route will invoke, one after another. Phoenix hides details in layers by breaking its functionality into small functions and modules and naming them well so they can tell the story. Every application using Phoenix has an endpoint that looks like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ MyApp.Endpoint ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ Phoenix.Endpoint, ​<em class="string">otp_app:</em>​ ​<em class="string">:my_app</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  plug Plug.Static, ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  plug Plug.RequestId</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  plug Plug.Telemetry, ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  plug Plug.Parsers, ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  plug Plug.MethodOverride</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  plug Plug.Head</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  plug Plug.Session, ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  plug MyApp.Router</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-402" class="calibre19">

We are going to dive deep into the mechanics later in the book. For now, what matters is that we have an overview of what our web application provides at a high level.</p>
<p id="calibre_link-403" class="calibre19">Rather than forcing users to configure the server with thousands of tiny decisions, Phoenix provides a default outline. If all you want to do is peek under the hood, you can open up a file. You don’t need to modify this base outline at all, but when it’s time to make that obscure change, you can edit this outline to your heart’s content.</p>
<p id="calibre_link-404" class="calibre19">

So often, productivity means avoiding blocks, and that means developers must have adequate information. Couple the layered architecture with Elixir’s fantastic tools for documentation and you have the tools to be quite productive. For example, you can learn more about any of the components above by simply typing <span class="cf">h Plug.Session</span> in your Elixir terminal, or by accessing the documentation online<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-220" href="#calibre_link-258">[2]</a></sup> or directly in your favorite editor.


</p>
<p id="calibre_link-405" class="calibre19">At the end of the day, Phoenix wants to optimize both productivity and maintainability. After all, maintainability means productivity over time.


</p><h3 class="calibre22">Functional Programming 101: Immutability</h3>
<p id="calibre_link-406" class="calibre19">
One of the secrets for Phoenix’s long-term productivity comes from a trait shared across many functional programming languages: immutability.</p>
<p id="calibre_link-407" class="calibre19">Imagine the following code:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">list = [1, 2, 3]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">do_something(list)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">list</td></tr></table>
<p id="calibre_link-408" class="calibre19">In most programming languages, you cannot assert with a 100% guarantee the <span class="cf">list</span> will still be <span class="cf">[1, 2, 3]</span> after calling <span class="cf">do_something</span>. That’s because <span class="cf">do_something</span> can change the list in place. In Elixir, that’s simply not possible. Our data structures are immutable, so instead of changing the <span class="cf">list</span>, we can only build new lists. Therefore our code is written as a series of small functions that receive everything they have to work with as input and return everything they have changed.</p>
<p id="calibre_link-409" class="calibre19">

This plays a very important role in code readability and maintainability. You will spend much less time and brain cycles trying to figure out what object changed what or what is the current state of a certain component.</p>
<p id="calibre_link-410" class="calibre19">While this is a small example, you will find working with Elixir and functional programming to be full of small changes and improvements that make your code easier to understand, both for your teammates and your future self.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-295"><div id="calibre_link-411" class="calibre2"><h2 id="calibre_link-68" class="calibre20">Concurrent</h2>
<p id="calibre_link-412" class="calibre19">
Over the last decade, we have been hearing more and more about concurrency. If you have never used a language with first-class concurrency support before, you may be wondering what all the fuss is about. In this section, we will cover why concurrency matters in the context of web applications and how Phoenix developers leverage it to build fast, performant applications. First let’s talk about the different types of concurrency.</p><h3 class="calibre22">Types of Concurrency</h3>
<p id="calibre_link-413" class="calibre19">


For our purposes, let’s think of concurrency as a web application’s ability to process two or more web requests at the same time. The simplest way to handle multiple requests is by executing them one right after the other, but that strategy isn’t very efficient. To process a request, most web apps need to perform I/O such as making database requests or communicating with an external API. While you’re waiting for those external services to complete, you could start working on the next request. This is I/O concurrency. Most programming languages provide I/O concurrency out of the box or via libraries. Sometimes, however, the I/O concurrency abstraction ends up leaking to the developer, who must write code in a confusing way, with callbacks of some form.</p>
<p id="calibre_link-414" class="calibre19">

Another type of concurrency is multi-core concurrency, which focuses on the CPU. If your machine has more than one core, one core processes one request while a second core processes another one. For the rest of this discussion, we will consider machines with four cores in our examples, which is commonplace, as even smart watches have multiple cores today.</p>
<p id="calibre_link-415" class="calibre19">There are two main ways to leverage multi-core concurrency:</p><ul class="calibre28"><li class="calibre29">
<p id="calibre_link-416" class="calibre31">With an operating system process per core: If your machine has four cores, you will start four different instances of your web application.</p></li><li class="calibre29">
<p id="calibre_link-417" class="calibre31">With user space routines: If your machine has four cores, you start a single instance of your web application that is capable of using all cores efficiently.</p></li></ul>
<p id="calibre_link-418" class="calibre19">
The downside of using operating system processes is that those four instances cannot share memory. This solution typically leads to higher resource usage and more complex solutions.</p>
<p id="calibre_link-419" class="calibre19">



Thanks to the Erlang VM, Elixir provides I/O concurrency without callbacks, with user-space multi-core concurrency. In a nutshell, this means Elixir developers write code in the simplest and most straightforward fashion and the virtual machine takes care of using all of the resources,  both CPU and I/O, for you. The result is a better application. Let’s talk about why.</p><h3 class="calibre22">Simpler Solutions</h3>
<p id="calibre_link-420" class="calibre19">One issue with concurrency via operating system processes is the poor resource usage. Each core needs a separate instance of your application. If you have 16 cores, you need 16 instances, each on its own memory space.</p>
<p id="calibre_link-421" class="calibre19">
With user space concurrency, you always start a single instance of your application. As you receive new requests, they are naturally spread throughout all cores. Furthermore, they all share the same memory. This small drawback might seem a little vague, so let’s make it more explicit by looking at one specific problem, a common dashboard.</p>
<p id="calibre_link-422" class="calibre19">
Imagine each user in your application has a dashboard. The data in this dashboard takes around 200ms to load and it takes about 100kB in memory. Since we want to provide good experience to users, we decide to cache this data. Let’s say your web application supports only operating system process concurrency. That means each application instance needs to keep its own cache. For ten thousand (10,000) active users, that’s a 1GB data cache for all of the dashboards <span class="calibre4">per instance</span>. For 16 cores with 16 instances, that’s 16GB of cache, and it’s only for the dashboard data. Furthermore, since each instance has its own cache shared across all users, each cache will be less effective at startup time because cache hit rates will be lower, leading to poor startup times.</p>
<p id="calibre_link-423" class="calibre19">To save memory and improve the hit rates, you may decide to put the data in an external caching system, such as Redis or memcached. This external cache increases your complexity for both development and deployment concerns because you now have a new external dependency. Your application is much faster than it would be if you were simply querying the database, but every time users access the dashboard, your application still needs to go over the network, load the cache data, and deserialize it.</p>
<p id="calibre_link-424" class="calibre19">In Elixir, since we start a single web application instance across all cores, we have a single cache of 1GB, shared across all cores, regardless of whether the machine has 1, 4, or 16 cores. We don’t need to add external dependencies and we can serve the dashboard as quickly as possible because we don’t need to go over the network.</p>
<p id="calibre_link-425" class="calibre19">
Does this mean Elixir eliminates the need for caching systems? Surely not. For example, if you have a high number of machines running in production, you may still want an external caching system as a fallback to the local one. We just don’t need external cache systems nearly as often. Elixir developers typically get a lot of mileage from their servers, without a need to resort to external caching. For example, Bleacher Report was able to replace 150 instances running Ruby on Rails with 5 Phoenix instances, which has been proven to handle eight times their average load at a fraction of the cost.<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-221" href="#calibre_link-296">[3]</a></sup></p>
<p id="calibre_link-426" class="calibre19">And while this is just one example, we have the option to make similar trade-offs at different times in our stacks. For simple asynchronous processing, you don’t need a background job framework. For real-time messaging across nodes, you don’t need an external queue system. We may still use those tools, but Elixir developers don’t need to reach for them as often as other developers might. We can avoid or delay buying into complex solutions, spending more time on domain and business logic.</p><h3 class="calibre22">Performance for Developers</h3>
<p id="calibre_link-427" class="calibre19">

Developers are users too. Elixir’s concurrency can have a dramatic impact on our experience as we write software. When we compile software, run tests, or even fetch dependencies, Elixir is using all cores in your machine, and these shorter cycles over the course of a day can stack up.</p>
<p id="calibre_link-428" class="calibre19">Here is a fun story. In its first versions, Elixir used to start as many tests concurrently as the number of cores in your machine. For instance, if your machine has four cores, it would run at most four tests at the same time. This is a great choice if your tests are mostly using the CPU.</p>
<p id="calibre_link-429" class="calibre19">However, for web applications, it is most likely that your tests are also waiting on I/O, due to the database or external systems. Based on this insight, the Elixir team bumped the default number of concurrent tests to double the number of cores. The result? Users reported their test suites became 20%-30% faster. Overall, it is not uncommon for us to hear about web applications running thousands of tests in under 10 seconds.</p><h3 class="calibre22">But Concurrency Is Hard</h3>
<p id="calibre_link-430" class="calibre19">
You may have heard that concurrency is hard and we don’t dispute that. We <span class="calibre4">do</span> claim that traditional languages make concurrency considerably harder than it should be. Many of the issues with concurrency in traditional programming languages come from in-memory race conditions, caused by mutability.</p>
<p id="calibre_link-431" class="calibre19">Let’s take an example. If you have two user space routines trying to remove an element from the same list, you can have a segmentation fault or similarly scary error, as those routines may change the same address in memory at the same time. This means developers need to track where all of the state is and how it is changing across multiple routines.</p>
<p id="calibre_link-432" class="calibre19">In functional programming languages, such as Elixir, the data is immutable. If you want to remove an element from a list, you don’t change that list in memory. You create a new list instead. That means as a functional developer, you don’t need to be concerned with bugs that are caused by concurrent access to memory. You’ll deal only with concurrency issues that are natural to your domain.</p>
<p id="calibre_link-433" class="calibre19">For example, what is the issue with this code sample?</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">product = get_product_from_the_database(id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">product = set_product_pageviews(get_product_pageviews(product) + 1)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">update_product_in_the_database(product)</td></tr></table>
<p id="calibre_link-434" class="calibre19">Consider a product with 100 pageviews. Now imagine two requests are happening at the same time. Each request reads the product from the database, sees that the counter is 100, increments the counter to 101, and updates the product in the database. When both requests are done, the end result <span class="calibre4">could</span> be 101 in the database while we expected it to be 102. This is a race condition that will happen regardless of the programming language you are using. Different databases will have different solutions to the problem. The simplest one is to perform the increment atomically in the database.</p>
<p id="calibre_link-435" class="calibre19">Therefore, when talking about web applications, concurrency issues are natural. Using a language like Elixir and a framework such as Phoenix makes all of the difference in the world. When your chosen environment is equipped with excellent tools to reason about concurrency, you’ll have all of the tools you need to grow as a developer and improve your reasoning about concurrency in the wild.</p>
<p id="calibre_link-436" class="calibre19">
In Elixir, our user-space abstraction for concurrency is also called <span class="calibre4">processes</span>, but do not confuse them with operating system processes. Elixir processes are abstractions inside the Erlang VM that are very cheap and very lightweight. Here is how you can start 100,000 of them in a couple of seconds:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">for i &lt;- 1..100_000 ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  spawn(​<strong class="kw">fn</strong>​ -&gt; Process.sleep(​<em class="string">:infinity</em>​) ​<strong class="kw">end</strong>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-437" class="calibre19">From now on, when you read the word <span class="calibre4">process</span>, you should think about Elixir’s lightweight processes rather than operating system processes. That’s enough about concurrency for now but we will be sure to revisit this topic later.




</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-12"><div id="calibre_link-438" class="calibre2"><h2 id="calibre_link-69" class="calibre20">Beautiful Code</h2>
<p id="calibre_link-439" class="calibre19">
Elixir is perhaps the first functional language to support Lisp-style macros with a more natural syntax. This feature, like a <span class="calibre4">template for code</span>, is not always the right tool for everyday users, but macros are invaluable for extending the Elixir language to add the common features all web servers need to support.</p>
<p id="calibre_link-440" class="calibre19">For example, web servers need to map routes onto functions that do the job:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">pipeline :browser do</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  plug :accepts, ["html"]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  plug :fetch_session</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  plug :protect_from_forgery</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">end</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">pipeline :api do</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  plug :accepts, ["json"]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">end</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">scope "/", MyApp do</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  pipe_through :browser</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  get "/users", UserController, :index</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">end</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">scope "/api/", MyApp do</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  pipe_through :api</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">end</td></tr></table>
<p id="calibre_link-441" class="calibre19">You’ll see this code a little later. You don’t have to understand exactly what it does. For now, know that the first group of functions will run for all browser-based applications, and the second group of functions will run for all JSON-based applications. The third and fourth blocks define which URLs will go to which controller.</p>
<p id="calibre_link-442" class="calibre19">

You’ve likely seen code like this before. Here’s the point. You don’t have to sacrifice beautiful code to use a functional language. Your code organization can be even better. In Phoenix, you won’t have to read through inheritance chains to know how your code works. You’ll just build a <span class="cf">pipeline</span> for each group of routes that work the same way.</p>
<p id="calibre_link-443" class="calibre19">



You can find an embarrassing number of frameworks that break this kind of code down into something that is horribly inefficient. Consultancies have made millions on performance tuning by doing nothing more than tuning route tables. This Phoenix example reduces your router to pattern matching that’s further optimized by the virtual machine, becoming extremely fast. We’ve built a layer that ties together Elixir’s pattern matching with the macro syntax to provide an excellent routing layer, and one that fits the Phoenix framework well.</p>
<p id="calibre_link-444" class="calibre19">

You’ll find many more examples like this one, such as Ecto’s elegant query syntax or how we express requests as a pipeline of functions that compose well and run quickly. In each case, you’re left with code that’s easier to read, write, and understand.</p>
<p id="calibre_link-445" class="calibre19">We’re not here to tell you that macros are the solution to all problems, or that you should use a DSL when a function call should do. We’ll use macros when they can dramatically simplify your daily tasks, making them easier to understand and produce. When we do build a DSL, you can bet that we’ve done our best to make it fast and intelligent.
</p><h3 class="calibre22">Effortlessly Extensible Architecture</h3>
<p id="calibre_link-446" class="calibre19">


The Phoenix framework gives you the right set of abstractions for extension. Your applications will break down into individual functions. Rather than rely on other mechanisms like inheritance that hide intentions, you’ll roll up your functions into <span class="calibre4">pipelines</span>, where each function feeds into the next. It’s like building a shopping list for your requests.</p>
<p id="calibre_link-447" class="calibre19">In this book, you’ll write your own authentication code, based on secure open standards. You’ll see how easy it is to tune behavior to your needs and extend it when you need to.</p>
<p id="calibre_link-448" class="calibre19">The Phoenix abstractions, in their current incarnation, are new, but each has withstood the test of time. When it’s time to extend Phoenix&mdash;whether you’re plugging in your own session store or doing something as comprehensive as attaching third-party applications like a Twitter wrapper&mdash;you’ll have the right abstractions available to ensure that the ideas can scale as well as they did when you wrote the first line of code.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-163"><div id="calibre_link-449" class="calibre2"><h2 id="calibre_link-70" class="calibre20">Interactive</h2>
<p id="calibre_link-450" class="calibre19">
By this point, you may be noticing that each concept builds on the previous one. Elixir makes productive, explicit layers available to programmers who can use them to build concurrent applications. Phoenix introduces beautiful, concurrent abstractions for use in beautiful APIs.</p>
<p id="calibre_link-451" class="calibre19">
For the first four years, the Phoenix team worked at building this infrastructure, and this past year we’ve seen the culmination of this investment in new, exciting APIs for building interactive applications. The best example is Phoenix LiveView, a library for building applications without custom JavaScript. Until the right infrastructure was in place, LiveView could be only a dream.</p>
<p id="calibre_link-452" class="calibre19">
Building interactive applications does require APIs that shield many different concerns from an end user, but APIs are just the tip of the iceberg. Underneath that tip is a tremendous amount of infrastructure. Let’s take a peak beneath the surface.</p><h3 class="calibre22">Scaling by Forgetting</h3>
<p id="calibre_link-453" class="calibre19">


Traditional web servers scale by treating each tiny user interaction as an identical stateless request. The application doesn’t save state between requests at all. It simply looks up the user and simultaneously looks up the context of the conversation in a user session. Presto. All scalability problems go away because there’s only one type of connection.</p>
<p id="calibre_link-454" class="calibre19">But there’s a cost. The developer must keep track of the state for each request, and that burden can be particularly arduous for newer, more interactive applications with intimate, long-running rich interactions. As a developer, until now, you’ve been forced to make a choice between  applications that intentionally forget important details to scale and applications that try to remember too much and break under load.</p><h3 class="calibre22">Processes and Channels</h3>
<p id="calibre_link-455" class="calibre19">

With Elixir, you can create hundreds of thousands of <span class="calibre4">lightweight processes</span> without breaking a sweat. Lightweight processes also mean lightweight connections, and that matters because <span class="calibre4">connections can be conversations</span>. Whether you’re building a chat on a game channel or a map to the grocery store, you won’t have to juggle the details by hand anymore. This application style is called <span class="calibre4">channels</span>, and Phoenix makes it easy. Here’s what a typical channels feature might look like:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ handle_in(​<em class="string">"</em>​​<em class="string">new_annotation"</em>​, params, socket) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  broadcast! socket, ​<em class="string">"</em>​​<em class="string">new_annotation"</em>​, %{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">user:</em>​ %{​<em class="string">username:</em>​ ​<em class="string">"</em>​​<em class="string">anon"</em>​},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">body:</em>​ params[​<em class="string">"</em>​​<em class="string">body"</em>​],</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">at:</em>​ params[​<em class="string">"</em>​​<em class="string">at"</em>​]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {​<em class="string">:reply</em>​, ​<em class="string">:ok</em>​, socket}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-456" class="calibre19">You don’t have to understand the details. Just understand that when your application needs to connect your users and broadcast information in real time, your code can get much simpler and faster.</p>
<p id="calibre_link-457" class="calibre19">



Even now, you’ll see many different types of frameworks begin to support channel-style features, from Java to JavaScript and even Ruby. Here’s the problem. None of them comes with the simple guarantees that Phoenix has: isolation and concurrency. Isolation guarantees that if a bug affects one channel, all other channels continue running. Breaking one feature won’t bleed into other site functionality. Concurrency means one channel can never block another one, whether code is waiting on the database or crunching data. This key advantage means that the UI never becomes unresponsive because the user started a heavy action. Without those guarantees, the development bogs down into a quagmire of low-level concurrency details.</p>
<p id="calibre_link-458" class="calibre19">

You may also be wondering whether keeping an open connection per user can scale. The Phoenix team decided to benchmark their channels abstraction and they were able to reach two million connections on a single node.<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-222" href="#calibre_link-164">[4]</a></sup> And while that proves Phoenix Channels scale vertically (i.e., on powerful machines), it also scales horizontally. If you need to run a cluster of Phoenix instances, Phoenix will broadcast messages across all nodes out of the box, without a need for external dependencies.</p>
<p id="calibre_link-459" class="calibre19">It’s true, you can build these kinds of applications without Phoenix, but building them without the guarantees of isolation and concurrency is never pleasant. The results will almost universally be infected with reliability and scalability problems, and your users will never be as satisfied as you’d like to make them.</p><h3 class="calibre22">Presence and LiveView</h3>
<p id="calibre_link-460" class="calibre19">


As Phoenix grows and matures, the team continues to provide tools developers can use to build interactive applications. The first addition was support for tracking presence. Tracking which users are connected to a cluster of machines is a notoriously difficult problem. But in Phoenix, it takes as little as ten lines of code to track which users, fridges, cars, doors, or houses are connected to your application. In a world that is getting more and more connected, this feature is essential.</p>
<p id="calibre_link-461" class="calibre19">The best part about presence is that it doesn’t require any external dependencies. Regardless of whether you are running two Phoenix nodes or twenty, those nodes will communicate with each other, making sure to track connections regardless of where they happen in the cluster. You get a fantastic feature set right out of the box.</p>
<p id="calibre_link-462" class="calibre19">The most recent interactive development tool is <span class="cf">LiveView</span>. <span class="cf">LiveView</span> allows developers to build rich, interactive real-time applications without writing custom JavaScript.<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-223" href="#calibre_link-165">[5]</a></sup> For the JavaScript developers out there, it can be summarized as “server-side React”. Here is a simple counter built with <span class="cf">LiveView</span>:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ DemoWeb.CounterLive ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ Phoenix.LiveView</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ render(assigns) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">~</strong>​L​<em class="string">"""</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">    &lt;span&gt;&lt;%= @val %&gt;&lt;/span&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">    &lt;button phx-click="inc"&gt;+&lt;/button&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">    """</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ mount(_session, socket) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, assign(socket, ​<em class="string">val:</em>​ 0)}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ handle_event(​<em class="string">"</em>​​<em class="string">inc"</em>​, _, socket) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:noreply</em>​, update(socket, ​<em class="string">:val</em>​, &amp;(&amp;1 + 1))}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-463" class="calibre19">When Phoenix renders the page the first time, it works just like any other static page. That means browsers get a fast first-page view and search engines have something to index. Once rendered, Phoenix connects to the LiveView on the server, using WebSockets and Channels. LiveView applications are breathtakingly simple:</p><ul class="calibre28"><li class="calibre29">A function renders a web page.</li><li class="calibre29">That function accepts state as an input and returns a web page as output.</li><li class="calibre29">Events can change that state, bit by bit.</li></ul>
<p id="calibre_link-464" class="calibre19">

State is a simple data structure that can hold whatever you want it to. Events that change your state can come from a button or a form on a web page. Other events can come from your application, like a low-battery sensor elsewhere in your application.</p>
<p id="calibre_link-465" class="calibre19">The best part is that LiveView is smart enough to send only what changes, and only when it changes. And once again, all you need to make this work is Phoenix.</p>
<p id="calibre_link-466" class="calibre19">Combine LiveView with Phoenix’s ability to broadcast changes and track users in a cluster and you have the most complete tooling for building rich and interactive applications out of the box.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-219"><div id="calibre_link-467" class="calibre2"><h2 id="calibre_link-71" class="calibre20">Reliable</h2>
<p id="calibre_link-468" class="calibre19">


As Chris followed José into the Elixir community, he learned to appreciate the frameworks that Erlang programmers have used to make the most reliable applications in the world. Before Elixir, the language of linked and supervised processes wasn’t part of his vocabulary. After spending some time with Elixir, he found the missing pieces he’d been seeking.</p>
<p id="calibre_link-469" class="calibre19">



You see, you might have interactive applications built from beautiful, concurrent, responsive code, but it doesn’t matter unless your code is reliable. Erlang applications have always been more reliable than others in the industry. The secret is the process linking structure and the process communication, which allow effective supervision. You can start concurrent tasks and services that are fully supervised. When one crashes, Elixir can restart it in the last known good state, along with any tainted related service. Erlang’s supervisors can have supervisors too, so your whole application will have a tree of supervisors.</p>
<p id="calibre_link-470" class="calibre19">
The nice thing is that you won’t have to write that supervision code yourself. By default, Phoenix has set up most of the supervision structure for you. For example, if you want to talk to the database, you need to keep a pool of database connections, and Phoenix provides one out of the box. As you’ll see later on, we can monitor and introspect this pool. It’s straightforward to study bottlenecks and even emulate failures by crashing database connections on purpose, only to see supervisors establishing new connections in their place. As a programmer, these abstractions will give you the freedom of a carpenter building on a fresh clean slab, <span class="calibre4">but your foundation solves many of your hardest problems before you even start</span>. As an administrator, you’ll thank us every day of the week because of the support calls that don’t come in.</p>
<p id="calibre_link-471" class="calibre19">In the next chapter, you’ll dive right in. From the beginning, you’ll build a quick application, and we’ll walk you through each layer of Phoenix. The water is fine. Come on in!</p>

<div class="footnotes">
<h4 class="calibre24">Footnotes</h4>
<dl class="calibre25">
<dt class="footnote-number"><a id="calibre_link-258" href="#calibre_link-220" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[2]</a></dt><dd class="calibre26">
<p id="calibre_link-472" class="calibre27"><a href="https://hexdocs.pm/plug/Plug.Session.html" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://hexdocs.pm/plug/Plug.Session.html</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-296" href="#calibre_link-221" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[3]</a></dt><dd class="calibre26">
<p id="calibre_link-473" class="calibre27"><a href="https://www.techworld.com/apps-wearables/how-elixir-helped-bleacher-report-handle-8x-more-traffic-3653957/" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://www.techworld.com/apps-wearables/how-elixir-helped-bleacher-report-handle-8x-more-traffic-3653957/</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-164" href="#calibre_link-222" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[4]</a></dt><dd class="calibre26">
<p id="calibre_link-474" class="calibre27"><a href="https://phoenixframework.org/blog/the-road-to-2-million-websocket-connections" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://phoenixframework.org/blog/the-road-to-2-million-websocket-connections</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-165" href="#calibre_link-223" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[5]</a></dt><dd class="calibre26">
<p id="calibre_link-475" class="calibre27"><a href="https://dockyard.com/blog/2018/12/12/phoenix-liveview-interactive-real-time-apps-no-need-to-write-javascript" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://dockyard.com/blog/2018/12/12/phoenix-liveview-interactive-real-time-apps-no-need-to-write-javascript</a></p></dd></dl></div>
<div class="copyright">Copyright © 2020, The Pragmatic Bookshelf.</div>




</div>



  </div>


<div class="calibre1" id="calibre_link-247"><div id="calibre_link-476" class="calibre2"><h1 class="part-title" id="calibre_link-72"><span class="part-number">Part 1</span><br class="calibre18" />Building with Functional MVC</h1><blockquote class="partintro" id="calibre_link-477">
<p id="calibre_link-478" class="calibre32">In Part I, we’ll talk about traditional request/response web applications. We’ll walk through the basic layers of Phoenix in great detail. You’ll learn how to structure your application into small functions, with each one transforming the results of the previous ones. This pipeline of small functions will lead to the controller, from where we call your model domain and views, but splitting the responsibilities slightly differently from what you’ve seen elsewhere. You’ll also learn to integrate databases through the Ecto persistence layer and even build your own authentication API. Then, you’ll learn to test what you’ve built so far. In short, you’ll learn to build traditional applications that are faster, more reliable, and easier to understand.</p></blockquote>


</div>



  </div>


<div class="calibre1" id="calibre_link-277"><div id="calibre_link-479" class="calibre2"><h1 class="pcalibre6 chapter-title" id="calibre_link-73"><span class="chapter-number">
            Chapter
            2</span><br class="calibre18" /><span class="chapter-name">The Lay of the Land</span></h1>

<p id="calibre_link-480" class="calibre19">Welcome to Phoenix. In this chapter, we’re not going to try to sell you too hard. We think that once you begin the work of learning this framework, the benefits will quickly become evident.</p>
<p id="calibre_link-481" class="calibre19">You can think of any web server as a function. Each time you type a URL, think of it as a function call to some remote server. That function takes your request and generates some response. As we will see, <span class="calibre4">a web server is a natural problem for a functional language to solve.</span></p>
<p id="calibre_link-482" class="calibre19">When all is said and done, each Phoenix application is made of functions. In this chapter, we’re going to break down a typical web request, and we’ll talk about what happens from the moment the user types the URL to the moment Phoenix returns some result.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-1"><div id="calibre_link-483" class="calibre2"><h2 id="calibre_link-74" class="calibre20">Simple Functions</h2>
<p id="calibre_link-484" class="calibre19">



Phoenix is built on Elixir, which is a beautiful language, so we’re going to use Elixir to talk about the way the layers of Phoenix fit together. In Elixir, we might have a couple of functions like these:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ inc(x), ​<strong class="kw">do</strong>​: x + 1</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ dec(x), ​<strong class="kw">do</strong>​: x - 1</td></tr></table>
<p id="calibre_link-485" class="calibre19">
We can chain together several different function calls like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">2 |&gt; inc |&gt; inc |&gt; dec</td></tr></table>
<p id="calibre_link-486" class="calibre19">




The <span class="cf">|&gt;</span>, or <span class="calibre4">pipe operator</span>, takes the value on the left and passes it as the first argument to the function on the right. We call these compositions <span class="calibre4">pipes</span> or <span class="calibre4">pipelines</span>, and we call each individual function a <span class="calibre4">segment</span> or <span class="calibre4">pipe segment</span>.</p>
<p id="calibre_link-487" class="calibre19">



There’s a side benefit, though. Pipelines are also functions. That means you can make pipelines of pipelines. This idea will help you understand how the various layers fit together. Let’s take a look at what a Phoenix program might look like, using pipes:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">connection |&gt; phoenix</td></tr></table>
<p id="calibre_link-488" class="calibre19">

Most of the time, you’d write <span class="cf">phoenix(connection)</span>, but bear with us for a moment. We’re going to expand that <span class="cf">phoenix</span> function in a bit. We don’t care how the request gets to Phoenix. At some point, we know that a browser establishes a <span class="cf">connection</span> with an end user, and then there’s this big hairy function called <span class="cf">phoenix</span>. We pipe the connection into <span class="cf">phoenix</span>, it does its magic, and we’re done.</p>
<p id="calibre_link-489" class="calibre19">
In Phoenix, that <span class="cf">connection</span> is the whole universe of things we need to know about a user’s request. It is a <span class="calibre4">struct</span>, which is a map with a known set of fields. The connection comes in with information about the <span class="calibre4">request</span>: whether it’s HTTP or HTTPS, what the URL is, what the parameters look like. Then, each layer of Phoenix makes a little change to that connection.  When Phoenix is done, that <span class="cf">connection</span> will have the response in it.</p><h3 class="calibre22">Where Are All of the Diagrams?</h3>
<p id="calibre_link-490" class="calibre19">

In this book, we’re going to try something a little different. We’re going to use an experimental alternative to architectural diagrams.</p>
<p id="calibre_link-491" class="calibre19">For example, let’s say we’re showing you how to bake a cake.  We could have a little diagram with boxes representing process steps that have beautiful bevels or drop shadows or other embellishments. Such a diagram would give you a quick mental picture of what’s happening. Then, you could mentally translate that diagram into code.</p>
<p id="calibre_link-492" class="calibre19">We can do better, though. Instead, we could choose to express the same idea
with an Elixir pipe, like this:</p><table class="processedcode1"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   ingredients</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; mix()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; bake()</td></tr></table>
<p id="calibre_link-493" class="calibre19">That code isn’t as beautiful as a blinking diagram with fountain fills, but it’s tremendously exciting. That ugly text shows you exactly what the layers are, and also how the functions work together. It also helps you build a mental picture of what’s happening, because in Phoenix it <span class="calibre4">is what’s happening.</span> When you understand <span class="calibre4">that</span> diagram, you understand Phoenix. You’ll actually see code like that throughout the Phoenix framework, so we think it’s an excellent way to show how the parts fit together.</p>
<p id="calibre_link-494" class="calibre19">Now you know what the API of <span class="calibre4">every layer of Phoenix looks like.</span> Functions call other functions, and the first argument for each of those other functions is the <span class="cf">connection</span>.</p><h3 class="calibre22">The Layers of Phoenix</h3>
<p id="calibre_link-495" class="calibre19">Let’s take our simplified version of Phoenix and break it down a bit. Let’s say that the request is a classic HTTP-style request. (The book will cover the more interactive channels API a little later, but the basic premise will be the same.) As we drill down to the next layer of detail, here’s what you see:</p><table class="processedcode1"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   connection</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; endpoint()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; router()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; pipelines()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; controller()</td></tr></table>
<p id="calibre_link-496" class="calibre19">





Each request comes in through an <span class="cf">endpoint</span>, the first point of contact. It’s literally the end, or the beginning, of the Phoenix world. A request comes into an endpoint. From there, requests go into
our <span class="cf">router</span> layer, which directs a request into the appropriate <span class="cf">controller</span>, after passing it through a series of <span class="cf">pipelines</span>. As you might expect, a pipeline groups functions together to handle common tasks. You might have a pipeline for browser requests, and another for JSON requests.</p><h3 class="calibre22">Inside Controllers</h3>
<p id="calibre_link-497" class="calibre19">






Web frameworks have been around for a long time. The main pattern we use has been around even longer. The Smalltalk language introduced a pattern called <span class="calibre4">model-view-controller</span> (MVC). Models access data, views present data, and controllers coordinate between the two. In a sense, the purpose of a web server is to get requests to functions that perform the right task. In most web frameworks, including Phoenix, that task is called an <span class="calibre4">action</span>, and we group like functions together in controllers.</p>
<p id="calibre_link-498" class="calibre19">To give you a little more perspective, the controller is also a pipeline of functions, one that looks like this:</p><table class="processedcode1"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   connection</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; controller()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; common_services()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; action()</td></tr></table>
<p id="calibre_link-499" class="calibre19">

This view of the world may look much like what you’d expect from a typical web framework. The connection flows into the controller and calls common services. In Phoenix, those common services are implemented with Plug. You’ll get more details as we go. For now, think of Plug as a strategy for building web applications and a library with a few simple tools to enable that strategy.</p>
<p id="calibre_link-500" class="calibre19">In this book our actions will do many different things, from accessing other websites to authenticating a user. Most often, our actions will access a database and render a view. Here’s what an action to show a user might look like:</p><table class="processedcode1"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   connection</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; find_user()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; view()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; template()</td></tr></table>
<p id="calibre_link-501" class="calibre19">



In Phoenix, we like to encapsulate all business logic in simple modules called <span class="calibre4">contexts</span>. If you’re using a database in Phoenix, you’ll probably use Ecto, the persistence layer. If you want to talk to another web application, there are many HTTP clients to choose from. Whether that code interacts with another web server or a database, you will want to keep the controllers clean and skinny.</p>
<p id="calibre_link-502" class="calibre19">There you have it. You don’t have to memorize all of these layers now, but you’ve seen the major pieces, and you know how they fit together. After a few pages of theory, you’re probably eager to roll up your sleeves and get started.





</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-48"><div id="calibre_link-503" class="calibre2"><h2 id="calibre_link-75" class="calibre20">Installing Your Development Environment</h2>
<p id="calibre_link-504" class="calibre19">



Like many great programming projects, Phoenix builds on some of the best open source projects available. You’ll install all of those dependencies now, using the best resources you can find for your own environment.</p><h3 class="calibre22">Elixir Needs Erlang</h3>
<p id="calibre_link-505" class="calibre19">



Erlang provides the base programming virtual machine. It supports our base programming model for concurrency, failover, and distribution. It also provides an exhaustive programming library that’s the foundation of the Elixir language. Go download Erlang,<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-316" href="#calibre_link-49">[6]</a></sup> choosing the best installation for your environment. You’ll want version 20.0 or greater.</p><h3 class="calibre22">Phoenix Needs Elixir</h3>
<p id="calibre_link-506" class="calibre19">







The Elixir programming language powers Phoenix. You can find installation instructions on the Elixir<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-317" href="#calibre_link-50">[7]</a></sup> site. You’ll want version 1.6 or greater. Before you work through this book, it would be helpful to know Elixir. Good online resources<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-318" href="#calibre_link-51">[8]</a></sup> exist, but we recommend the excellent book <em class="calibre4">Programming Elixir</em>&nbsp;[Tho16], by Dave Thomas, which will get you all of the way through concurrency concepts and OTP. For now, think of OTP as the layer for managing concurrent, distributed services. Rest assured that you’ll get more details on OTP later.</p>
<p id="calibre_link-507" class="calibre19">You can check to see that Elixir and Erlang are working correctly, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">elixir</strong>​​<strong class="kw"> </strong>​​<strong class="kw">-v</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Elixir 1.8.0</td></tr></table>
<p id="calibre_link-508" class="calibre19">

Let’s also install Hex, Elixir’s package manager:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">local.hex</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating ~/.mix/archives/hex-0.19.0</td></tr></table>
<p id="calibre_link-509" class="calibre19">

Elixir is working, and if you were building strictly a JSON API or a very simple application it would be enough. For this application, since you’ll be building both frontend and backend with Phoenix, you need to install a database and the code that will help you manage assets. That means you’ll have to install PostgreSQL and Node.js.</p><h3 class="calibre22">Ecto Needs PostgreSQL</h3>
<p id="calibre_link-510" class="calibre19">




Ecto uses the PostgreSQL<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-319" href="#calibre_link-52">[9]</a></sup> database adapter by default, and Phoenix adopts this default. It’s the database engine we’ll be using throughout the book, so you’ll need version 9.5 or greater. You can check your local version like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">psql</strong>​​<strong class="kw"> </strong>​​<strong class="kw">--version</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">psql (PostgreSQL) 9.5.1</td></tr></table><h3 class="calibre22">Node.js for Assets</h3>
<p id="calibre_link-511" class="calibre19">









Web development often requires web assets to be processed for deployment. Rather than reinvent the wheel, developers can optionally use Node.js tools for those services. Phoenix will use <span class="cf">webpack.js.org</span> to compile static assets  such as JavaScript and CSS by default, and webpack uses npm, the Node.js package manager, to install its dependencies. Once it’s installed, Phoenix will rely on them for asset management. Follow the directions on the Node.js<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-320" href="#calibre_link-53">[10]</a></sup> site and make sure you have version 5.3.0 or greater. Test your installation like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">node</strong>​​<strong class="kw"> </strong>​​<strong class="kw">--version</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">v5.3.0</td></tr></table>
<p id="calibre_link-512" class="calibre19">




Phoenix has a feature called <span class="calibre4">live reloading</span>, which automatically reloads web pages as our assets and templates change. If you’re running Linux, you’re also going to need to install inotify<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-321" href="#calibre_link-54">[11]</a></sup> to support live reloading. Other operating systems are covered.</p>
<p id="calibre_link-513" class="calibre19">We’re finally ready for Phoenix.</p><h3 class="calibre22">Phoenix</h3>
<p id="calibre_link-514" class="calibre19">


You’re going to work in the Elixir language to write your code, so you’ll use the Mix utility to run development tasks. Let’s use Mix to install the Phoenix archive, and then to install Phoenix itself:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">$  mix archive.install hex phx_new</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating ~/.mix/archives/phx_new</td></tr></table>
<p id="calibre_link-515" class="calibre19">

In case you already had Phoenix installed, make sure you have version v1.4.7 or later:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">$  mix phx.new -v</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Phoenix v1.4.7</td></tr></table>
<p id="calibre_link-516" class="calibre19">Now you’re ready to roll!



</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-198"><div id="calibre_link-517" class="calibre2"><h2 id="calibre_link-76" class="calibre20">Creating a Throwaway Project</h2>
<p id="calibre_link-518" class="calibre19">
Since C programmers wrote the first “Hello, World” examples in 1978, it’s traditionally been the first program you write when learning almost any language. So we don’t break with tradition, we’re going to create a “Hello, World” application as our first project. It will help you get your feet wet. When you’re done, you’ll get to see all of those layers we talked about in practice.</p>
<p id="calibre_link-519" class="calibre19">You now have a shiny new Phoenix installation. It’s time to build a project. You’re in a functional language, so you’re going to spend all of your time writing functions. This common project structure will help you organize things so you don’t have to reimagine it for each project.</p>
<p id="calibre_link-520" class="calibre19">



In Elixir, repetitive tasks that manage the programming cycle will run in Mix. Each time you call this utility, you specify a <span class="calibre4">task</span>&mdash;an Elixir script&mdash;to run. Let’s use a task now to create our first Phoenix project, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">phx.new</strong>​​<strong class="kw"> </strong>​​<strong class="kw">hello</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating hello/config/config.exs</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...</span>​</td></tr></table><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Fetch and install dependencies? [Yn] y</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* running mix deps.get</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* running mix deps.compile</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...</span>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">cd</strong>​​<strong class="kw"> </strong>​​<strong class="kw">hello</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">cd</strong>​​<strong class="kw"> </strong>​​<strong class="kw">assets</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">npm</strong>​​<strong class="kw"> </strong>​​<strong class="kw">install</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...</span>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">cd</strong>​​<strong class="kw"> </strong>​​<strong class="kw">..</strong>​</td></tr></table>
<p id="calibre_link-521" class="calibre19">We’re all set! We created a new project and built our static assets. At the bottom of the <span class="cf">mix phx.new</span> output, you can see a few sentences that tell you what to do next. Change into the <span class="cf">hello</span> directory and run the mix tasks to create the database and boot up the Phoenix web server, which will start looking for requests on port 4000.</p>
<p id="calibre_link-522" class="calibre19">Run your Phoenix application like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">ecto.create</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">phx.server</strong>​</td></tr></table>
<p id="calibre_link-523" class="calibre19">






</p><table class="simpletable"><thead class="calibre33"><tr class="calibre34"><th colspan="2" class="outerlines"><p class="calibre31">Database errors</p></th></tr></thead><tbody class="calibre35"><tr class="tr"><td class="calibre36">
               <img id="calibre_link-524" class="calibre37" src="images/000035.png" alt="images/aside-icons/info.png" width="283" height="300" />
             </td><td class="calibre38">

  <p class="calibre31">
    If you receive database errors when running <span class="cf1">mix ecto.create</span>, double-check your <span class="cf1">Hello.Repo</span> username and password values in <span class="cf1">config/dev.exs</span> and match your system settings where necessary.
  </p>
</td></tr></tbody></table>
<p id="calibre_link-525" class="calibre19">

You can see that the server started on port 4000. The <span class="cf">[info]</span> blocks tell you exactly where this server is running. Point your browser to <span class="cf">http://localhost:4000/</span>. You can see a <a href="#calibre_link-199" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">simple Phoenix welcome page</a>.</p><div id="calibre_link-199" class="praise"><div class="praise"><img id="calibre_link-526" class="border" src="images/000001.png" alt="images/src/getting_started/welcome.png" /></div></div>
<p id="calibre_link-527" class="calibre19">And we’re live! There’s no way we’re going to get a million-dollar valuation with this product, though. Let’s begin to change that by building our first feature.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-239"><div id="calibre_link-528" class="calibre2"><h2 id="calibre_link-77" class="calibre20">Building a Feature</h2>
<p id="calibre_link-529" class="calibre19">






Our first feature won’t be complicated. It’ll print a string when you load a specific URL. To build that feature, we’re going to use a small fraction of the files that <span class="cf">mix phx.new</span> created. Don’t worry. You’ll get a tour of the whole tree a little later. For now, everything we need is in the <span class="cf">lib/hello_web</span> subdirectory. We’ll edit <span class="cf">router.ex</span> to point a URL to our code. We’ll also add a controller to the <span class="cf">lib/hello_web/controllers</span> subdirectory, a view to <span class="cf">lib/hello_web/views</span>, and a template to <span class="cf">lib/hello_web/templates</span>.</p>
<p id="calibre_link-530" class="calibre19">






First things first. We want to map requests coming in to a specific URL to the code that satisfies our request. We’ll tie a URL to a function on a controller, and that function to a view. You’ll do so in the routing layer, as you would for other web frameworks. Routes in Phoenix go in <span class="cf">lib/hello_web/router.ex</span> by default. The <span class="cf">.ex</span> extension is for compiled Elixir files. Take a look at that file now. Scroll to the bottom, and you’ll find a block that looks like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/getting_started/listings/hello/lib/hello_web/router.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">getting_started/listings/hello/lib/hello_web/router.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">scope ​<em class="string">"</em>​​<em class="string">/"</em>​, HelloWeb ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  pipe_through ​<em class="string">:browser</em>​ ​<em class="comment"># Use the default browser stack</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  get ​<em class="string">"</em>​​<em class="string">/"</em>​, PageController, ​<em class="string">:index</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-531" class="calibre19">




You can see a block of requests, scoped to <span class="cf">/</span>. That means that this group of routes will attempt to match all routes beginning with <span class="cf">/</span>. The <span class="cf">pipe_through :browser</span> macro handles some housekeeping for all common browser-style requests. You can see one route that takes requests that look like <span class="cf">/</span> and sends them to the <span class="cf">:index</span> action on the <span class="cf">PageController</span>. This looks like the right place to add our route. Add the following route <span class="calibre4">above the existing route</span>:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">get ​<em class="string">"</em>​​<em class="string">/hello"</em>​, HelloController, ​<em class="string">:world</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">get ​<em class="string">"</em>​​<em class="string">/"</em>​, PageController, ​<em class="string">:index</em>​</td></tr></table>
<p id="calibre_link-532" class="calibre19">This new code will match routes starting with <span class="cf">/hello</span> and send them to the <span class="cf">:world</span> function on the <span class="cf">HelloController</span> module. If you’d like, you can point your browser to <span class="cf">localhost:4000/hello</span>, but you’ll get an error page because our controller module doesn’t exist yet:</p><div class="praise"><div class="praise"><img id="calibre_link-533" class="border1" src="images/000003.png" alt="images/src/getting_started/hello_error.png" /></div></div>
<p id="calibre_link-534" class="calibre19">

Before moving forward, let’s briefly review the error page. At the top of the page we get the exception name: <span class="cf">UndefinedFunctionError</span>. Next, we see the error message. It seems <span class="cf">HelloWeb.HelloController.init</span>, which expects one argument, is undefined because the module does not exist. That’s a good start and you can also see the detailed code related to the error.</p>
<p id="calibre_link-535" class="calibre19">

The lefthand pane will usually show the relevant code snippets. Because the module in this case does not exist, there is no code snippet loaded by default, but you can populate this pane by clicking any of the stacktrace entries on the righthand side. In the stack trace, orange dots denote calls within the application and gray ones identify dependency code. Finally the bottom of the page has general request information, such as request headers, cookies, session, and the like.</p>
<p id="calibre_link-536" class="calibre19">

Let’s fix that error now. All controllers in Phoenix are in <span class="cf">lib/hello_web/controllers</span>. Create a <span class="cf">lib/hello_web/controllers/hello_controller.ex</span> file that looks like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/getting_started/listings/hello/lib/hello_web/controllers/hello_controller.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">getting_started/listings/hello/lib/hello_web/controllers/hello_controller.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ HelloWeb.HelloController ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ HelloWeb, ​<em class="string">:controller</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ world(conn, _params) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    render(conn, ​<em class="string">"</em>​​<em class="string">world.html"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-537" class="calibre19">


This controller is simple. If you’re new to Elixir, you’ll often see <span class="cf">use SomeModule</span> to introduce specific functionality to a module. The <span class="cf">use HelloWeb, :controller</span> call prepares us to use the Phoenix Controller API, including making some functions available that we’ll want to use later. The router will call the <span class="cf">world</span> action on our controller, passing all of the information we need. We call the functions invoked by the router on our controller’s actions, but don’t get confused. They’re just functions.</p>
<p id="calibre_link-538" class="calibre19">Once again, you might point your browser to <span class="cf">localhost:4000/hello</span>, but you’d find that it’s still not working. We have yet to create our view, so Phoenix reports:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">undefined function: HelloWeb.HelloView.render/2</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    (module HelloWeb.HelloView is not available)</td></tr></table>
<p id="calibre_link-539" class="calibre19">

That makes sense. Let’s easily fix that problem by creating a view called <span class="cf">lib/hello_web/views/hello_view.ex</span> with the following contents:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/getting_started/listings/hello/lib/hello_web/views/hello_view.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">getting_started/listings/hello/lib/hello_web/views/hello_view.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ HelloWeb.HelloView ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ HelloWeb, ​<em class="string">:view</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-540" class="calibre19">

That file doesn’t actually do any work beyond tying the view for <span class="cf">world</span> with some code to render a template. We’ll rely on the defaults to render a template, which doesn’t yet exist. One more time, you see an error when you point your browser to <span class="cf">localhost:4000/hello</span>:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Could not render "world.html" for HelloWeb.HelloView, please define a matching</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">clause for render/2 or define a template at "lib/hello_web/templates/hello".</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  No templates were compiled for this module.</td></tr></table>
<p id="calibre_link-541" class="calibre19">We are getting closer. Create the following template at <span class="cf">lib/hello_web/templates/hello/world.html.eex</span>, and we’re done:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/getting_started/listings/hello/lib/hello_web/templates/hello/world.html.eex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">getting_started/listings/hello/lib/hello_web/templates/hello/world.html.eex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;h1&gt;From template: Hello world!&lt;/h1&gt;</td></tr></table>
<p id="calibre_link-542" class="calibre19">


As soon as you save your code, notice that the web page reloads! We have live reloading enabled, so whenever we touch templates or template assets, you’ll see an automatic page reload.</p>
<p id="calibre_link-543" class="calibre19">

The <span class="cf">.eex</span> extension denotes a template, which Phoenix will compile into a function. If you look closely, you can see the page we loaded has a header. We’re implicitly using the layout defined in the <span class="cf">lib/hello_web/views/layout_view.ex</span> view and the template defined in <span class="cf">lib/hello_web/templates/layout/app.html.eex</span>. We’ll work more with views a little later. For now, it’s enough for you to know it’s there.</p>
<p id="calibre_link-544" class="calibre19">Enjoy the results. It’s not a fully operational death star, but you’re well on your way.</p><h3 class="calibre22">Using Routes and Params</h3>
<p id="calibre_link-545" class="calibre19">



Right now, there’s no dynamic information in our route, and we don’t need any <span class="calibre4">yet</span>, but later we’ll need to grab dynamic data from the URL to look up data from our database. Let’s use our sandbox to see how that works. We’ll use dynamic routes closely with Elixir’s pattern matching. First, let’s revise our route. Replace the first route in <span class="cf">lib/hello_web/router.ex</span> with this one:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">get ​<em class="string">"</em>​​<em class="string">/hello/:name"</em>​, HelloController, ​<em class="string">:world</em>​</td></tr></table>
<p id="calibre_link-546" class="calibre19">

Notice that we’re matching a URL pattern&mdash;<span class="cf">/hello</span>, as before&mdash;but we also add <span class="cf">/:name</span> to the route. The <span class="cf">:</span> tells Phoenix to create a parameter called <span class="cf">:name</span> in our route and pass that name as a parameter to the controller. Change the <span class="cf">world</span> function on <span class="cf">lib/hello_web/controllers/hello_controller.ex</span> to look like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ world(conn, %{​<em class="string">"</em>​​<em class="string">name"</em>​ =&gt; name}) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  render(conn, ​<em class="string">"</em>​​<em class="string">world.html"</em>​, ​<em class="string">name:</em>​ name)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-547" class="calibre19">Since it’s the first time we’re using the shorthand hash notation, we’ll give it a brief introduction. The code <span class="cf">name: name</span> is shorthand for <span class="cf">:name =&gt; name</span>. They are both shorthand notations for representing key-value pairs. <span class="cf">[name: name]</span> is shorthand for <span class="cf">[{:name, name}]</span>. Finally, since <span class="cf">name: name</span> is the last argument, of a function, we can omit the brackets. That means <span class="cf">render(conn, "world.html", name: name)</span> is shorthand for <span class="cf">render(conn, "world.html", [name: name])</span>. Whew. Now, on to the code.</p>
<p id="calibre_link-548" class="calibre19">Our new action uses the second argument, which is a map of inbound parameters. We match to capture the <span class="cf">name</span> key in the <span class="cf">name</span> variable, and pass the result to <span class="cf">render</span> in a keyword list. If you’re new to Elixir, that function header looks a little different from what you might have seen before. Something special is happening, so let’s look at it in a little more detail. If you already understand pattern matching, you can  skip to the next section.</p><h3 class="calibre22">Pattern Matching in Functions</h3>
<p id="calibre_link-549" class="calibre19">



The Elixir language has an excellent feature called <span class="calibre4">pattern matching</span>. When Elixir encounters a <span class="cf">=</span> operator, it means “make the thing on the left match the thing on the right.” You can use this feature in two different ways: to take data structures apart, or to test. Let’s look at an example. Open up interactive Elixir by typing <span class="cf">iex</span> in your OS shell and follow this script:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ {first, second, third} = {​<em class="string">:lions</em>​, ​<em class="string">:tigers</em>​, ​<em class="string">:bears</em>​}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{:lions, :tigers, :bears}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ first</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">:lions</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ {first, second, ​<em class="string">:bears</em>​} = {​<em class="string">:lions</em>​, ​<em class="string">:tigers</em>​, ​<em class="string">:bears</em>​}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{:lions, :tigers, :bears}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ {first, second, ​<em class="string">:armadillos</em>​} = {​<em class="string">:lions</em>​, ​<em class="string">:tigers</em>​, ​<em class="string">:bears</em>​}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">**</strong>​ (MatchError) no match of right hand side value: {:lions, :tigers, :bears}</td></tr></table>
<p id="calibre_link-550" class="calibre19">In the first statement, we’re matching a 3-tuple to <span class="cf">{:lions, :tigers, :bears}</span>. Elixir tries to make the expression on the left match, and it can do so by assigning <span class="cf">first</span> to <span class="cf">:lions</span>, and <span class="cf">second</span> to <span class="cf">:tigers</span>. In this case, we’re using the pattern match to pick off pieces of the inside of the data structure.</p>
<p id="calibre_link-551" class="calibre19">In the third or fourth statement, we’re doing something different. We’re matching to do a test. When the interpreter tries to match the two, it succeeds and passes on, or fails and throws an exception.</p>
<p id="calibre_link-552" class="calibre19">You can also use pattern-matching syntax within your function heads in both of these ways. Type the following into your console:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ austin = %{​<em class="string">city:</em>​ ​<em class="string">"</em>​​<em class="string">Austin"</em>​, ​<em class="string">state:</em>​ ​<em class="string">"</em>​​<em class="string">Tx"</em>​}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%{city: "Austin", state: "Tx"}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ ​<strong class="kw">defmodule</strong>​ Place ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​   ​<strong class="kw">def</strong>​ city(%{​<em class="string">city:</em>​ city}), ​<strong class="kw">do</strong>​: city</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​   ​<strong class="kw">def</strong>​ texas?(%{​<em class="string">state:</em>​ ​<em class="string">"</em>​​<em class="string">Tx"</em>​}), ​<strong class="kw">do</strong>​: true</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​   ​<strong class="kw">def</strong>​ texas?(_), ​<strong class="kw">do</strong>​: false</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​ ​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-553" class="calibre19">


This module uses pattern matching in two different ways. The first function uses pattern matching to destructure the data, or take it apart. We use it to extract the <span class="cf">city</span>. It grabs the value for the <span class="cf">:city</span> key from any map. Although this bit of destructuring is trivial, sometimes the data structures can be deep, and you can reach in and grab the attributes you need with a surgeon’s precision.</p>
<p id="calibre_link-554" class="calibre19">
The second function, <span class="cf">texas?</span>, is using a pattern match as a test. If the inbound map has a <span class="cf">:state</span> keyword that’s set to <span class="cf">Tx</span>, it’ll match. Otherwise, it’ll fall through to the next function, returning <span class="cf">false</span>. If we wanted to, we could:



</p><ul class="calibre28"><li class="calibre29">
<p id="calibre_link-555" class="calibre31">Match all maps with a given key, as in <span class="cf1">has_state?(%{state: _})</span>, where the underscore <span class="cf1">_</span> will match anything</p></li><li class="calibre29">
<p id="calibre_link-556" class="calibre31">Use strings as keys instead of atoms,  as in <span class="cf1">has_state?(%{"state" =&gt; "Tx"})</span></p></li><li class="calibre29">
<p id="calibre_link-557" class="calibre31">Match a state, and assign the whole map to a variable, as in <span class="cf1">has_state?(%{"state" =&gt; "Tx"} = place)</span></p></li></ul>
<p id="calibre_link-558" class="calibre19">The point is, pattern matching is a huge part of Elixir and Phoenix programming. We’ll use it to grab only certain types of connections, and also to grab individual pieces of the connection, conveniently within the function heading.</p>
<p id="calibre_link-559" class="calibre19">With all of that in mind, let’s look at our controller action again:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ world(conn, %{​<em class="string">"</em>​​<em class="string">name"</em>​ =&gt; name}) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  render(conn, ​<em class="string">"</em>​​<em class="string">world.html"</em>​, ​<em class="string">name:</em>​ name)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-560" class="calibre19">That makes more sense now. We’re grabbing the <span class="cf">name</span> field from the second argument, which contains the inbound parameters. Our controller then renders the <span class="cf">world.html</span> template, passing in the local data. The local data prepares a map of variables for use by the templates. Now our views can access the <span class="cf">name</span> variable we’ve specified.</p><div class="xxxsays"><div class="heading"><div class="persons-picture"><img src="images/000048.png" alt="Chris says:" class="calibre40" /></div><div class="label">Chris says:</div><div class="title">Atom Keys vs. String Keys?</div></div><div class="praise">
<p id="calibre_link-561" class="calibre14">





In the <span class="cf">world</span> action in our controllers, the external parameters have string keys, <span class="cf">"name" =&gt; name</span>, while internally we use <span class="cf">name: name</span>. That’s a convention followed throughout Phoenix. External data can’t safely be converted to atoms, because the atom table isn’t garbage-collected. Instead, we explicitly match on the string keys, and then our application boundaries like controllers and channels will convert them into atom keys, which we’ll rely on everywhere else inside Phoenix.
</p></div></div><h3 class="calibre22">Using Assigns in Templates</h3>
<p id="calibre_link-562" class="calibre19">

Now, all that remains is to tweak our template in <span class="cf">lib/hello_web/templates/hello/world.html.eex</span> to make use of the value. You can access the <span class="cf">name</span> specified in the <span class="cf">world</span> action as <span class="cf">@name</span>, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;h1&gt;Hello ​<em class="comment">&lt;%=</em>​ String.capitalize(@name) ​<em class="comment">%&gt;</em>​!&lt;/h1&gt;</td></tr></table>
<p id="calibre_link-563" class="calibre19">
The <span class="cf">&lt;%= %&gt;</span> brackets surround the code we want to substitute into the rendered page. <span class="cf">@name</span> will have the value of the <span class="cf">:name</span> option that we passed to <span class="cf">render</span>. We’ve worked for this reward, so point your browser to <span class="cf">localhost:4000/hello/phoenix</span>. It’s ALIVE!</p><div class="praise"><img id="calibre_link-564" class="border2" src="images/000010.png" alt="images/src/getting_started/hello_phoenix.png" width="630" height="174" /></div>
<p id="calibre_link-565" class="calibre19">We’ve done a lot in a short time. Some of this plumbing might seem like magic to you, but you’ll find that Phoenix is marvelously explicit, so it’s easy to understand exactly what’s happening, when, for each request. It’s time to make this magic more tangible.














</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-269"><div id="calibre_link-566" class="calibre2"><h2 id="calibre_link-78" class="calibre20">Going Deeper: The Request Pipeline</h2>
<p id="calibre_link-567" class="calibre19">



When we created the <span class="cf">hello</span> project, Mix created a bunch of directories and files. It’s time to take a more detailed look at what all of those files do and, by extension, how Phoenix helps you organize applications.</p>
<p id="calibre_link-568" class="calibre19">

When you think about it, typical web applications are just big functions. Each web request is a function call taking a single formatted string&mdash;the URL&mdash;as an argument. That function returns a response that’s nothing more than a formatted string. If you look at your application in this way, your goal is to understand how functions are composed to make the one big function call that handles each request. In some web frameworks, that task is easier said than done. Most frameworks have hidden functions that are only exposed to those with deep, intimate internal knowledge.</p>
<p id="calibre_link-569" class="calibre19">The Phoenix experience is different because it encourages breaking big functions down into smaller ones. Then, it provides a place to explicitly register each smaller function in a way that’s easy to understand and replace. We’ll tie all of these functions together with the Plug library.</p>
<p id="calibre_link-570" class="calibre19">


Think of the Plug library as a specification for building applications that connect to the web. Each plug consumes and produces a common data structure called <span class="cf">Plug.Conn</span>. Remember, that struct represents <span class="calibre4">the whole universe for a given request</span>, because it has things that web applications need: the inbound request, the protocol, the parsed parameters, and so on.</p>
<p id="calibre_link-571" class="calibre19">
Think of each individual plug as a function that takes a <span class="cf">conn</span>, does something small, and returns a slightly changed <span class="cf">conn</span>. The web server provides the initial data for our request, and then Phoenix calls one plug after another. Each plug can transform the <span class="cf">conn</span> in some small way until you eventually send a response back to the user.</p>
<p id="calibre_link-572" class="calibre19">Even responses are just transformations on the connection. When you hear words like <span class="calibre4">request</span> and <span class="calibre4">response</span>, you might be tempted to think that a request is a plug function call, and a response is the return value. That’s not what happens. A response is just one more action on the <span class="cf">connection</span>, like this:</p><table class="processedcode1"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; render_response()</td></tr></table>
<p id="calibre_link-573" class="calibre19">



The whole Phoenix framework is made up of organizing functions that do something small to connections, <span class="calibre4">even rendering the result</span>.
Said another way…</p>
<p id="calibre_link-574" class="calibre19"><span class="calibre4">Plugs  are functions.</span></p>
<p id="calibre_link-575" class="calibre19"><span class="calibre4">Your web applications are pipelines of plugs.</span></p><h3 class="calibre22">Phoenix File Structure</h3>
<p id="calibre_link-576" class="calibre19">




If web applications in Phoenix are functions, the next logical step is to learn where to find those individual functions and how they fit together to build a coherent application.  Let’s work through the project directory structure, focusing on only the most important ones for now. Here’s what your directories look like now:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">├── assets</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">├── config</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">├── lib</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">├──── hello</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">├──── hello_web</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">├── test</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">...</td></tr></table>
<p id="calibre_link-577" class="calibre19">










Browser files like JavaScript and CSS go into <span class="cf">assets</span> and the Phoenix configuration goes into <span class="cf">config</span>. Your supervision trees (we’ll explore those more in chapters to come), long-running processes, and application business logic go into <span class="cf">lib/hello</span>. Your web-related code&mdash;including controllers, views, and templates&mdash;goes in <span class="cf">lib/hello_web</span>. Predictably, you’ll put tests in <span class="cf">test</span>.</p>
<p id="calibre_link-578" class="calibre19">In this section, you will walk through each of these pieces, including the pieces you created and many other ones that Phoenix generated. To sleuth out the entire pipeline of functions for a full web request, you need to start at the beginning. You will start with the basic code that Elixir and Erlang depend on.</p><h3 class="calibre22">Elixir Configuration</h3>
<p id="calibre_link-579" class="calibre19">


Since Phoenix projects are Elixir applications, they have the same structure as other Mix projects. Let’s look at the basic files in the project:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">├── lib</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│   ├── hello</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│   ├── hello_web</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│   │   ├── endpoint.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│   │   └── ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│   ├── hello.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│   └── hello_web.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">├── mix.exs</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">├── mix.lock</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">├── test</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">...</td></tr></table>
<p id="calibre_link-580" class="calibre19">





We’ve already encountered the <span class="cf">.ex</span> files. These contain Elixir code which you’ll compile to the <span class="cf">.beam</span> files that run on the Erlang virtual machine. The <span class="cf">.exs</span> files are Elixir scripts. They’re not compiled to <span class="cf">.beam</span> files. The compilation happens in memory, each time they are run. They’re excellent for quick-changing scripts or standalone development-time tasks.</p>
<p id="calibre_link-581" class="calibre19">
The project we created is a Mix project, named after the build tool that nearly all Elixir projects use. All Mix projects have a common structure. Each project has a configuration file, <span class="cf">mix.exs</span>, containing basic information about the project that supports tasks like compiling files, starting the server, and managing dependencies. When we add dependencies to our project, we’ll need to make sure they show up here. Also, after we compile the project, <span class="cf">mix.lock</span> will include the specific versions of the libraries we depend on, so we guarantee that our production machines use exactly the same versions that we used during development and in our build servers.</p>
<p id="calibre_link-582" class="calibre19">


Each Mix project also has a <span class="cf">lib</span> directory. Support for starting, stopping, and supervising each application is in <span class="cf">lib/hello/application.ex</span>.</p>
<p id="calibre_link-583" class="calibre19">

Also, each Mix project has a <span class="cf">test</span> directory that hosts all tests. Phoenix adds some files to this test structure to support testing-specific files like controllers and views. We have not yet written any tests, but when we do, they will live in <span class="cf">test</span>.</p><h3 class="calibre22">Environments and Endpoints</h3>
<p id="calibre_link-584" class="calibre19">




Your application will run in an environment. The environment contains specific configuration that your web application needs. You can find that configuration in <span class="cf">config</span>:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...</span>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">├── config</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│   ├── config.exs</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│   ├── dev.exs</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│   ├── prod.exs</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│   ├── prod.secret.exs</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│   └── test.exs</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...</span>​</td></tr></table>
<p id="calibre_link-585" class="calibre19">





Phoenix supports a master configuration file plus an additional file for each environment you plan to run in. The environments supported by default are development (<span class="cf">dev.exs</span>), test (<span class="cf">test.exs</span>), and production (<span class="cf">prod.exs</span>), but you can add any others that you want.</p>
<p id="calibre_link-586" class="calibre19">





You can see the three environment files, the master <span class="cf">config.exs</span> file containing application-wide configuration concerns, and a file called <span class="cf">prod.secret.exs</span>, which is responsible to load secrets and other configuration values from environment variables. Those environment variables are usually populated by deployment tasks.</p>
<p id="calibre_link-587" class="calibre19">


You switch between <span class="cf">prod</span>, <span class="cf">dev</span>, and <span class="cf">test</span> environments via the <span class="cf">MIX_ENV</span> environment variable. We’ll spend most of our time in this book in <span class="cf">dev</span> and <span class="cf">test</span> modes. That’ll be easy, because your Mix task will have you working in <span class="cf">dev</span> by default, and it’ll shift to <span class="cf">test</span> when you run automated tests with <span class="cf">mix</span>.</p>
<p id="calibre_link-588" class="calibre19">



The master configuration file, <span class="cf">config/config.exs</span>, initially contains information about logging, and <span class="calibre4">endpoints</span>. Remember when we said that your web applications were just functions? An endpoint is the boundary where the web server hands off the connection to our application code. Now, you’ll see that <span class="cf">config/config.exs</span> contains a single endpoint called <span class="cf">Hello.Endpoint</span>. Open the file called <span class="cf">config/config.exs</span> in your editor:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">use</strong>​ Mix.Config</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment"># Configures the endpoint</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">config ​<em class="string">:hello</em>​, HelloWeb.Endpoint,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="string">url:</em>​ [​<em class="string">host:</em>​ ​<em class="string">"</em>​​<em class="string">localhost"</em>​],</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="string">secret_key_base:</em>​ ​<em class="string">"</em>​​<em class="string">U8VmJ...hNnTsFFvrhmD"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="string">render_errors:</em>​ [​<em class="string">view:</em>​ HelloWeb.ErrorView, ​<em class="string">accepts:</em>​ ​<strong class="kw">~</strong>​w(html json)],</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="string">pubsub:</em>​ [​<em class="string">name:</em>​ Hello.PubSub,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">           ​<em class="string">adapter:</em>​ Phoenix.PubSub.PG2]</td></tr></table>
<p id="calibre_link-589" class="calibre19">Even though you might not understand this entire block of code, you can see that this code has our endpoint, which is the beginning of our world. The <span class="cf">config</span> function call configures the <span class="cf">HelloWeb.Endpoint</span> endpoint in our <span class="cf">:hello</span> application, giving a keyword list with configuration options. Let’s look at that endpoint, which we find in <span class="cf">lib/hello_web/endpoint.ex</span>:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ HelloWeb.Endpoint ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ Phoenix.Endpoint, ​<em class="string">otp_app:</em>​ ​<em class="string">:hello</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  plug Plug.Static, ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  plug Plug.RequestId</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  plug Plug.Telemetry, ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  plug Plug.Parsers, ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  plug Plug.MethodOverride</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  plug Plug.Head</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  plug Plug.Session, ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  plug HelloWeb.Router</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-590" class="calibre19">


You can see that this chain of functions, or plugs, does the typical things that almost all production web servers need to do: deal with static content, log requests, parse parameters, and the like. Remember, you already know how to read this code. It’ll translate to a pipeline of functions, like this:</p><table class="processedcode1"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   connection</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; Plug.Static.call()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; Plug.RequestId.call()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; Plug.Telemetry.call()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; Plug.Parsers.call()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; Plug.MethodOverride.call()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; Plug.Head.call()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; Plug.Session.call()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; HelloWeb.Router.call()</td></tr></table>
<p id="calibre_link-591" class="calibre19">That’s an oversimplification, but the basic premise is correct. Endpoints are the chain of functions at the beginning of each request.</p>
<p id="calibre_link-592" class="calibre19">Now you can get a better sense of what’s going on. Each request that comes in will be piped through this full list of functions. If you want to change the logging layer, you can change logging for all requests by specifying a different logging function here.</p>
<p id="calibre_link-593" class="calibre19">



Summarizing what we have so far: an endpoint is a plug, one that’s made up of other plugs. Your application is a series of plugs, beginning with an endpoint and ending with a controller:</p><table class="processedcode1"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   connection</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; endpoint()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; plug()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; plug()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; router()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; HelloWebController()</td></tr></table>
<p id="calibre_link-594" class="calibre19">


We know that the last plug in the endpoint is the router, and we know we can find that file in <span class="cf">lib/hello_web/router.ex</span>.





</p><div class="xxxsays"><div class="heading"><div class="persons-picture"><img src="images/000024.png" alt="José says:" class="calibre41" /></div><div class="label">José says:</div><div class="title">Can I Have More Than One Endpoint?</div></div><div class="praise">
<p id="calibre_link-595" class="calibre14">

Although applications usually have a single endpoint, Phoenix doesn’t limit the number of endpoints your application can have. For example, you could have your main application endpoint running on port 80 (HTTP) and 443 (HTTPS), as well as a specific admin endpoint running on a special port&mdash;let’s say 8443 (HTTPS)&mdash;with specific characteristics and security constraints.
</p>
<p id="calibre_link-596" class="calibre14">

Alternatively, we could break those endpoints into separate applications but still run them side by side. You’ll explore this later on when learning about umbrella projects.  </p></div></div><h3 class="calibre22">The Router Flow</h3>
<p id="calibre_link-597" class="calibre19">



Now that you know what plugs are, let’s take a fresh look at our router. Crack open <span class="cf">lib/hello_web/router.ex</span>. You can see that it’s made up of two parts: pipelines and a route table. Here’s the first part:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/getting_started/listings/hello/lib/hello_web/router.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">getting_started/listings/hello/lib/hello_web/router.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ HelloWeb.Router ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ HelloWeb, ​<em class="string">:router</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  pipeline ​<em class="string">:browser</em>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    plug ​<em class="string">:accepts</em>​, [​<em class="string">"</em>​​<em class="string">html"</em>​]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    plug ​<em class="string">:fetch_session</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    plug ​<em class="string">:fetch_flash</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    plug ​<em class="string">:protect_from_forgery</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    plug ​<em class="string">:put_secure_browser_headers</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  pipeline ​<em class="string">:api</em>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    plug ​<em class="string">:accepts</em>​, [​<em class="string">"</em>​​<em class="string">json"</em>​]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-598" class="calibre19">

Sometimes, you’ll want to perform a common set of tasks, or transformations, for some logical group of functions. Not surprisingly, you’ll do each transformation step with a plug and group these plugs into pipelines. When you think about it, a pipeline is just a bigger plug that takes a <span class="cf">conn</span> struct and returns one too.</p>
<p id="calibre_link-599" class="calibre19">




In <span class="cf">router.ex</span>, you can see two pipelines, both of which do reasonable things for a typical web application. The <span class="calibre4">browser pipeline</span> accepts only HTML. It provides some common services such as fetching the session and a user message system called the <span class="calibre4">flash</span>, used for brief user notifications. It also provides some security services, such as request forgery protection.</p>
<p id="calibre_link-600" class="calibre19">
We’d use the second pipeline of functions for a typical JSON API. This stack strictly calls the function that accepts only JSON requests, so if you had the idea of converting the whole API site to accept only XML, you could do so by changing one plug in one place.</p>
<p id="calibre_link-601" class="calibre19">Our <span class="cf">hello</span> application uses the <span class="cf">browser</span> pipeline, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/getting_started/listings/hello/lib/hello_web/router.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">getting_started/listings/hello/lib/hello_web/router.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">scope ​<em class="string">"</em>​​<em class="string">/"</em>​, HelloWeb ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  pipe_through ​<em class="string">:browser</em>​ ​<em class="comment"># Use the default browser stack</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  get ​<em class="string">"</em>​​<em class="string">/"</em>​, PageController, ​<em class="string">:index</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-602" class="calibre19">Now you can tell exactly what the pipeline does. All the routes after <span class="cf">pipe_through :browser</span>&mdash;all the routes in our application&mdash;go through the browser pipeline. Then, the router triggers the controller.</p>
<p id="calibre_link-603" class="calibre19">

In general, the router is the last plug in the endpoint. It gets a connection, calls a pipeline, and then calls a controller. When you break it down, every traditional Phoenix application looks like this:</p><table class="processedcode1"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   connection</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; endpoint()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; router()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; pipeline()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; controller()</td></tr></table><ul class="calibre28"><li class="calibre29">
<p id="calibre_link-604" class="calibre31">The endpoint has functions that happen for every request.</p></li><li class="calibre29">
<p id="calibre_link-605" class="calibre31">The connection goes through a named pipeline, which has common functions for each major type of request.

</p></li><li class="calibre29">
<p id="calibre_link-606" class="calibre31">The controller invokes the model and renders a template through a view.</p></li></ul>
<p id="calibre_link-607" class="calibre19">Let’s look at the final piece of this pipeline, the controller.


</p><h3 class="calibre22">Controllers, Views, and Templates</h3>
<p id="calibre_link-608" class="calibre19">







From the previous section, you know that a request comes through an endpoint, through the router, through a pipeline, and into the controller. The controller is the gateway for the bulk of a traditional web application. Like a puppet master, your controller pulls the strings for this application, making data available in the connection for consumption by the view. It potentially fetches database data to stash in the connection and then redirects or renders a view. The view substitutes values for a template.</p>
<p id="calibre_link-609" class="calibre19">For Phoenix, your web-related code, including controllers, views, and templates goes into the <span class="cf">lib/hello_web/</span> directory. Right now, that directory looks like:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">├── hello</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│&nbsp;&nbsp; ├── application.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│&nbsp;&nbsp; └── repo.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">├── hello.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">├── hello_web</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│&nbsp;&nbsp; ├── channels</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│   │   └── user_socket.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│&nbsp;&nbsp; ├── controllers</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── hello_controller.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│&nbsp;&nbsp; │&nbsp;&nbsp; └── page_controller.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│&nbsp;&nbsp; ├── endpoint.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│&nbsp;&nbsp; ├── gettext.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│&nbsp;&nbsp; ├── router.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│&nbsp;&nbsp; ├── templates</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── hello</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│   │   │   └── world.html.eex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│&nbsp;&nbsp; │&nbsp;&nbsp; ├── layout</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│   │   │   └── app.html.eex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│&nbsp;&nbsp; │&nbsp;&nbsp; └── page</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│   │   │   └── index.html.eex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│&nbsp;&nbsp; └── views</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│&nbsp;&nbsp;     ├── error_helpers.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│&nbsp;&nbsp;     ├── error_view.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│&nbsp;&nbsp;     ├── hello_view.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│&nbsp;&nbsp;     ├── layout_view.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">│&nbsp;&nbsp;     └── page_view.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">└── hello_web.ex</td></tr></table>
<p id="calibre_link-610" class="calibre19">
You can see two top-level files, <span class="cf">hello.ex</span> and <span class="cf">hello_web.ex</span>. The <span class="cf">Hello</span> module is an empty module which defines the top-level interface and documentation for your application. The <span class="cf">HelloWeb</span> module contains some glue code that defines the overall
structure to the web-related modules of your application.</p>
<p id="calibre_link-611" class="calibre19">The second part of this book will be dedicated to applications that use the <span class="cf">channels</span> directory, so let’s skip that for now. You’ve already coded a simple controller, so you know what the basic structure looks like.</p>
<p id="calibre_link-612" class="calibre19">





As you might expect for the support of old-style MVC applications, you can see that <span class="cf">lib/hello_web</span> contains directories for views, and
controllers. There’s also a directory for templates&mdash;because
Phoenix separates the views from the templates themselves.</p>
<p id="calibre_link-613" class="calibre19">We’ve created code in the <span class="cf">controller</span>, <span class="cf">views</span>, and <span class="cf">templates/hello</span>
directories, and we’ve added code to <span class="cf">router.ex</span> as well. This
application is fairly complete. After all, it’s handling plenty of
production-level concerns for you:












</p><ul class="calibre28"><li class="calibre29">
<p id="calibre_link-614" class="calibre31">The Erlang virtual machine and OTP engine will help the application
scale.</p></li><li class="calibre29">
<p id="calibre_link-615" class="calibre31">The endpoint will filter out static requests and also parse the
request into pieces, and trigger the router.</p></li><li class="calibre29">
<p id="calibre_link-616" class="calibre31">The browser pipeline will honor <span class="cf1">Accept</span> headers, fetch the session, and protect from attacks like cross-site request forgery (CSRF).</p></li></ul>
<p id="calibre_link-617" class="calibre19">All of these features are quickly available to you for tailoring, but
they’re also conveniently stashed out of your way in a structure that’s robust, fast, and easy to extend. In fact, there’s no magic at all.
You have a good picture of exactly which functions Phoenix calls
on a request to <span class="cf">/hello</span>, and where that code lives within the code
base:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">connection                  ​<em class="comment"># Plug.Conn</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">|&gt; endpoint()               ​<em class="comment"># lib/hello_web/endpoint.ex</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">|&gt; browser()                ​<em class="comment"># lib/hello_web/router.ex</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">|&gt; HelloController.world()  ​<em class="comment"># lib/hello_web/controllers/hello_controller.ex</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">|&gt; HelloView.render(        ​<em class="comment"># lib/hello_web/views/hello_view.ex</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">       ​<em class="string">"</em>​​<em class="string">world.html"</em>​)        ​<em class="comment"># lib/hello_web/templates/hello/world.html.eex</em>​</td></tr></table>
<p id="calibre_link-618" class="calibre19">It’s easy to gloss over these details and go straight to the <span class="cf">hello_web</span>
directory, and entrust the rest of the details to Phoenix. We
encourage you instead to stop and take a look at exactly what happens
for each request, from top to bottom.














</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-315"><div id="calibre_link-619" class="calibre2"><h2 id="calibre_link-79" class="calibre20">Wrapping Up</h2>
<p id="calibre_link-620" class="calibre19">We’ve gotten off to a strong start. You’ve created a first project.
Though all of the concepts might still be a bit hazy, you now have
a high-level understanding of how Phoenix projects hang together. The
core concepts are these:</p><ul class="calibre28"><li class="calibre29">
<p id="calibre_link-621" class="calibre31">We installed Phoenix, which is built using Erlang and OTP for the service
layer, Elixir for the language, and Node.js for packaging static assets.</p></li><li class="calibre29">
<p id="calibre_link-622" class="calibre31">We used the Elixir build tool <span class="cf1">mix</span> to create a new project and
start our server.</p></li><li class="calibre29">
<p id="calibre_link-623" class="calibre31">Web applications in Phoenix are pipelines of plugs.</p></li><li class="calibre29">
<p id="calibre_link-624" class="calibre31">The basic flow of traditional applications is endpoint, router, pipeline, controller.</p></li></ul><ul class="calibre28"><li class="calibre29">
<p id="calibre_link-625" class="calibre31">Routers distribute requests.</p></li><li class="calibre29">
<p id="calibre_link-626" class="calibre31">Controllers call services and set up intermediate data for views.</p></li></ul>
<p id="calibre_link-627" class="calibre19">In the next chapter, we’re going to build a more hardy controller.
You’ll see how data flows through Phoenix, from the controller all the
way into templates. You’ll learn about concepts like layouts along the
way. Let’s get cracking!</p>

<div class="footnotes">
<h4 class="calibre24">Footnotes</h4>
<dl class="calibre25">
<dt class="footnote-number"><a id="calibre_link-49" href="#calibre_link-316" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[6]</a></dt><dd class="calibre26">
<p id="calibre_link-628" class="calibre27"><a href="http://www.erlang.org" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">http://www.erlang.org</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-50" href="#calibre_link-317" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[7]</a></dt><dd class="calibre26">
<p id="calibre_link-629" class="calibre27"><a href="http://elixir-lang.org" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">http://elixir-lang.org</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-51" href="#calibre_link-318" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[8]</a></dt><dd class="calibre26">
<p id="calibre_link-630" class="calibre27"><a href="http://elixir-lang.org/getting-started/introduction.html" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">http://elixir-lang.org/getting-started/introduction.html</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-52" href="#calibre_link-319" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[9]</a></dt><dd class="calibre26">
<p id="calibre_link-631" class="calibre27"><a href="http://www.postgresql.org/download/" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">http://www.postgresql.org/download/</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-53" href="#calibre_link-320" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[10]</a></dt><dd class="calibre26">
<p id="calibre_link-632" class="calibre27"><a href="http://nodejs.org" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">http://nodejs.org</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-54" href="#calibre_link-321" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[11]</a></dt><dd class="calibre26">
<p id="calibre_link-633" class="calibre27"><a href="https://hexdocs.pm/phoenix/installation.html#inotify-tools-for-linux-users" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://hexdocs.pm/phoenix/installation.html#inotify-tools-for-linux-users</a></p></dd></dl></div>
<div class="copyright">Copyright © 2020, The Pragmatic Bookshelf.</div>




</div>



  </div>


<div class="calibre1" id="calibre_link-22"><div id="calibre_link-634" class="calibre2"><h1 class="pcalibre6 chapter-title" id="calibre_link-80"><span class="chapter-number">
            Chapter
            3</span><br class="calibre18" /><span class="chapter-name">Controllers</span></h1>

<p id="calibre_link-635" class="calibre19">By now, you should have a loose grasp of how Phoenix applications work. You know that a typical request  starts at an endpoint, flows through a router, and then flows into a controller. You should be starting to appreciate that web programming is a functional problem, and that it’s natural to represent it using a functional language.</p>
<p id="calibre_link-636" class="calibre19">The “Hello, World” application we built in the previous chapter was a toy. It was the appropriate way to introduce you to Phoenix and the basics, but we’re going to abandon it now so we can grapple with code organization and problem solving. For the rest of the book, we’re going to work in a new project, and we’ll continue developing it through to the end. Before we get started, though, let’s take a deeper look at how controllers work. In addition, we’ll introduce all of the things controllers touch, including views, templates, and contexts.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-182"><div id="calibre_link-637" class="calibre2"><h2 id="calibre_link-81" class="calibre20">Understanding Controllers</h2>
<p id="calibre_link-638" class="calibre19">
In this chapter, we focus on building the controllers and the pieces of the application they touch.  Though Phoenix has generators that could generate much of a simple web app from scratch, we’re going to build part of it by hand so we can appreciate how the parts fit together. Before we fire up the generators, let’s talk about how the controller hangs together.</p>
<p id="calibre_link-639" class="calibre19">

Our application will be called <span class="cf">rumbl</span>. When we’re all done, the application will allow us to take videos (hosted elsewhere), and attach comments to them <span class="calibre4">in real time</span> and play them back alongside the comments of other users. Think of it as <span class="calibre4">Mystery Science Theater 3000</span> meets Twitter. At scale, this application will be tremendously demanding because each user will record and play back comments that must be saved and served quickly so that the content stays relevant. The <a href="#calibre_link-183" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">figure</a> shows what it will look like.</p><div id="calibre_link-183" class="praise"><div class="praise"><img id="calibre_link-640" class="border3" src="images/000026.png" alt="images/src/controllers_views_templates/interface.png" /></div></div>
<p id="calibre_link-641" class="calibre19">

Before we get to the heavy lifting of videos and comments, we’re going to handle users so you can get fully grounded in basic concepts first. Initially, we’ll focus on a controller that handles our users. Let’s talk about what we want to happen when a request for our user controller comes in via a browser:</p><table class="processedcode1"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   connection</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; endpoint()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; router()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; browser_pipeline()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; UserController.action()</td></tr></table>
<p id="calibre_link-642" class="calibre19">




A request enters through the endpoint (<span class="cf">lib/rumbl_web/endpoint.ex</span>) and then goes into the router (<span class="cf">lib/rumbl_web/router.ex</span>). The router matches the URL pattern, dispatches the connection through the browser pipeline, and then calls the <span class="cf">UserController</span> action. Let’s break that last part down a little further, assuming that the request invokes the <span class="cf">index</span> action:</p><table class="processedcode1"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   connection</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; UserController.index()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; UserView.render("index.html")</td></tr></table>
<p id="calibre_link-643" class="calibre19">We need to build the controller to do the work for our individual request, the view to render our template, and the template.</p>
<p id="calibre_link-644" class="calibre19">


In order to respond to browser requests, we have to implement our business logic. For example, the <span class="cf">UserController.index</span> might be a simple function that returns all users in our application, but where are those users stored? What information does the <span class="cf">index</span> view require for each user? Do users have different roles? Is all user information publicly available? Those are business concerns that will vary from application to application.</p>
<p id="calibre_link-645" class="calibre19">We could write all of this business logic directly in our controllers but there’s a better way. We’ll isolate our business logic into a simple API layer called the <span class="calibre4">context</span>.</p><h3 class="calibre22">The Context</h3>
<p id="calibre_link-646" class="calibre19">
A context in Phoenix is nothing more than a module that groups functions with a shared purpose. For example, our application will need to read, modify, and delete user accounts. We will strive to keep all of this code in a single module.</p>
<p id="calibre_link-647" class="calibre19">
Generally speaking, a context <span class="calibre4">encapsulates all business logic for a common purpose</span>. This way, we can interact with our business logic from controllers, channels, or remote APIs, without having to  duplicate code. In a nutshell, a controller exists to work with context functions. It parses end user requests, calls context functions, and translates those results into something the end user can understand. Each slice of code has an isolated purpose. The context doesn’t know about the controller, and the controller doesn’t know about the business rules.</p>
<p id="calibre_link-648" class="calibre19">

As we will see, organizing our code in contexts also does wonders for maintainability. We can add many new features, fixes, or business logic changes by simply changing contexts, without touching the web layer at all. We can also unit test our business logic thoroughly via the context API while focusing our integration tests on the controller.</p>
<p id="calibre_link-649" class="calibre19">With a master plan in our pocket, we can start to build our project. Let’s get started.
</p><h3 class="calibre22">Creating the Project</h3>
<p id="calibre_link-650" class="calibre19">




Let’s go ahead and create a new application, called <span class="cf">rumbl</span>, with <span class="cf">mix phx.new</span>. To save some later heartache, we’ll go ahead and create the Ecto configuration so we’ll have it down the road:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">phx.new</strong>​​<strong class="kw"> </strong>​​<strong class="kw">rumbl</strong>​</td></tr></table><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Fetch and install dependencies? [Yn] y</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* running mix deps.get</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* running mix deps.compile</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* running cd assets &amp;&amp; npm install &amp;&amp; \</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  node node_modules/webpack/bin/webpack.js --mode development</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">We are all set! Go into your application by running:</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    $ cd rumbl</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Then configure your database in config/dev.exs and run:</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    $ mix ecto.create</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Start your Phoenix app with:</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    $ mix phx.server</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">You can also run your app inside IEx (Interactive Elixir) as:</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    $ iex -S mix phx.server</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">$</td></tr></table>
<p id="calibre_link-651" class="calibre19">

First, run <span class="cf">mix ecto.create</span> to prep your database for later use. Next, start the app up with <span class="cf">mix phx.server</span> to make sure it’s working, and point your browser to <span class="cf">http://localhost:4000/</span>. You see the familiar Phoenix home page. That’s not exactly what we’re looking for. We can steal some of that goodness to build our own messaging.</p><h3 class="calibre22">A Simple Home Page</h3>
<p id="calibre_link-652" class="calibre19">
The default web page is a simple template that has HTML. For now, we can use it to form the foundation of our home page. Let’s start to tweak it right now. Make your <span class="cf">lib/rumbl_web/templates/page/index.html.eex</span> look like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/controllers_views_templates/listings/rumbl/lib/rumbl_web/templates/page/index.html.eex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">controllers_views_templates/listings/rumbl/lib/rumbl_web/templates/page/index.html.eex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;section class=​<em class="string">"phx-hero"</em>​&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;h1&gt;​<em class="comment">&lt;%=</em>​ gettext ​<em class="string">"</em>​​<em class="string">Welcome to %{name}!"</em>​, ​<em class="string">name:</em>​ ​<em class="string">"</em>​​<em class="string">Rumbl.io"</em>​ ​<em class="comment">%&gt;</em>​&lt;/h1&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;p&gt;Rumbl out loud.&lt;/p&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;/section&gt;</td></tr></table>
<p id="calibre_link-653" class="calibre19">Now we have a home page started. Notice that your browser has already changed as shown in the <a href="#calibre_link-184" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">figure</a>.</p><div id="calibre_link-184" class="praise"><div class="praise"><img id="calibre_link-654" class="border4" src="images/000028.png" alt="images/src/controllers_views_templates/rumbl_home.png" width="675" height="311" /></div></div>
<p id="calibre_link-655" class="calibre19">We have a crude home page so we should start to think about what to do about our users. We’re not quite ready to integrate a real database, but we <span class="calibre4">can</span> start thinking about the way we will make them available to our controller. For that, we’ll build a context.</p><h3 class="calibre22">Working with Contexts</h3>
<p id="calibre_link-656" class="calibre19">All good application programmers must learn how to break down complex ideas into discrete steps. The opposite is also true. To build a beautiful API, you must be able to coalesce discrete functions into ideas by strategically layering and grouping functions.</p>
<p id="calibre_link-657" class="calibre19">Every library we use, and even Elixir itself, is structured based on those ideas. For example, any time you call <span class="cf">Logger.debug</span> from Elixir’s standard library, you are accessing the <span class="cf">Logger</span> context. Internally, <span class="cf">Logger</span> may be broken into multiple modules, but for us, everything is exposed through a simple, well-defined public API of the <span class="cf">Logger</span> module.</p>
<p id="calibre_link-658" class="calibre19">






Phoenix projects are structured like Elixir libraries and projects. We split our code into contexts. A context will group related functionality, such as posts and comments, often encapsulating patterns such as data access and data validation, all driven by our business needs. By using contexts, we decouple and isolate our systems into manageable, independent parts. Done correctly, these APIs expose critical logical concepts while hiding both complexity and implementation details.</p>
<p id="calibre_link-659" class="calibre19">
With those goals in mind we’ll build a context backed by hardcoded data for the short term. This interface should allow us to rapidly test the application as we build it, and also to test our controllers, views, and templates with simple data-only structs. Later, we can replace our hardcoded implementation with a full database-backed Ecto repository, and our public interface will remain unchanged.</p>
<p id="calibre_link-660" class="calibre19">Let’s think about where our user functionality should live.  User accounts will be a core part of rumbl so let’s create a module called <span class="cf">Accounts</span> to group those concerns together. As rumbl grows, we can extend that code with other related functions such as authentication or password resets.</p>
<p id="calibre_link-661" class="calibre19">Now that we know we need an <span class="cf">Accounts</span> context, we can create the bits and pieces we’ll need to flesh it out. We’ll need a data structure for representing a user, so create a new file in <span class="cf">lib/rumbl/accounts/user.ex</span> and key this in:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/controllers_views_templates/listings/rumbl/lib/rumbl/accounts/user.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">controllers_views_templates/listings/rumbl/lib/rumbl/accounts/user.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ Rumbl.Accounts.User ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  defstruct [​<em class="string">:id</em>​, ​<em class="string">:name</em>​, ​<em class="string">:username</em>​]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-662" class="calibre19">
We defined a <span class="cf">Rumbl.Accounts.User</span> struct with the fields <span class="cf">id</span>, <span class="cf">name</span>, and <span class="cf">username</span>. A struct is Elixir’s main abstraction for working with structured data.</p><h3 class="calibre22">Elixir Structs</h3>
<p id="calibre_link-663" class="calibre19">


Elixir structs are built on top of maps. We could have implemented our <span class="cf">User</span> with a simple map. Maps would work just fine, but any developer could misspell a key or make a similar mistake. Let’s see that problem play out in action. Run <span class="cf">iex -S mix</span> to start an interactive Elixir within our application but without running the Phoenix server:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ alias Rumbl.Accounts.User</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ user = %{​<em class="string">usernmae:</em>​ ​<em class="string">"</em>​​<em class="string">jose"</em>​}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%{usernmae: "jose"}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ user.username</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">**</strong>​ (KeyError) key :username not found in: %{usernmae: "jose"}</td></tr></table>
<p id="calibre_link-664" class="calibre19">

You may have noticed that we misspelled <span class="cf">username</span> as <span class="cf">usernmae</span>. A limitation of maps is that they offer protection for bad keys only at runtime, when we effectively access the key. However, many times we’d like to know about such errors as soon as possible, often at compilation time. Structs solve this exact problem. If you know exactly which keys should be in a map, a struct is a better choice. For example, our <span class="cf">User</span> has clearly defined keys. Let’s try again but this time using our newly defined <span class="cf">Rumbl.Accounts.User</span> struct:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ jose = %User{​<em class="string">name:</em>​ ​<em class="string">"</em>​​<em class="string">Jose Valim"</em>​}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%Rumbl.Accounts.User{id: nil, name: "Jose Valim", username: nil}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ jose.name</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">"Jose Valim"</td></tr></table>
<p id="calibre_link-665" class="calibre19">
One of the first things to notice is default values. Even though we specified only the <span class="cf">:name</span> field when creating the struct, Elixir conveniently filled in the remaining ones. Now, if we misspell a key, we’re protected:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ chris = %User{​<em class="string">nmae:</em>​ ​<em class="string">"</em>​​<em class="string">chris"</em>​}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">**</strong>​ (KeyError) key :nmae not found in:</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%Rumbl.Accounts.User{id: nil, name: nil, username: nil}</td></tr></table>
<p id="calibre_link-666" class="calibre19">We misspelled the <span class="cf">name:</span> key and got an error. Nice.</p>
<p id="calibre_link-667" class="calibre19">

Notice that the syntax for structs and maps is nearly identical, except for the name of the struct. There’s a good reason for that. A struct <span class="calibre4">is</span> a map that has a <span class="cf">__struct__</span> key:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ jose.__struct__</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Rumbl.Accounts.User</td></tr></table>
<p id="calibre_link-668" class="calibre19">With our user in place, let’s define our <span class="cf">Accounts</span> context. We will add a couple of functions which will allow user account fetching. Let’s create a new file in <span class="cf">lib/rumbl/accounts.ex</span> and key this in:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/controllers_views_templates/listings/rumbl/lib/rumbl/accounts.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">controllers_views_templates/listings/rumbl/lib/rumbl/accounts.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ Rumbl.Accounts ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  @moduledoc ​<em class="string">"""</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<em class="string">  The Accounts context.</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<em class="string">  """</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  alias Rumbl.Accounts.User </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ list_users ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    [</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">      %User{​<em class="string">id:</em>​ ​<em class="string">"</em>​​<em class="string">1"</em>​, ​<em class="string">name:</em>​ ​<em class="string">"</em>​​<em class="string">José"</em>​, ​<em class="string">username:</em>​ ​<em class="string">"</em>​​<em class="string">josevalim"</em>​},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      %User{​<em class="string">id:</em>​ ​<em class="string">"</em>​​<em class="string">2"</em>​, ​<em class="string">name:</em>​ ​<em class="string">"</em>​​<em class="string">Bruce"</em>​, ​<em class="string">username:</em>​ ​<em class="string">"</em>​​<em class="string">redrapids"</em>​},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      %User{​<em class="string">id:</em>​ ​<em class="string">"</em>​​<em class="string">3"</em>​, ​<em class="string">name:</em>​ ​<em class="string">"</em>​​<em class="string">Chris"</em>​, ​<em class="string">username:</em>​ ​<em class="string">"</em>​​<em class="string">chrismccord"</em>​}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ get_user(id) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    Enum.find(list_users(), ​<strong class="kw">fn</strong>​ map -&gt; map.id == id ​<strong class="kw">end</strong>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">20:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ get_user_by(params) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    Enum.find(list_users(), ​<strong class="kw">fn</strong>​ map -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      Enum.all?(params, ​<strong class="kw">fn</strong>​ {key, val} -&gt; Map.get(map, key) == val ​<strong class="kw">end</strong>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">25:&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-669" class="calibre19">In our new module, we defined some of the typical functions you’d expect to find to manage a list of <span class="cf">User</span> structs. The <span class="cf">list_users()</span> function returns a list of all user structs in our system. Similarly, <span class="cf">get_user</span> and <span class="cf">get_user_by</span> functions fetch a single user from the system matching an ID or list of attributes.</p>
<p id="calibre_link-670" class="calibre19">Now our application has an interface to fetch user accounts in the system. Callers don’t know that we’re returning hardcoded data instead of talking to the database, and <span class="calibre4">that’s the point</span>. We can make our data storage more sophisticated later while building out our greater application design.</p>
<p id="calibre_link-671" class="calibre19">Let’s take the context for a spin. Start the console with <span class="cf">iex -S mix</span>. The <span class="cf">-S mix</span> option starts IEx in the context of the Mix script, giving us access to all modules in our application directly in IEx:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ alias Rumbl.Accounts</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ alias Rumbl.Accounts.User</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Accounts.list_users()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  %Rumbl.Accounts.User{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    id: "1",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    name: "José",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    username: "josevalim"</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  },</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  %Rumbl.Accounts.User{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    id: "2",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    name: "Bruce",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    username: "redrapids"</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  },</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  %Rumbl.Accounts.User{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    id: "3",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    name: "Chris",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    username: "chrismccord"</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Accounts.get_user(​<em class="string">"</em>​​<em class="string">1"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%Rumbl.Accounts.User{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  id: "1",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  name: "José",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  username: "josevalim"</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Accounts.get_user_by(​<em class="string">name:</em>​ ​<em class="string">"</em>​​<em class="string">Bruce"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%Rumbl.Accounts.User{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  id: "2",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  name: "Bruce",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  username: "redrapids"</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">}</td></tr></table>
<p id="calibre_link-672" class="calibre19">And presto, we have a working user account system. Our controller will work fine. In fact, <span class="calibre4">our tests will work fine as well</span>. With some minor tweaks, this strategy will serve us well as we take the controller through its paces.</p>
<p id="calibre_link-673" class="calibre19">Now that we have user accounts, we can move ahead to the actual code that fetches and renders them.
</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-232"><div id="calibre_link-674" class="calibre2"><h2 id="calibre_link-82" class="calibre20">Building a Controller</h2>
<p id="calibre_link-675" class="calibre19">

You’ve already built a simple controller, so you know the drill. At this point, we could create all of the routes needed by a user automatically with the <span class="cf">resources</span> macro, but we are going to play the teacher and say “Show your work!” If you understand how a single route works, it’ll be much easier to explore the powerful shortcuts later. Specifically, we need two routes. <span class="cf">UserController.index</span> will show a list of users, and <span class="cf">UserController.show</span> will show a single user. As always, create the routes in <span class="cf">router.ex</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/controllers_views_templates/listings/rumbl/lib/rumbl_web/router.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">controllers_views_templates/listings/rumbl/lib/rumbl_web/router.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">scope ​<em class="string">"</em>​​<em class="string">/"</em>​, RumblWeb ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  pipe_through ​<em class="string">:browser</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  get ​<em class="string">"</em>​​<em class="string">/users"</em>​, UserController, ​<em class="string">:index</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  get ​<em class="string">"</em>​​<em class="string">/users/:id"</em>​, UserController, ​<em class="string">:show</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  get ​<em class="string">"</em>​​<em class="string">/"</em>​, PageController, ​<em class="string">:index</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-676" class="calibre19">









Notice that we have our two new routes and the default route for <span class="cf">/</span>. Our two new routes use the new <span class="cf">UserController</span>, which doesn’t yet exist, with the <span class="cf">:show</span> and <span class="cf">:index</span> actions. The names and URLs we’ve chosen for these actions aren’t random. The <span class="cf">:show</span>, <span class="cf">:index</span>, <span class="cf">:new</span>, <span class="cf">:create</span>, <span class="cf">:edit</span>, <span class="cf">:update</span>, and <span class="cf">:delete</span> actions are all frequently used in Phoenix. For now, follow along strictly, and you’ll learn the shortcuts later.</p>
<p id="calibre_link-677" class="calibre19">Let’s take a closer look at the <span class="cf">:index</span> route:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">get ​<em class="string">"</em>​​<em class="string">/users"</em>​, UserController, ​<em class="string">:index</em>​</td></tr></table>
<p id="calibre_link-678" class="calibre19">

You’ve seen the <span class="cf">get</span> macro before. The route matches HTTP <span class="cf">GET</span> requests to a URL that looks like <span class="cf">/users</span> and sends them to the <span class="cf">UserController</span>, calling the <span class="cf">index</span> action. That route stores <span class="cf">:index</span>&mdash;the action we intend to invoke&mdash;in the <span class="cf">conn</span> and then calls the right pipeline.</p>
<p id="calibre_link-679" class="calibre19">Now, restart your server and point your browser to <span class="cf">http://localhost:4000/users</span>. You get some debugging information, but you don’t have to go beyond the title to find this message:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">UndefinedFunctionError at GET /users</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">function RumblWeb.UserController.init/1 is undefined</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">(module RumblWeb.UserController is not available)</td></tr></table>
<p id="calibre_link-680" class="calibre19">That makes sense; we haven’t written the controller yet.</p>
<p id="calibre_link-681" class="calibre19">Let’s create a controller in <span class="cf">lib/rumbl_web/controllers/user_controller.ex</span>. Initially, we’ll include one function called <span class="cf">index</span> to find the users from our Accounts context:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/controllers_views_templates/listings/rumbl/lib/rumbl_web/controllers/user_controller.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">controllers_views_templates/listings/rumbl/lib/rumbl_web/controllers/user_controller.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ RumblWeb.UserController ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ RumblWeb, ​<em class="string">:controller</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  alias Rumbl.Accounts</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ index(conn, _params) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    users = Accounts.list_users()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    render(conn, ​<em class="string">"</em>​​<em class="string">index.html"</em>​, ​<em class="string">users:</em>​ users)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-682" class="calibre19">Let’s take that code apart. There’s a little bit of ceremony at the top of the file that defines our module and announces that we’re going to use the <span class="cf">:controller</span> API.  Right now, the only action is <span class="cf">index</span>.</p>
<p id="calibre_link-683" class="calibre19">If you access the users page again, you can see that we’re getting an error message, but we’ve traded up:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">UndefinedFunctionError at GET /users</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">undefined function: RumblWeb.UserView.render/2</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  (module RumblWeb.UserView is not available)</td></tr></table>
<p id="calibre_link-684" class="calibre19">Progress! We have a controller, but we still need to code a view.
</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-259"><div id="calibre_link-685" class="calibre2"><h2 id="calibre_link-83" class="calibre20">Coding Views</h2>
<p id="calibre_link-686" class="calibre19">


This is your second pass through this process. The first time, you built a “Hello, World”-style feature, one with a controller, view, and template. Now it’s time for the more detailed explanation that you were promised earlier. In many other web frameworks, the terms <span class="calibre4">view</span> and <span class="calibre4">template</span> are often used synonymously. It’s enough for users to know that when a controller finishes a task, a view is somehow rendered.</p>
<p id="calibre_link-687" class="calibre19">





In Phoenix, the terminology is a little more explicit. A <span class="calibre4">view</span> is a module containing rendering functions that convert data into a format the end user will consume, like HTML or JSON. You can write such functions as you would any other Elixir function. Those rendering functions can also be defined from templates. A <span class="calibre4">template</span> is a function on that module, compiled from a file containing a raw markup language and embedded Elixir code to process substitutions and loops. The separation of the view and template concepts makes it easy to render data any way you want, be it with a raw function, an embedded Elixir engine, or any other template engine.</p>
<p id="calibre_link-688" class="calibre19">

In short, views are modules responsible for rendering. Templates are web pages or fragments that allow both static markup and native code to build response pages, compiled into a function.</p>
<p id="calibre_link-689" class="calibre19">Let’s build a view in <span class="cf">lib/rumbl_web/views/user_view.ex</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/controllers_views_templates/listings/rumbl/lib/rumbl_web/views/user_view.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">controllers_views_templates/listings/rumbl/lib/rumbl_web/views/user_view.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ RumblWeb.UserView ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ RumblWeb, ​<em class="string">:view</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  alias Rumbl.Accounts</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ first_name(%Accounts.User{​<em class="string">name:</em>​ name}) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    name</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; String.split(​<em class="string">"</em>​​<em class="string"> "</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; Enum.at(0)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-690" class="calibre19">We added a simple <span class="cf">first_name</span> function to parse a user’s first name from that user’s <span class="cf">name</span> field. Next, in <span class="cf">lib/rumbl_web/templates</span>, we created a <span class="cf">user</span> directory and a new <span class="cf">index</span> template in <span class="cf">lib/rumbl_web/templates/user/index.html.eex</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/controllers_views_templates/listings/rumbl/lib/rumbl_web/templates/user/index.html.eex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">controllers_views_templates/listings/rumbl/lib/rumbl_web/templates/user/index.html.eex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;h1&gt;Listing Users&lt;/h1&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;table&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="comment">&lt;%=</em>​ for user &lt;- @users ​<strong class="kw">do</strong>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    &lt;tr&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      &lt;td&gt;&lt;b&gt;​<em class="comment">&lt;%=</em>​ first_name(user) ​<em class="comment">%&gt;</em>​&lt;/b&gt; (​<em class="comment">&lt;%=</em>​ user.id ​<em class="comment">%&gt;</em>​)&lt;/td&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      &lt;td&gt;​<em class="comment">&lt;%=</em>​ link ​<em class="string">"</em>​​<em class="string">View"</em>​, ​<em class="string">to:</em>​ Routes.user_path(@conn, ​<em class="string">:show</em>​, user.id) ​<em class="comment">%&gt;</em>​&lt;/td&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    &lt;/tr&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="comment">&lt;%</em>​ ​<strong class="kw">end</strong>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;/table&gt;</td></tr></table>
<p id="calibre_link-691" class="calibre19">






That’s mostly HTML markup, with a little Elixir mixed in. This template language is called <span class="cf">EEx</span>, which stands for Embedded Elixir, and is part of the Elixir’s standard library. At runtime, Phoenix will translate this template to a function using this strategy. <span class="cf">EEx</span> executes Elixir code that’s within <span class="cf">&lt;%= %&gt;</span> tags, injecting the result into the template. <span class="cf">EEx</span> evaluates code within <span class="cf">&lt;% %&gt;</span> tags without injecting the result, meaning we’ll use them for code with side effects. Since we generally try to keep side effects out of views wherever possible, we’ll use mostly the <span class="cf">&lt;%= %&gt;</span> form. You’ve seen template code before, but we’ll walk through it anyway.</p>
<p id="calibre_link-692" class="calibre19">The expression <span class="cf">for user &lt;- @users</span> walks through the users, rendering each user using the template code inside the <span class="cf">do</span> block, and rolling up the result into the template. Remember, we’ve already populated <span class="cf">@users</span> within our <span class="cf">index</span> action.</p>
<p id="calibre_link-693" class="calibre19">Each user is a map. We render the <span class="cf">name</span> field, the <span class="cf">id</span> field, and a link. That link comes from a helper function.</p><div class="xxxsays"><div class="heading"><div class="persons-picture"><img src="images/000048.png" alt="Chris says:" class="calibre40" /></div><div class="label">Chris says:</div><div class="title">Why Are Templates So Fast in Phoenix?</div></div><div class="praise">
<p id="calibre_link-694" class="calibre14">






After compilation, templates are functions. Since Phoenix builds templates using linked lists rather than string concatenation the way many imperative languages do, one of the traditional bottlenecks of many web frameworks goes away. Phoenix doesn’t have to make huge copies of giant strings.
</p>
<p id="calibre_link-695" class="calibre14">

Since Elixir has only a single copy of the largest and most frequently used strings in your application, the hardware caching features of most CPUs can come into play. The book’s introduction talked about the performance of the routing layer. The performance of the view layer is just as important. For more details, see Elixir RAM and the Template of Doom.<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-167" href="#calibre_link-260">[12]</a></sup>
</p></div></div>
</div>



  </div>


<div class="calibre1" id="calibre_link-297"><div id="calibre_link-696" class="calibre2"><h2 id="calibre_link-84" class="calibre20">Using Helpers</h2>
<p id="calibre_link-697" class="calibre19">





That <span class="cf">link</span> function packs a surprising amount of punch into a small package. Phoenix helpers provide a convenient way to drop common HTML structures onto your view. There’s nothing special about them. Helpers are simply Elixir functions. For example, you can call the functions directly in IEx:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">iex</strong>​​<strong class="kw"> </strong>​​<strong class="kw">-S</strong>​​<strong class="kw"> </strong>​​<strong class="kw">mix</strong>​</td></tr></table><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Phoenix.HTML.Link.link(​<em class="string">"</em>​​<em class="string">Home"</em>​, ​<em class="string">to:</em>​ ​<em class="string">"</em>​​<em class="string">/"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{:safe,  [60, "a", [[32, "href", 61, 34, "/", 34]],</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">62, "Home", 60,   47, "a", 62]}</td></tr></table>
<p id="calibre_link-698" class="calibre19">

The return value might look a little odd. We received a tuple with <span class="cf">:safe</span>, followed by an unusual looking list of values. This list is known as an <span class="calibre4">I/O list</span>. I/O lists are simply lists of values which allow data to be efficiently used for I/O, such as writing values to a socket. Let’s convert this result into a human-readable form by calling <span class="cf">Phoenix.HTML.safe_to_string/1</span>:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​​<strong class="kw"> </strong>​​<strong class="kw">Phoenix.HTML.Link.link(</strong>​​<em class="string">"Home"</em>​​<strong class="kw">,</strong>​​<strong class="kw"> </strong>​​<strong class="kw">to:</strong>​​<strong class="kw"> </strong>​​<em class="string">"/"</em>​​<strong class="kw">)</strong>​​<strong class="kw"> </strong>​​<strong class="kw">|&gt;</strong>​​<strong class="kw"> </strong>​​<strong class="kw">Phoenix.HTML.safe_to_string()</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">"&lt;a href=\"/\"&gt;Home&lt;/a&gt;"</td></tr></table>
<p id="calibre_link-699" class="calibre19">The second argument to our <span class="cf">link</span> function is a keyword list, with the <span class="cf">to:</span> argument specifying the target. We use a path that’s automatically created for our <span class="cf">:show</span> route to specify the link target. Now you can see that our list has the three users we fetched from our repository as shown in the <a href="#calibre_link-298" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">figure</a>.</p><div id="calibre_link-298" class="praise"><div class="praise"><img id="calibre_link-700" class="border5" src="images/000022.png" alt="images/src/controllers_views_templates/index.png" width="720" height="306" /></div></div>
<p id="calibre_link-701" class="calibre19">

At this point you may be wondering where the HTML helpers come from. At the top of each view, you can find the following definition: <span class="cf">use RumblWeb, :view</span>. This code snippet is the one responsible for setting up our view modules, importing all required functionality. Open up <span class="cf">lib/rumbl_web.ex</span> to see exactly what’s imported into each view:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/controllers_views_templates/rumbl/lib/rumbl_web.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">controllers_views_templates/rumbl/lib/rumbl_web.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ view ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">quote</strong>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">use</strong>​ Phoenix.View, ​<em class="string">root:</em>​ ​<em class="string">"</em>​​<em class="string">lib/rumbl_web/templates"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">                      ​<em class="string">namespace:</em>​ RumblWeb</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="comment"># Import convenience functions from controllers</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">import</strong>​ Phoenix.Controller,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">           ​<em class="string">only:</em>​ [​<em class="string">get_flash:</em>​ 1, ​<em class="string">get_flash:</em>​ 2, ​<em class="string">view_module:</em>​ 1]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="comment"># Use all HTML functionality (forms, tags, etc)</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">use</strong>​ Phoenix.HTML</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">import</strong>​ RumblWeb.ErrorHelpers</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">import</strong>​ RumblWeb.Gettext</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    alias RumblWeb.Router.Helpers, ​<em class="string">as:</em>​ Routes</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-702" class="calibre19">The <span class="cf">view</span> function uses Elixir’s <span class="cf">quote</span> to inject a chunk of code into each view. Since the contents of each <span class="cf">quote</span> are executed for each view, you want to keep it short and sweet, limiting these chunks only to imports, uses, and aliases. In our case, one of those injected statements is <span class="cf">use Phoenix.HTML</span>.</p>
<p id="calibre_link-703" class="calibre19">





<span class="cf">Phoenix.HTML</span> is responsible for the HTML functionality in views, from generating links to working with forms. <span class="cf">Phoenix.HTML</span> also provides HTML safety: <span class="calibre4">by default, applications are safe from cross-site scripting (XSS) attacks</span>, because only the markup generated by <span class="cf">Phoenix.HTML</span> functions is considered safe. That’s why the <span class="cf">link</span> function returns a tuple. The first element of the tuple&mdash;the <span class="cf">:safe</span> atom&mdash;indicates that the content in the second element is known to be safe.</p>
<p id="calibre_link-704" class="calibre19">

To learn about existing HTML helpers, visit the <span class="cf">Phoenix.HTML</span> documentation.<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-168" href="#calibre_link-299">[13]</a></sup></p>
<p id="calibre_link-705" class="calibre19">
Keep in mind that the <span class="cf">rumbl_web.ex</span> file is not a place to attach your own functions.  You want to keep this file skinny and easy to understand. For example, the contents of the view function will be macro-expanded <span class="calibre4">to each and every view</span>! So remember, in <span class="cf">rumbl_web.ex</span>, prefer <span class="cf">import</span> statements to defining your own functions.</p>
<p id="calibre_link-706" class="calibre19">That’s a good amount of progress so far. Let’s create one more action, and the corresponding template, to round out our actions.



</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-13"><div id="calibre_link-707" class="calibre2"><h2 id="calibre_link-85" class="calibre20">Showing a User</h2>
<p id="calibre_link-708" class="calibre19">



Now that we’ve created the code to show a list of users, we can work on showing a single user. To refresh your memory, let’s look at the route we created earlier:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">get ​<em class="string">"</em>​​<em class="string">/users/:id"</em>​, UserController, ​<em class="string">:show</em>​</td></tr></table>
<p id="calibre_link-709" class="calibre19">
That’s easy enough. On a request to <span class="cf">/users/:id</span>, where <span class="cf">:id</span> is part of the inbound URL, the router will add at least two things we’ll need to <span class="cf">conn</span>, including the <span class="cf">:id</span> that’s part of the URL, and the action name, <span class="cf">:show</span>. Then, the router will call the plugs in our pipeline, and then the <span class="cf">UserController</span>.  To show a single user using this request, we need a controller action, which we add to <span class="cf">lib/rumbl_web/controllers/user_controller.ex</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/controllers_views_templates/listings/rumbl/lib/rumbl_web/controllers/user_controller.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">controllers_views_templates/listings/rumbl/lib/rumbl_web/controllers/user_controller.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ show(conn, %{​<em class="string">"</em>​​<em class="string">id"</em>​ =&gt; id}) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  user = Accounts.get_user(id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  render(conn, ​<em class="string">"</em>​​<em class="string">show.html"</em>​, ​<em class="string">user:</em>​ user)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-710" class="calibre19">

Now, you can see why Plug breaks out the <span class="cf">params</span> part of the inbound <span class="cf">conn</span>. We can use <span class="cf">params</span> to extract the individual elements our action needs. In this case, we’re matching on the <span class="cf">"id"</span> key to populate the <span class="cf">id</span> variable. We then use that to ask the Accounts context for the given user,  and use that to render the result.</p>
<p id="calibre_link-711" class="calibre19">
When you point the browser to <span class="cf">localhost:4000/users/1</span>, predictably, Phoenix screams at you. You’ve not yet built the template.</p>
<p id="calibre_link-712" class="calibre19">Add this to <span class="cf">lib/rumbl_web/templates/user/show.html.eex</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/controllers_views_templates/listings/rumbl/lib/rumbl_web/templates/user/show.html.eex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">controllers_views_templates/listings/rumbl/lib/rumbl_web/templates/user/show.html.eex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;h1&gt;Showing User&lt;/h1&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;b&gt;​<em class="comment">&lt;%=</em>​ first_name(@user) ​<em class="comment">%&gt;</em>​&lt;/b&gt; (​<em class="comment">&lt;%=</em>​ @user.id ​<em class="comment">%&gt;</em>​)</td></tr></table>
<p id="calibre_link-713" class="calibre19">Point your browser to <span class="cf">/users/1</span>. You can see the first user, with the dynamic content piped in as we require.</p><h3 class="calibre22">Naming Conventions</h3>
<p id="calibre_link-714" class="calibre19">





When Phoenix renders templates from a controller, it infers the name of the view module, <span class="cf">RumblWeb.UserView</span>, from the name of the controller module, <span class="cf">RumblWeb.UserController</span>. The view modules infer their template locations from the view module name. In our example, our <span class="cf">RumblWeb.UserView</span> would look for templates in the <span class="cf">web/templates/user/</span> directory. Phoenix uses the explicit names you provide throughout, whether singular or plural. That strategy avoids confusing pluralization rules and naming inconsistencies you might find in other frameworks.</p>
<p id="calibre_link-715" class="calibre19">You’ll see how to customize these conventions later. For now, know that you can let Phoenix save you some time by letting the good old computer do the work for you. Break the rules if you have to, but if you’re smart about it, you’ll save some tedious ceremony along the way.</p><h3 class="calibre22">Nesting Templates</h3>
<p id="calibre_link-716" class="calibre19">

Often there’s a need to reduce duplication in the templates themselves. For example, both of our templates have common code that renders a user. Take the common code and create a <span class="cf">user</span> template in <span class="cf">lib/rumbl_web/templates/user/user.html.eex</span>:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;strong&gt;​<em class="comment">&lt;%=</em>​ first_name(@user) ​<em class="comment">%&gt;</em>​&lt;/strong&gt; (​<em class="comment">&lt;%=</em>​ @user.id ​<em class="comment">%&gt;</em>​)</td></tr></table>
<p id="calibre_link-717" class="calibre19">
We created another template to render a user. Then, whenever we build tables or listings of users, we can re-use this template. Now, change your <span class="cf">show.html.eex</span> template to render it:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;h1&gt;Showing User&lt;/h1&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment">&lt;%=</em>​ render ​<em class="string">"</em>​​<em class="string">user.html"</em>​, ​<em class="string">user:</em>​ @user ​<em class="comment">%&gt;</em>​</td></tr></table>
<p id="calibre_link-718" class="calibre19">Also, change your <span class="cf">index.html.eex</span> template to render it:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;tr&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;td&gt;​<em class="comment">&lt;%=</em>​ render ​<em class="string">"</em>​​<em class="string">user.html"</em>​, ​<em class="string">user:</em>​ user ​<em class="comment">%&gt;</em>​&lt;/td&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;td&gt;​<em class="comment">&lt;%=</em>​ link ​<em class="string">"</em>​​<em class="string">View"</em>​, ​<em class="string">to:</em>​ Routes.user_path(@conn, ​<em class="string">:show</em>​, user.id) ​<em class="comment">%&gt;</em>​&lt;/td&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;/tr&gt;</td></tr></table>
<p id="calibre_link-719" class="calibre19">





At this point, it’s worth emphasizing that a view in Phoenix is just a module, and templates are just functions. When we add a template named <span class="cf">lib/rumbl_web/templates/user/user.html.eex</span>, the view extracts the template from the filesystem and makes it a function in the view itself. That’s why we need the view in the first place. Let’s build on this thought inside <span class="cf">iex -S mix</span>:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ user = Rumbl.Accounts.get_user(​<em class="string">"</em>​​<em class="string">1"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%Rumbl.Accounts.User{...}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ view = RumblWeb.UserView.render(​<em class="string">"</em>​​<em class="string">user.html"</em>​, ​<em class="string">user:</em>​ user)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{:safe, [[[[["" | "&lt;strong&gt;"] | "José"] | "&lt;/strong&gt; ("] | "1"] | ")\n"]}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Phoenix.HTML.safe_to_string(view)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">"&lt;strong&gt;José&lt;/strong&gt; (1)\n"</td></tr></table>
<p id="calibre_link-720" class="calibre19">




We fetch a user from the repository and then render the template directly. Because Phoenix has the notion of HTML safety, we can see that <span class="cf">render</span> returns a tuple, tagged as <span class="cf">:safe</span> just as we saw with our <span class="cf">link</span> helper. Likewise, the contents are also stored in an I/O list for performance.</p>
<p id="calibre_link-721" class="calibre19">




Each template in our application becomes a <span class="cf">render(template_name, assigns)</span> clause in its respective view. So, rendering a template is a combination of pattern matching on the template name and executing the function. The <span class="cf">assigns</span> argument is simply a holding hash for user-defined values containing values set by plugs and controller functions. Because the rendering contract is so simple, nothing is stopping developers from defining <span class="cf">render</span> clauses directly on the view module, skipping the whole template. For example, in your <span class="cf">RumblWeb.ErrorView</span>, you could respond to 404 or 500 status codes with basic error messages by simply implementing the following functions:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ render(​<em class="string">"</em>​​<em class="string">404.html"</em>​, _assigns) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="string">"</em>​​<em class="string">Page not found"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ render(​<em class="string">"</em>​​<em class="string">500.html"</em>​, _assigns) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="string">"</em>​​<em class="string">Internal server error"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-722" class="calibre19">By default, your generated error view implements the <span class="cf">template_not_found/2</span> callback which renders these basic error messages for you. You can see this in action in your own <span class="cf">RumblWeb.ErrorView</span>, which contains:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/controllers_views_templates/rumbl/lib/rumbl_web/views/error_view.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">controllers_views_templates/rumbl/lib/rumbl_web/views/error_view.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment"># By default, Phoenix returns the status message from</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment"># the template name. For example, "404.html" becomes</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment"># "Not Found".</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ template_not_found(template, _assigns) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Phoenix.Controller.status_message_from_template(template)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-723" class="calibre19">


The <span class="cf">Phoenix.View</span> module&mdash;the one used to define the views themselves&mdash;also provides functions for rendering views, including a function to render and convert the rendered template into a string in one pass:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ user = Rumbl.Accounts.get_user(​<em class="string">"</em>​​<em class="string">1"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%Rumbl.Accounts.User{...}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Phoenix.View.render(RumblWeb.UserView, ​<em class="string">"</em>​​<em class="string">user.html"</em>​, ​<em class="string">user:</em>​ user)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{:safe, [[[[["" | "&lt;strong&gt;"] | "José"] | "&lt;/strong&gt; ("] | "1"] | ")\n"]}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Phoenix.View.render_to_string(RumblWeb.UserView, ​<em class="string">"</em>​​<em class="string">user.html"</em>​, ​<em class="string">user:</em>​ user)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">"&lt;strong&gt;José&lt;/strong&gt; (1)\n"</td></tr></table>
<p id="calibre_link-724" class="calibre19">Behind the scenes, <span class="cf">Phoenix.View</span> calls <span class="cf">render</span> in the given view and adds some small conveniences, like wrapping our templates in layouts whenever one is available. Let’s find out how.

</p><h3 class="calibre22">Layouts</h3>
<p id="calibre_link-725" class="calibre19">


When we call <span class="cf">render</span> in our controller, instead of rendering the desired view directly, the controller first renders the layout view, which then renders the actual template in a predefined markup. This allows developers to provide a consistent markup across all pages without duplicating it over and over again.</p>
<p id="calibre_link-726" class="calibre19">



Since layouts are regular views with templates, all the knowledge that you’ve gained so far applies to them. In particular, each template receives a couple of special assigns when rendering, namely <span class="cf">@view_module</span> and <span class="cf">@view_template</span>. You can see these in <span class="cf">lib/rumbl_web/templates/layout/app.html.eex</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/controllers_views_templates/rumbl/lib/rumbl_web/templates/layout/app.html.eex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">controllers_views_templates/rumbl/lib/rumbl_web/templates/layout/app.html.eex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;main role=​<em class="string">"main"</em>​ class=​<em class="string">"container"</em>​&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;p class=​<em class="string">"alert alert-info"</em>​ role=​<em class="string">"alert"</em>​&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="comment">&lt;%=</em>​ get_flash(@conn, ​<em class="string">:info</em>​) ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;/p&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;p class=​<em class="string">"alert alert-danger"</em>​ role=​<em class="string">"alert"</em>​&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="comment">&lt;%=</em>​ get_flash(@conn, ​<em class="string">:error</em>​) ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;/p&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="comment">&lt;%=</em>​ render @view_module, @view_template, assigns ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;/main&gt;</td></tr></table>
<p id="calibre_link-727" class="calibre19">




It’s just pure HTML with a <span class="cf">render</span> call of <span class="cf">render @view_module, @view_template, assigns</span>, but it doesn’t need to be restricted to HTML. As in any other template, the connection is also available in layouts as <span class="cf">@conn</span>, giving you access to any other helper in Phoenix. When you call <span class="cf">render</span> in your controller, you’re actually rendering with the <span class="cf">:layout</span> option set by default. This allows you to render the view and template for your controller action in the layout with a plain <span class="cf">render</span> function call. No magic is happening here.</p>
<p id="calibre_link-728" class="calibre19">We can tweak the existing layout to be a little more friendly to our application. Rather than slog through a bunch of CSS and HTML here, we’ll let you work out your own design. If you choose to do so, replace the layout you find at <span class="cf">lib/rumbl_web/templates/layout/app.html.eex</span> with one you like better. As always, you’ll see your browser autoupdate.</p>
<p id="calibre_link-729" class="calibre19">We’re just about done here. By now, our growing company valuation is somewhere north of, well, the tree house you built in the third grade. Don’t worry, though; things will pick up in a hurry. You’re going to go deeper faster than you thought possible.









</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-166"><div id="calibre_link-730" class="calibre2"><h2 id="calibre_link-86" class="calibre20">Wrapping Up</h2>
<p id="calibre_link-731" class="calibre19">We packed a ton into this chapter. Let’s summarize what you’ve done:</p><ul class="calibre28"><li class="calibre29">
<p id="calibre_link-732" class="calibre31">We created our first context that encapsulates all of the logic related to account management.</p></li><li class="calibre29">
<p id="calibre_link-733" class="calibre31">We created actions, which serve as the main point of control for each request.</p></li><li class="calibre29">
<p id="calibre_link-734" class="calibre31">We created views, which exist to render templates.</p></li><li class="calibre29">
<p id="calibre_link-735" class="calibre31">We created templates, which generate HTML for our users.</p></li><li class="calibre29">
<p id="calibre_link-736" class="calibre31">We employed helpers, which are simple Phoenix functions used in templates.</p></li><li class="calibre29">
<p id="calibre_link-737" class="calibre31">We used layouts, which are HTML templates that embed an action’s HTML.</p></li></ul>
<p id="calibre_link-738" class="calibre19">In the next chapter, we’re going to go back to the context, which we’ve implemented with a simple in-memory list, with a database backend using Ecto. By the time we’re done, we’ll be reading our users from the database and entering new users with forms. Along the way, we’ll start to see how a little upfront design effort with contexts paves the way for our growing feature set.</p>
<p id="calibre_link-739" class="calibre19">Don’t stop now! Things are just getting interesting.</p>

<div class="footnotes">
<h4 class="calibre24">Footnotes</h4>
<dl class="calibre25">
<dt class="footnote-number"><a id="calibre_link-260" href="#calibre_link-167" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[12]</a></dt><dd class="calibre26">
<p id="calibre_link-740" class="calibre27"><a href="https://www.evanmiller.org/elixir-ram-and-the-template-of-doom.html" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://www.evanmiller.org/elixir-ram-and-the-template-of-doom.html</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-299" href="#calibre_link-168" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[13]</a></dt><dd class="calibre26">
<p id="calibre_link-741" class="calibre27"><a href="http://hexdocs.pm/phoenix_html" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">http://hexdocs.pm/phoenix_html</a></p></dd></dl></div>
<div class="copyright">Copyright © 2020, The Pragmatic Bookshelf.</div>




</div>



  </div>


<div class="calibre1" id="calibre_link-224"><div id="calibre_link-742" class="calibre2"><h1 class="pcalibre6 chapter-title" id="calibre_link-87"><span class="chapter-number">
            Chapter
            4</span><br class="calibre18" /><span class="chapter-name">Ecto and Changesets</span></h1>

<p id="calibre_link-743" class="calibre19">Up to now, we’ve been focusing on our application’s presentation layer
with views and templates, and controlling those views with
controllers. Rather than bogging down into technical details,
we used an application API to encapsulate all of our business concerns.
Our single <span class="cf">Accounts</span> context keeps all the data directly in the code
instead of using a real database. There’s a method to our
madness. With very little work, we can now replace our in-memory data structures
with a real database and all of our controller code can remain unchanged.</p>
<p id="calibre_link-744" class="calibre19">Ecto is the Elixir framework for persisting data.  In this chapter,
we’ll convert our <span class="cf">Accounts</span> context to use an Ecto repository
backed by a PostgreSQL database. By the time you’re done, your accounts
context will be able to save users and search for them using an
advanced query API.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-248"><div id="calibre_link-745" class="calibre2"><h2 id="calibre_link-88" class="calibre20">Understanding Ecto</h2>
<p id="calibre_link-746" class="calibre19">
If you’ve used data frameworks like LINQ in .NET or persistence frameworks like
Active Record in Rails, you’ll see some common threads in Ecto but also some
significant differences. Ecto is a wrapper that’s primarily intended
for relational databases, allowing developers to read and persist data
to underlying storage such as PostgreSQL. It has an encapsulated query
language that you can use to build layered queries that can then be
composed into more-sophisticated ones.</p>
<p id="calibre_link-747" class="calibre19">
Ecto also has a feature called <span class="calibre4">changesets</span> that holds all changes you
want to perform on the database. It encapsulates the whole process of
receiving external data, casting and validating it before writing it
to the database.</p>
<p id="calibre_link-748" class="calibre19">In this chapter, we’ll start with a basic database-backed repository.
We’ll then move on to creating data and managing updates with
changesets, saving most of the query language for later.</p>
<p id="calibre_link-749" class="calibre19">When we created our application, Phoenix generated an Ecto
repository, called <span class="cf">Rumble.Repo</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/ecto/rumbl/lib/rumbl/repo.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">ecto/rumbl/lib/rumbl/repo.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ Rumbl.Repo ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ Ecto.Repo,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">otp_app:</em>​ ​<em class="string">:rumbl</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">adapter:</em>​ Ecto.Adapters.Postgres</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-750" class="calibre19">Our repository uses Ecto’s default database adapter, PostgreSQL. If you haven’t already done so, install
PostgreSQL now.</p>
<p id="calibre_link-751" class="calibre19">

You can configure the repository and the development
credentials to access the database in <span class="cf">config/dev.exs</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/ecto/rumbl/config/dev.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">ecto/rumbl/config/dev.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment"># Configure your database</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">config ​<em class="string">:rumbl</em>​, Rumbl.Repo,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="string">username:</em>​ ​<em class="string">"</em>​​<em class="string">postgres"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="string">password:</em>​ ​<em class="string">"</em>​​<em class="string">postgres"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="string">database:</em>​ ​<em class="string">"</em>​​<em class="string">rumbl_dev"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="string">hostname:</em>​ ​<em class="string">"</em>​​<em class="string">localhost"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="string">pool_size:</em>​ 10</td></tr></table>
<p id="calibre_link-752" class="calibre19">








We specify the <span class="cf">username</span>, <span class="cf">password</span>, and <span class="cf">database</span>
parameters. You need to replace those with your own database username
and password.</p>
<p id="calibre_link-753" class="calibre19">Let’s verify our credentials are correct. Type the following command and
Ecto will create the underlying database, if it’s not already there:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">ecto.create</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">The database for Rumbl.Repo has been created.</td></tr></table>
<p id="calibre_link-754" class="calibre19">We haven’t yet done the heavy lifting to specify our users. We’ve
only tied Ecto to this PostgreSQL database. Let’s create some schemas
and tie those tables to code in our <span class="cf">Accounts</span> context.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-278"><div id="calibre_link-755" class="calibre2"><h2 id="calibre_link-89" class="calibre20">Defining the User Schema and Migration</h2>
<p id="calibre_link-756" class="calibre19">


At its core, Ecto lets you specify a struct that ties individual fields to the fields in database tables through a DSL. Let’s use that now. To define our schema, let’s replace our bare user struct in <span class="cf">lib/rumbl/accounts/user.ex</span> with the following:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/ecto/listings/rumbl/lib/rumbl/accounts/user.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">ecto/listings/rumbl/lib/rumbl/accounts/user.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ Rumbl.Accounts.User ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ Ecto.Schema</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">import</strong>​ Ecto.Changeset</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  schema ​<em class="string">"</em>​​<em class="string">users"</em>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    field ​<em class="string">:name</em>​, ​<em class="string">:string</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    field ​<em class="string">:username</em>​, ​<em class="string">:string</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    timestamps()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-757" class="calibre19">




This DSL is built with Elixir macros. The <span class="cf">schema</span> and <span class="cf">field</span> macros
let us specify both the underlying database table and the Elixir struct
at the same time. Each <span class="cf">field</span> corresponds to both a field in the database and a
field in our local <span class="cf">Accounts.User</span> struct. By default, Ecto defines the primary key called <span class="cf">:id</span> automatically. From the <span class="cf">schema</span> definition, Ecto automatically defines an Elixir struct for us, which we can create by calling <span class="cf">%Rumbl.Accounts.User{}</span> as we did before.</p>
<p id="calibre_link-758" class="calibre19">

Finally, our schema uses <span class="cf">use Ecto.Schema</span> at the top and it also imports
<span class="cf">Ecto.Changeset</span> functions which will allow us to work more easily with
changesets later on.</p>
<p id="calibre_link-759" class="calibre19">
We’ve treated our code with care, and we should give our database <span class="calibre4">at
least</span> the same level of respect. Now that we have our <span class="cf">Repo</span> and
<span class="cf">User</span> schema configured, we need to make the database reflect the
structure of our application. Ecto uses <span class="calibre4">migrations</span> for that purpose.
A migration changes a database to match the structure our application
needs. For our new feature, we need to add a migration to create our
users table with columns matching our <span class="cf">User</span> schema. Let’s generate one:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">ecto.gen.migration</strong>​​<strong class="kw"> </strong>​​<strong class="kw">create_users</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating priv/repo/migrations</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating priv/repo/migrations/20180315023132_create_users.exs</td></tr></table>
<p id="calibre_link-760" class="calibre19">






The <span class="cf">mix ecto.gen.migration</span> command creates a migration file for
us with a special timestamp to ensure ordering of our database
migrations. For this reason, your migration filename will have a
different prefix than ours. Key in these changes within your empty
<span class="cf">change</span> function:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/ecto/listings/rumbl/priv/repo/migrations/20180315023132_create_users.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">ecto/listings/rumbl/priv/repo/migrations/20180315023132_create_users.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ Rumbl.Repo.Migrations.CreateUsers ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ Ecto.Migration</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ change ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    create table(​<em class="string">:users</em>​) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      add ​<em class="string">:name</em>​, ​<em class="string">:string</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      add ​<em class="string">:username</em>​, ​<em class="string">:string</em>​, ​<em class="string">null:</em>​ false</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      add ​<em class="string">:password_hash</em>​, ​<em class="string">:string</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      timestamps()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    create unique_index(​<em class="string">:users</em>​, [​<em class="string">:username</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-761" class="calibre19">In the dark days of persistence frameworks, before migrations were
commonplace, changes to the database weren’t versioned with the source
code. Often, those changes weren’t even automated. That strategy was
fine if new code worked the first time, but it opened the door for
problems:</p><ul class="calibre28"><li class="calibre29">
<p id="calibre_link-762" class="calibre31">When deploying new code, programmers often introduced errors when
changing the database.</p></li><li class="calibre29">
<p id="calibre_link-763" class="calibre31">The high stress of code rollbacks led to frequent mistakes when
changes were rolled back under pressure.</p></li><li class="calibre29">
<p id="calibre_link-764" class="calibre31">Building a fresh development environment was tough because the
schema history was too fragmented.</p></li></ul>
<p id="calibre_link-765" class="calibre19">



In general, migrating a database, both up for a successful deploy and
down for an unsuccessful deploy, should be an automated and repeatable
process. The <span class="cf">Ecto.Migration</span>
API<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-262" href="#calibre_link-279">[14]</a></sup> provides several
functions to create, remove, and change database tables, fields, and
indexes. These functions also have counterparts to do the reverse.
Here, we used the <span class="cf">create</span>, <span class="cf">add</span>, and <span class="cf">timestamps</span> macros to build
our users table and matched the fields with our <span class="cf">User</span> schema. For
example, <span class="cf">add</span> creates a new field, and <span class="cf">timestamps</span> creates a couple
of fields for us, <span class="cf">inserted_at</span> and <span class="cf">updated_at</span>.</p>
<p id="calibre_link-766" class="calibre19">Overall, we created a table with six fields: the auto-generated <span class="cf">id</span>,
the <span class="cf">inserted_at</span> and <span class="cf">updated_at</span> timestamps,
<span class="cf">name</span>, <span class="cf">username</span>, and <span class="cf">password_hash</span>. We added <span class="cf">password_hash</span>
to the database but we didn’t list <span class="cf">password_hash</span> as a schema field for
now. We will introduce it when it’s time to discuss authentication in
Chapter 5, <a href="#calibre_link-94" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">​<em class="calibre4">Authenticating Users</em>​</a>. Finally, we add a unique index
to guarantee that the <span class="cf">username</span> field is unique across the whole table.</p>
<p id="calibre_link-767" class="calibre19">Now all that’s left is to migrate up our database:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">ecto.migrate</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] == Running Rumbl.Repo.Migrations.CreateUsers.change/0 forward</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] create table users</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] create index users_username_index</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] == Migrated in 0.0s</td></tr></table>
<p id="calibre_link-768" class="calibre19">




Be careful. The <span class="cf">ecto.migrate</span> task will migrate the database <span class="calibre4">for
your current environment</span>. So far, we’ve been running the <span class="cf">dev</span>
environment. To change the environment, you’d set the <span class="cf">MIX_ENV</span>
operating-system environment variable.</p>
<p id="calibre_link-769" class="calibre19">We’ve configured our database and created the schema with a migration. We are ready
to use our repository through the <span class="cf">Accounts</span> context. We just need to make
sure our repository services are up and running.</p>
<p id="calibre_link-770" class="calibre19">



Phoenix is built on top of OTP, a layer for reliably managing services.
We can use OTP to start key services like Ecto repositories in a supervised
process so that Ecto and Phoenix can do the right thing in case our
repository crashes. To do so, we simply need to list the <span class="cf">Rumbl.Repo</span> as a
child in our supervision tree. Phoenix already did that for us. Open up
<span class="cf">lib/rumbl/application.ex</span> and you will find this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">children = [</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="comment"># Start the Ecto repository</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Rumbl.Repo,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">]</td></tr></table>
<p id="calibre_link-771" class="calibre19">Now that our configuration is established, let’s take it for a spin.






</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-23"><div id="calibre_link-772" class="calibre2"><h2 id="calibre_link-90" class="calibre20">Using the Repository to Add Data</h2>
<p id="calibre_link-773" class="calibre19">




With our database ready, we can begin to persist our <span class="cf">Accounts.User</span> structs. Let’s hop into an IEx shell and create the users that we previously hardcoded in our Accounts context.</p>
<p id="calibre_link-774" class="calibre19">Spin up your console with <span class="cf">iex -S mix</span>, and insert some data:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ alias Rumbl.Repo</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ alias Rumbl.Accounts.User</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Repo.insert(%User{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​   ​<em class="string">name:</em>​ ​<em class="string">"</em>​​<em class="string">José"</em>​, ​<em class="string">username:</em>​ ​<em class="string">"</em>​​<em class="string">josevalim"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​ })</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[debug] QUERY OK db=5.0ms</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">INSERT INTO "users" ("name","username","inserted_at",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{:ok,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"> %Rumbl.Accounts.User{__meta__: #Ecto.Schema.Metadata&lt;:loaded, "users"&gt;,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  id: 1,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  inserted_at: ~N[2017-10-25 19:13:28.878179],</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  name: "José",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  updated_at: ~N[2017-10-25 19:13:28.879737],</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  username: "josevalim"}}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Repo.insert(%User{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​   ​<em class="string">name:</em>​ ​<em class="string">"</em>​​<em class="string">Bruce"</em>​, ​<em class="string">username:</em>​ ​<em class="string">"</em>​​<em class="string">redrapids"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​ })</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Repo.insert(%User{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​   ​<em class="string">name:</em>​ ​<em class="string">"</em>​​<em class="string">Chris"</em>​, ​<em class="string">username:</em>​ ​<em class="string">"</em>​​<em class="string">mccord"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​ })</td></tr></table>
<p id="calibre_link-775" class="calibre19">
And we’re up! You can see that Ecto is creating the <span class="cf">id</span> field and
populating our timestamps for us. It’s great to persist data, but how do we use Ecto to retrieve it? Let’s take a look:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Repo.all(User)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[debug] QUERY OK source="users" db=3.2ms decode=0.1ms queue=0.1ms</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">SELECT u0."id", u0."name", u0."username", u0."inserted_at", u0."updated_at"</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">FROM "users" AS u0 []</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  %Rumbl.Accounts.User{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    id: 1,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    name: "José",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    username: "josevalim",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  },</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  %Rumbl.Accounts.User{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    id: 2,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    name: "Bruce",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    username: "redrapids",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  },</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  %Rumbl.Accounts.User{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    id: 3,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    name: "Chris",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    username: "mccord",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Repo.get(User, 1)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[debug] QUERY OK source="users" db=3.4ms</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">SELECT u0."id", u0."name", u0."username",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">u0."inserted_at", u0."updated_at"</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">FROM "users" AS u0 WHERE (u0."id" = $1) [1]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%Rumbl.Accounts.User{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  id: 1,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  name: "José",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  username: "josevalim",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">}</td></tr></table>
<p id="calibre_link-776" class="calibre19">
Now that we can persist users to our repo and pull the accounts back out, we’re ready to wire up database access to our <span class="cf">Accounts</span> context. Make the following changes to your <span class="cf">lib/rumbl/accounts.ex</span> file:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/ecto/listings/rumbl/lib/rumbl/accounts.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">ecto/listings/rumbl/lib/rumbl/accounts.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">alias Rumbl.Repo</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">alias Rumbl.Accounts.User</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ get_user(id) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Repo.get(User, id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ get_user!(id) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Repo.get!(User, id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ get_user_by(params) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Repo.get_by(User, params)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ list_users ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Repo.all(User)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-777" class="calibre19">
We replaced our <span class="cf">get_user</span>, <span class="cf">get_user_by</span>, and <span class="cf">list_users</span> functions with calls into our Ecto repo. We added a new <span class="cf">get_user!</span> which raises an <span class="cf">Ecto.NotFoundError</span> when looking up a user that does not exist.</p>
<p id="calibre_link-778" class="calibre19">




If you’ve seen plenty of MVC applications in the past, you know how easy it is for that design to get away from you. It’s easy to see the concerns about persistence creep into the controller. As controller actions grow, business logic creeps in and the overall separation of concerns devolves, eroding design quality and crippling maintainability.</p>
<p id="calibre_link-779" class="calibre19">

Contrast that with our context, where there’s a logical parking place for all of these concerns. You can already see the benefits of our <span class="cf">Accounts</span> context in action. With our repo calls in place, we’re ready to try it out even though we haven’t touched our controller code at all.</p>
<p id="calibre_link-780" class="calibre19">Restart your server and then visit our users page at <span class="cf">http://localhost:4000/users</span> and view the logs to see the inserted records:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">phx.server</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] Running RumblWeb.Endpoint with Cowboy on http://localhost:4000</td></tr></table>
<p id="calibre_link-781" class="calibre19">Now visit <span class="cf">http://localhost:4000/users</span> as before, but watch the logs
to see Ecto’s SQL statements being executed:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] GET /users</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[debug] Processing with RumblWeb.UserController.index/2</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Parameters: %{}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Pipelines: [:browser]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[debug] QUERY OK source="users" db=1.0ms</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">SELECT u0."id", u0."name", u0."username", ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] Sent 200 in 1ms</td></tr></table>
<p id="calibre_link-782" class="calibre19">You can see that we’re fetching data from the database instead of the
in-memory hardcoded data. We’re making plenty of progress here, but there’s still work to do. Let’s build some forms to register new users via a web interface.




</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-185"><div id="calibre_link-783" class="calibre2"><h2 id="calibre_link-91" class="calibre20">Building Forms</h2>
<p id="calibre_link-784" class="calibre19">



Now that we have a database-backed context, let’s add the ability
to create new users in our system. We’re going to use Phoenix’s form
builders for that purpose. First, open up your controller at
<span class="cf">lib/rumbl_web/controllers/user_controller.ex</span> and set up a new user
account struct for our <span class="cf">new</span> template, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/ecto/listings/rumbl/lib/rumbl_web/controllers/user_controller.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">ecto/listings/rumbl/lib/rumbl_web/controllers/user_controller.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">alias Rumbl.Accounts.User</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ new(conn, _params) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  changeset = Accounts.change_user(%User{})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  render(conn, ​<em class="string">"</em>​​<em class="string">new.html"</em>​, ​<em class="string">changeset:</em>​ changeset)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-785" class="calibre19">





Notice the <span class="cf">Accounts.change_user</span> function. This function receives a struct, and returns an <span class="cf">Ecto.Changeset</span>.
Changesets let Ecto manage record changes, cast parameters, and perform validations. We use a changeset to build a customized strategy
for dealing with each specific kind of change, such as creating a user
or updating sensitive information. Let’s add a <span class="cf">changeset</span> function to
our <span class="cf">User</span> struct in <span class="cf">lib/rumbl/accounts/user.ex</span> with some essential
validations:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/ecto/listings/rumbl/lib/rumbl/accounts/user.change2.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">ecto/listings/rumbl/lib/rumbl/accounts/user.change2.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ changeset(user, attrs) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  user</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; cast(attrs, [​<em class="string">:name</em>​, ​<em class="string">:username</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; validate_required([​<em class="string">:name</em>​, ​<em class="string">:username</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; validate_length(​<em class="string">:username</em>​, ​<em class="string">min:</em>​ 1, ​<em class="string">max:</em>​ 20)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-786" class="calibre19">





Our changeset accepts an <span class="cf">Accounts.User</span> struct and attributes. We then pass the <span class="cf">cast</span> function a list of fields to tell Ecto that <span class="cf">name</span> and <span class="cf">username</span> are allowed to be cast as user input. This casts all allowable user input values to their schema types and rejects everything else. Next, we used <span class="cf">validate_required</span> which makes sure we provide all necessary required fields.</p>
<p id="calibre_link-787" class="calibre19">

We pipe <span class="cf">validate_required</span>, which returns an <span class="cf">Ecto.Changeset</span>, into
<span class="cf">validate_length</span> to validate the <span class="cf">username</span> length. <span class="cf">Ecto.Changeset</span>
defines <span class="cf">cast</span>, <span class="cf">validate_required</span>, and <span class="cf">validate_length</span>, which
we’ve imported at the top of our schema module.</p>
<p id="calibre_link-788" class="calibre19">Next, we need to expose our new functionality from our public <span class="cf">Accounts</span> context. Add a new <span class="cf">change_user</span> function which calls our user changeset:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/ecto/listings/rumbl/lib/rumbl/accounts.change2.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">ecto/listings/rumbl/lib/rumbl/accounts.change2.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ change_user(%User{} = user) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  User.changeset(user, %{})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-789" class="calibre19">


When we’re designing the business logic for our accounts, we need to decide what’s public and what’s private. The <span class="cf">Accounts</span> module itself is the only public API our controllers (or any other external components) should touch, but that doesn’t mean all logic related to accounts should live there. In this example, we added some private logic to <span class="cf">Accounts.User</span> which the context exposes via the <span class="cf">Accounts.change_user</span> function.</p>
<p id="calibre_link-790" class="calibre19">
We’re using layers to hide private logic behind a public API. There are many good ways to organize your code inside the context. You’ll choose the best one based on how you want to document, structure, and test the context internals.</p>
<p id="calibre_link-791" class="calibre19">At this point, you might wonder why Ecto adds this little bit of
complexity through changesets. You may have seen other frameworks that
add validations directly to the schema. We could simply write a set of
one-size-fits-all validations and then pass a set of updated
attributes to <span class="cf">create</span> or <span class="cf">update</span> functions, but that strategy might
lead to problems. Here’s why.</p><h3 class="calibre22">Handling Update Policies</h3>
<p id="calibre_link-792" class="calibre19">
When conventional persistence frameworks allow one-size-fits-all
validations, they’re forced to work harder and manage change across
multiple concerns. Here’s the problem. Say you have an account and your
new, simple application saves a simple password, hashed for security sake,
along with the record.</p>
<p id="calibre_link-793" class="calibre19">Next, imagine that your boss lays
down the requirement of logging into your application through
Facebook. That update requires a different kind of password
validation, and a different kind of enforcement for password rules, so
you build a custom validation and tweak your code in clever ways to
trigger the right password rules at the right time. That second policy
makes your <span class="cf">update_account</span> validations more complex, but they’re manageable.</p>
<p id="calibre_link-794" class="calibre19">Then, your
increasingly irritating boss asks for a JSON API, and your API
programmers aren’t content with the cute “Oops, an error was found”
error messages that seemed to work fine for end users. You need to
provide more information about what went wrong. You dig deeply
into the persistence API and decide that the error reporting no longer
works for you. Your stomach sinks as it does for that first rollercoaster drop while you hope against hope that the car will rise again,
but you instinctively know that this ride is at its zenith.  It’s
always downhill from here.</p>
<p id="calibre_link-795" class="calibre19">Here’s the problem. Your code has a <span class="calibre4">single update mechanism</span> but <span class="calibre4">multiple update policies</span>. Your code will continue to get more complex and difficult to maintain until you separate your update mechanisms. Ecto changesets allow you to do exactly that.</p>
<p id="calibre_link-796" class="calibre19">
<span class="calibre4">One size does not fit all</span> when it comes to update strategies.
Validations, error reporting, security, and the like can change. When
they do, if your single update policy is tightly coupled to a schema,
it’ll <span class="calibre4">hurt</span>. The changeset lets Ecto decouple update policy from the
schema, and that’s a good thing because you can handle each update
policy in its own separate changeset function. You’ll see a good
example of this policy segregation when you learn about
authentication.



</p><h3 class="calibre22">Building Resource Routes</h3>
<p id="calibre_link-797" class="calibre19">

Now that we’ve updated our schema, context, and controller to handle new users, we need to add the <span class="cf">new</span> action to our router. Replace your main router scope with the following code:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/ecto/listings/rumbl/lib/rumbl_web/router.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">ecto/listings/rumbl/lib/rumbl_web/router.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">scope ​<em class="string">"</em>​​<em class="string">/"</em>​, RumblWeb ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  pipe_through ​<em class="string">:browser</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  get ​<em class="string">"</em>​​<em class="string">/"</em>​, PageController, ​<em class="string">:index</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  resources ​<em class="string">"</em>​​<em class="string">/users"</em>​, UserController, ​<em class="string">only:</em>​ [​<em class="string">:index</em>​, ​<em class="string">:show</em>​, ​<em class="string">:new</em>​, ​<em class="string">:create</em>​]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-798" class="calibre19">




<span class="cf">resources</span> is a shorthand implementation for a common set of actions
that define create, read, update, and delete operations (commonly referred
to as CRUD) to access <span class="calibre4">resources</span> via simple HTTP verbs. We use
the <span class="cf">resources</span> macro to add a bunch of common routes that we’d
otherwise need to write by hand. Since <span class="cf">index</span> and <span class="cf">show</span> already
followed this convention, we remove the two <span class="cf">get</span> macros for the
<span class="cf">:index</span> and <span class="cf">:show</span> actions, and we replace them with the <span class="cf">resources</span>
macro. Since we don’t need the <span class="cf">edit</span> or <span class="cf">delete</span> actions, we pass the
<span class="cf">:only</span> option to explicitly list the routes we want generated. The
following would be equivalent to a <span class="cf">resources "/users",
UserController</span> declaration:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">get ​<em class="string">"</em>​​<em class="string">/users"</em>​, UserController, ​<em class="string">:index</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">get ​<em class="string">"</em>​​<em class="string">/users/:id/edit"</em>​, UserController, ​<em class="string">:edit</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">get ​<em class="string">"</em>​​<em class="string">/users/new"</em>​, UserController, ​<em class="string">:new</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">get ​<em class="string">"</em>​​<em class="string">/users/:id"</em>​, UserController, ​<em class="string">:show</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">post ​<em class="string">"</em>​​<em class="string">/users"</em>​, UserController, ​<em class="string">:create</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">patch ​<em class="string">"</em>​​<em class="string">/users/:id"</em>​, UserController, ​<em class="string">:update</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">put ​<em class="string">"</em>​​<em class="string">/users/:id"</em>​, UserController, ​<em class="string">:update</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">delete ​<em class="string">"</em>​​<em class="string">/users/:id"</em>​, UserController, ​<em class="string">:delete</em>​</td></tr></table>
<p id="calibre_link-799" class="calibre19">Sure, the <span class="cf">resources</span> macro has been known to reduce carpal tunnel
syndrome almost as much as an ergonomic workspace, but it’s more than
a keystroke saver. By keeping to these conventions where you can,
you’re also communicating in a language that other programmers also
understand. Creating these routes also makes additional functions
available. You can use routes by name to build links, HTML elements,
and the like.</p>
<p id="calibre_link-800" class="calibre19">

If at any time you want to see all available routes, you can run the
<span class="cf">phx.routes</span> Mix task, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">phx.routes</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">page_path  GET   /           RumblWeb.PageController :index</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">user_path  GET   /users      RumblWeb.UserController :index</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">user_path  GET   /users/new  RumblWeb.UserController :new</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">user_path  GET   /users/:id  RumblWeb.UserController :show</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">user_path  POST  /users      RumblWeb.UserController :create</td></tr></table>
<p id="calibre_link-801" class="calibre19">
With the route behind us, let’s move on to the template. Now create a
new file named <span class="cf">lib/rumbl_web/templates/user/new.html.eex</span> and add
this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/ecto/listings/rumbl/lib/rumbl_web/templates/user/new.html.eex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">ecto/listings/rumbl/lib/rumbl_web/templates/user/new.html.eex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;h1&gt;New User&lt;/h1&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment">&lt;%=</em>​ form_for @changeset, Routes.user_path(@conn, ​<em class="string">:create</em>​), ​<strong class="kw">fn</strong>​ f -&gt; ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;div&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="comment">&lt;%=</em>​ text_input f, ​<em class="string">:name</em>​, ​<em class="string">placeholder:</em>​ ​<em class="string">"</em>​​<em class="string">Name"</em>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;/div&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;div&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="comment">&lt;%=</em>​ text_input f, ​<em class="string">:username</em>​, ​<em class="string">placeholder:</em>​ ​<em class="string">"</em>​​<em class="string">Username"</em>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;/div&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="comment">&lt;%=</em>​ submit ​<em class="string">"</em>​​<em class="string">Create User"</em>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment">&lt;%</em>​ ​<strong class="kw">end</strong>​ ​<em class="comment">%&gt;</em>​</td></tr></table>
<p id="calibre_link-802" class="calibre19">



We use a function, rather than HTML tags, to build the form,
giving it an anonymous function. <span class="cf">form_for</span> provides conveniences like
security, UTF-8 encoding, and more. The function takes three
arguments: a changeset, a path, and an anonymous function. That
function takes one argument, the form data we’re labeling <span class="cf">f</span>. We’re
asking the template engine to build a function returning everything in
the template between <span class="cf">fn f -&gt;</span> and <span class="cf">end</span>. You can see the additional
functions in play as well. These build two input fields and a <span class="cf">submit</span>
tag. Similar to <span class="cf">link</span>, all those functions are documented in the
<span class="cf">Phoenix.HTML</span> library.<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-263" href="#calibre_link-186">[15]</a></sup></p>
<p id="calibre_link-803" class="calibre19">If we visit <span class="cf">http://localhost:4000/users/new</span> in our browser to
inspect the generated HTML, we see the following markup:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;form accept-charset=​<em class="string">"UTF-8"</em>​ action=​<em class="string">"/users"</em>​ method=​<em class="string">"post"</em>​&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;input name=​<em class="string">"_csrf_token"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">         type=​<em class="string">"hidden"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">         value=​<em class="string">"MFgTPhAieHUgGzJ2OiRDXXw3Luc7wV7h/reiiA=="</em>​&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;input name=​<em class="string">"_utf8"</em>​ type=​<em class="string">"hidden"</em>​ value=​<em class="string">"✓"</em>​&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;div&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    &lt;input id=​<em class="string">"user_name"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">           name=​<em class="string">"user[name]"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">           placeholder=​<em class="string">"Name"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">           type=​<em class="string">"text"</em>​&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;/div&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;div&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    &lt;input id=​<em class="string">"user_username"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">           name=​<em class="string">"user[username]"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">           placeholder=​<em class="string">"Username"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">           type=​<em class="string">"text"</em>​&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;/div&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;button type=​<em class="string">"submit"</em>​ value=​<em class="string">"Create User"</em>​&gt;&lt;/button&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;/form&gt;</td></tr></table>
<p id="calibre_link-804" class="calibre19">





You can see all of the work the <span class="cf">form_for</span> tag and the other
functions are doing for you. The special <span class="cf">_csrf_token</span> hidden
parameter was injected for us, and it makes sure that a user’s
requests are hard to spoof across sites. Also, though we didn’t
specify the name <span class="cf">user</span> with each of our text fields, the parameter
names like <span class="cf">user[name]</span> were pulled from our changeset.</p><div class="xxxsays"><div class="heading"><div class="persons-picture"><img src="images/000024.png" alt="José says:" class="calibre41" /></div><div class="label">José says:</div><div class="title">How Does Phoenix Know Which Data to Show in the Form?</div></div><div class="praise">
<p id="calibre_link-805" class="calibre14">





Our application passes a changeset from Ecto to the <span class="cf">form_for</span>
function. The Phoenix team had a problem. How should we make the changes
in the changeset available to the form? We could have hardcoded
<span class="cf">form_for</span> to directly use <span class="cf">Ecto.Changeset</span>, but we
weren’t happy with that choice. It would be brittle and hard to
extend.
</p>
<p id="calibre_link-806" class="calibre14">
Imagine that your company decides to build an in-house data
abstraction for some new technology and you want to integrate it with
Phoenix. With forms tightly coupled to changesets, you’d be lost.
You’d have to either rewrite forms or fork Phoenix. We needed a
contract. Elixir protocols are the perfect solution to this problem.
</p>
<p id="calibre_link-807" class="calibre14">To solve the <span class="cf">form_for</span> coupling problem, we defined a
protocol named <span class="cf">Phoenix.HTML.FormData</span>, which separates the
<span class="calibre4">interface</span> from the <span class="calibre4">implementation</span>.
<span class="cf">Ecto.Changeset</span> implements this protocol to convert its
internal data to the structure required by Phoenix forms, all properly
documented in the <span class="cf">Phoenix.HTML.FormData</span> contract. </p></div></div>
<p id="calibre_link-808" class="calibre19">You can probably guess where the data will go. The form will send a
<span class="cf">POST</span> request to <span class="cf">"/users"</span>, but we haven’t yet created the action
for it. Let’s do that now.
</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-187"><div id="calibre_link-809" class="calibre2"><h2 id="calibre_link-92" class="calibre20">Creating Resources</h2>
<p id="calibre_link-810" class="calibre19">

We have a form that submits the data for a new user. It’s time to surface this new feature in our controller. This work should happen in our context. Let’s extend <span class="cf">Accounts</span> to create users. Open up <span class="cf">lib/rumbl/accounts.ex</span> and key this in:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/ecto/listings/rumbl/lib/rumbl/accounts.change3.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">ecto/listings/rumbl/lib/rumbl/accounts.change3.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ create_user(attrs \\ %{}) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  %User{}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; User.changeset(attrs)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; Repo.insert()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-811" class="calibre19">
Take a look at the new short <span class="cf">create_user</span> function. We save our controller from this tiny bit of complexity. Our function has a short pipeline that starts with an empty user, applies a changeset, and then inserts it into the repository. The controller shouldn’t care about these short persistence details, but neither should the schema. We isolate change policy to a single place.</p>
<p id="calibre_link-812" class="calibre19">With the context ready, we can plug the changes into the controller. The question is where this work should happen. Recall our changes to the <span class="cf">router.ex</span> file, when we added the <span class="cf">resources "/users"</span> macro to <span class="cf">router.ex</span> to build a set of conventional routes. One new route maps posts to <span class="cf">"/users"</span> to the <span class="cf">UserController.create</span> action. Add a <span class="cf">create</span> function to <span class="cf">UserController</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/ecto/listings/rumbl/lib/rumbl_web/controllers/user_controller.change2.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">ecto/listings/rumbl/lib/rumbl_web/controllers/user_controller.change2.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ create(conn, %{​<em class="string">"</em>​​<em class="string">user"</em>​ =&gt; user_params}) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {​<em class="string">:ok</em>​, user} = Accounts.create_user(user_params)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; put_flash(​<em class="string">:info</em>​, ​<em class="string">"</em>​​<em class="string">#{</em>​user.name​<em class="string">}</em>​​<em class="string"> created!"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; redirect(​<em class="string">to:</em>​ Routes.user_path(conn, ​<em class="string">:index</em>​))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-813" class="calibre19">

This pattern of code should be getting familiar to you by now. We keep
piping functions together until the <span class="cf">conn</span> has the final result that
we want. Each function does an isolated transform step. We call into our context first, registering our user in the application. Then, we take the connection and transform it twice, adding a flash message with the <span class="cf">put_flash</span> function, and then add a redirect instruction with the <span class="cf">redirect</span> function. Both of these are simple <span class="cf">plug</span> functions that we use to transform the connection, one step at a time.



</p>
<p id="calibre_link-814" class="calibre19">Let’s examine one tiny detail here first. In some places, we’re going to need to refer to specific routes in the application. Generally, these get automatically generated, and you can access them from the <span class="cf">YourApplication.Router.Helpers</span> module. That’s a lot to type each time you need a route. In the auto-generated <span class="cf">rumbl_web</span> file, you’ll find the following snippet:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/ecto/rumbl/lib/rumbl_web.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">ecto/rumbl/lib/rumbl_web.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ controller ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">quote</strong>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">use</strong>​ Phoenix.Controller, ​<em class="string">namespace:</em>​ RumblWeb</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">import</strong>​ Plug.Conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">import</strong>​ RumblWeb.Gettext</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    alias RumblWeb.Router.Helpers, ​<em class="string">as:</em>​ Routes</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-815" class="calibre19">That’s the ticket. The line <span class="cf">alias RumblWeb.Router.Helpers, as: Routes</span> gives us exactly what we need. Here’s why.</p>
<p id="calibre_link-816" class="calibre19">




Phoenix automatically generates the <span class="cf">Helpers</span> inside your router which contains named helpers to help developers generate and keep their routes up to date. <span class="cf">Routes</span> is a simple alias for <span class="cf">Router.Helpers</span>. That’s why you can get any route through <span class="cf">Routes.some_path</span>!</p>
<p id="calibre_link-817" class="calibre19">Getting back to work, we can try out our shiny new <span class="cf">create</span> action. Go visit <span class="cf">http://localhost:4000/users/new</span>:</p><div class="praise"><img id="calibre_link-818" class="border5" src="images/000042.png" alt="images/src/ecto/new_user_form.png" width="720" height="319" /></div>
<p id="calibre_link-819" class="calibre19">And when we click Create User, we should be sent back to the users
index page to see our inserted user as shown in the <a href="#calibre_link-188" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">figure</a>.</p><div id="calibre_link-188" class="praise"><div class="praise"><img id="calibre_link-820" class="border5" src="images/000004.png" alt="images/src/ecto/new_user_added.png" width="720" height="550" /></div></div>
<p id="calibre_link-821" class="calibre19">We still have work to do, though. Type a username that’s too long, and
you’re greeted with Phoenix’s debug error page with the error “no
match of right hand side value.”</p>
<p id="calibre_link-822" class="calibre19">





We were expecting a result of the shape <span class="cf">{:ok, user}</span> but got
<span class="cf">{:error, %Ecto.Changeset{}}</span>. Our validations failed, throwing an error page.
To fix this problem, let’s check for both <span class="cf">:ok</span> and <span class="cf">:error</span>
outcomes, showing validation errors upon failure. First we
need to update our <span class="cf">UserController</span> to react to an invalid changeset:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/ecto/listings/rumbl/lib/rumbl_web/controllers/user_controller.change3.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">ecto/listings/rumbl/lib/rumbl_web/controllers/user_controller.change3.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ create(conn, %{​<em class="string">"</em>​​<em class="string">user"</em>​ =&gt; user_params}) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">case</strong>​ Accounts.create_user(user_params) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, user} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      |&gt; put_flash(​<em class="string">:info</em>​, ​<em class="string">"</em>​​<em class="string">#{</em>​user.name​<em class="string">}</em>​​<em class="string"> created!"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      |&gt; redirect(​<em class="string">to:</em>​ Routes.user_path(conn, ​<em class="string">:index</em>​))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:error</em>​, %Ecto.Changeset{} = changeset} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      render(conn, ​<em class="string">"</em>​​<em class="string">new.html"</em>​, ​<em class="string">changeset:</em>​ changeset)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-823" class="calibre19">
Easy enough. We insert the new user record and then match on the return code.
On <span class="cf">:ok</span>, we add a flash message to the <span class="cf">conn</span> and then redirect to the
<span class="cf">user_path</span>. That route takes us to the <span class="cf">index</span> action. On error, we
simply re-render <span class="cf">new.html</span>, passing the <span class="cf">conn</span> and the
<span class="cf">changeset</span> with the failed validations. We’ll use the Phoenix input fields to handle
the problem.</p>
<p id="calibre_link-824" class="calibre19">Show the validation errors for each form input field in
<span class="cf">lib/rumbl_web/templates/user/new.html.eex</span>, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/ecto/listings/rumbl/lib/rumbl_web/templates/user/new.change1.html.eex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">ecto/listings/rumbl/lib/rumbl_web/templates/user/new.change1.html.eex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment">&lt;%=</em>​ ​<strong class="kw">if</strong>​ @changeset.action ​<strong class="kw">do</strong>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;div class=​<em class="string">"alert alert-danger"</em>​&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    &lt;p&gt;Oops, something went wrong! Please check the errors below.&lt;/p&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;/div&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment">&lt;%</em>​ ​<strong class="kw">end</strong>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;div&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="comment">&lt;%=</em>​ text_input f, ​<em class="string">:name</em>​, ​<em class="string">placeholder:</em>​ ​<em class="string">"</em>​​<em class="string">Name"</em>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="comment">&lt;%=</em>​ error_tag f, ​<em class="string">:name</em>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;/div&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;div&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="comment">&lt;%=</em>​ text_input f, ​<em class="string">:username</em>​, ​<em class="string">placeholder:</em>​ ​<em class="string">"</em>​​<em class="string">Username"</em>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="comment">&lt;%=</em>​ error_tag f, ​<em class="string">:username</em>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;/div&gt;</td></tr></table>
<p id="calibre_link-825" class="calibre19">



The <span class="cf">:action</span> field of a changeset indicates an action we tried to
perform on it, such as <span class="cf">:insert</span>. When we build a new changeset,
the field is <span class="cf">nil</span>. If Phoenix renders our form with any
action, we know the form action had validation errors. In our code,
we first check for the existence of <span class="cf">@changeset.action</span>. If it’s
present, we show a validation notice at the top of the form. Next, we
use the <span class="cf">error_tag</span> function defined in
<span class="cf">lib/rumbl_web/views/error_helpers.ex</span> to display an error tag next to
each form input with the validation error for each field.</p>
<p id="calibre_link-826" class="calibre19">Now try again to submit your form with invalid fields:</p><div class="praise"><img id="calibre_link-827" class="border5" src="images/000029.png" alt="images/src/ecto/user_validation_errors.png" width="720" height="505" /></div>
<p id="calibre_link-828" class="calibre19">Presto!</p>
<p id="calibre_link-829" class="calibre19">
If you’ve not yet appreciated the Ecto strategy for changesets, this
code should help. The changeset had all validation errors because the
Ecto changeset carries the validations and stores this information for
later use. In addition to validation errors, the changesets also
<span class="calibre4">track changes</span>!</p>
<p id="calibre_link-830" class="calibre19">


Remember, we don’t have to compromise our context by letting Ecto persistence details bleed through. We’re actually surfacing <span class="calibre4">Phoenix form details</span> because changesets implement the <span class="cf">Phoenix.HTML.FormData</span> protocol.</p>
<p id="calibre_link-831" class="calibre19">Let’s see how that works. Crack open IEx. If you have an old window already open, you can just recompile the current project:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ recompile()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ alias Rumbl.Accounts.User</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ changeset = User.changeset(%User{​<em class="string">username:</em>​ ​<em class="string">"</em>​​<em class="string">eric"</em>​, ​<em class="string">name:</em>​ ​<em class="string">"</em>​​<em class="string">Eric"</em>​}, %{})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%Ecto.Changeset{changes: %{}, ...}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ ​<strong class="kw">import</strong>​ Ecto.Changeset</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Ecto.Changeset</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ changeset = put_change(changeset, ​<em class="string">:username</em>​, ​<em class="string">"</em>​​<em class="string">ericmj"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%Ecto.Changeset{changes: %{username: "ericmj"}, ...}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ changeset.changes</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%{username: "ericmj"}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ get_change(changeset, ​<em class="string">:username</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">"ericmj"</td></tr></table>
<p id="calibre_link-832" class="calibre19">
Now you have a more complete picture. Ecto is using changesets as a
bucket to hold everything related to a database change, before and
after persistence. You can use this information to do more than see
what changed. Ecto lets you write code to do the minimal required
database operation to update a record. If a particular change must be
checked against a database constraint, such as a unique index,
changesets do that. If Ecto can enforce validations without hitting
the database, you can do that too. You’ll explore the broader
changeset API, validations, and strategies as we build out the rest of
our application.












</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-261"><div id="calibre_link-833" class="calibre2"><h2 id="calibre_link-93" class="calibre20">Wrapping Up</h2>
<p id="calibre_link-834" class="calibre19">It’s a good time to pause and take stock of what we’ve done. It’s been
a busy chapter.</p><ul class="calibre28"><li class="calibre29">
<p id="calibre_link-835" class="calibre31">We began the chapter by introducing Ecto and announcing our
intention to replace the naive implementation in our context
with a database-backed Ecto repository.</p></li><li class="calibre29">
<p id="calibre_link-836" class="calibre31">We configured our new database and connected it to OTP, so that
Elixir could do the right thing in the event our repository crashes.</p></li><li class="calibre29">
<p id="calibre_link-837" class="calibre31">We created a schema, complete with information about each necessary
field.</p></li><li class="calibre29">
<p id="calibre_link-838" class="calibre31">We created a migration, to help us specify our database tables and
automate doing and undoing any database changes.</p></li><li class="calibre29">
<p id="calibre_link-839" class="calibre31">We created a changeset so Ecto could efficiently track and manage
each change requested by our application.</p></li><li class="calibre29">
<p id="calibre_link-840" class="calibre31">We integrated this change into our application.</p></li></ul>
<p id="calibre_link-841" class="calibre19">We’ve already come a long way, and we’re only a few chapters in. We’re
ready to handle some more sophisticated application features. Let’s
get rolling. In the next chapter, you’ll use some of these new
features to authenticate a user.</p>

<div class="footnotes">
<h4 class="calibre24">Footnotes</h4>
<dl class="calibre25">
<dt class="footnote-number"><a id="calibre_link-279" href="#calibre_link-262" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[14]</a></dt><dd class="calibre26">
<p id="calibre_link-842" class="calibre27"><a href="http://hexdocs.pm/ecto/Ecto.Migration.html" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">http://hexdocs.pm/ecto/Ecto.Migration.html</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-186" href="#calibre_link-263" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[15]</a></dt><dd class="calibre26">
<p id="calibre_link-843" class="calibre27"><a href="http://hexdocs.pm/phoenix_html" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">http://hexdocs.pm/phoenix_html</a></p></dd></dl></div>
<div class="copyright">Copyright © 2020, The Pragmatic Bookshelf.</div>




</div>



  </div>


<div class="calibre1" id="calibre_link-300"><div id="calibre_link-844" class="calibre2"><h1 class="pcalibre6 chapter-title" id="calibre_link-94"><span class="chapter-number">
            Chapter
            5</span><br class="calibre18" /><span class="chapter-name">Authenticating Users</span></h1>

<p id="calibre_link-845" class="calibre19">


We have something that is starting to look like an application. Our database-backed <span class="cf">Accounts</span> context is wired to our controller using changesets and forms. Let’s ramp up the sophistication with real login forms and sessions. Rather than use something off the shelf, we can build it ourselves. Along the way you’ll learn more about managing change with <span class="calibre4">Ecto changesets</span> and chaining together functions using <span class="calibre4">plugs</span>. Finally, we’ll introduce session handling so our application can track logged-in users.</p>
<p id="calibre_link-846" class="calibre19">As you’ve seen, Phoenix makes it easy to add functionality to your application from bottom to top. Authentication forms the foundation for your whole application’s security system, though, so we’re going to be sure each decision is right.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-14"><div id="calibre_link-847" class="calibre2"><h2 id="calibre_link-95" class="calibre20">Preparing for Authentication</h2>
<p id="calibre_link-848" class="calibre19">
Authentication is one of those features that can make or break your whole application experience. Programmers need to be able to easily layer on the right services and to direct requests where they need to go. Administrators need to trust the underlying policies, and also to configure the password constraints. Initially, we’ll plan our approach and install the necessary dependencies.</p>
<p id="calibre_link-849" class="calibre19">

Our approach to authentication will be a conventional one. Users will provide credentials when registering. We’ll store those in the database in a secure way. In our application, a <span class="calibre4">session</span> will contain the data about each individual user. We’ll let Phoenix manage the details. A user starting a session will need to provide the credentials, and we’ll check those against our database. We’ll mark each user as authenticated in the session, so that users are granted access until their sessions expire or they log out. We will build these functions and expose those ideas into the <span class="cf">Accounts</span> context.</p>
<p id="calibre_link-850" class="calibre19">
Above all else, we want this system to be secure. We won’t write the dicey parts ourselves, and we’ll make sure that we use approaches that are well understood to be secure. We’ll use as much as we can from Phoenix, and we’ll rely on Comeonin to handle the critical hashing piece.</p>
<p id="calibre_link-851" class="calibre19">




Comeonin<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-201" href="#calibre_link-15">[16]</a></sup> is a specification for password hashing libraries. It provides up-to-date and secure hashing schemes. We will use the Pbkdf2 password hashing technique, as it does not require any native dependencies, but there are other options listed on Comeonin’s documentation. Add <span class="cf">:pbkdf2_elixir</span> to your <span class="cf">mix.exs</span> dependencies to handle password hashing, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defp</strong>​ deps ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  [</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ...,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:pbkdf2_elixir</em>​, ​<em class="string">"</em>​​<em class="string">~&gt; 1.0"</em>​}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-852" class="calibre19">



<span class="cf">:pbkdf2_elixir</span>, like our other dependencies in <span class="cf">mix.exs</span>, is an application. An application is what you think it is: a collection of modules that work together and can be managed as a whole. So far, our application depends on <span class="cf">:phoenix</span> and <span class="cf">:phoenix_ecto</span>, as you’d expect, but also the <span class="cf">:postgrex</span> database driver, <span class="cf">:gettext</span> for internationalization, and now <span class="cf">:pbkdf2_elixir</span> for managing our password hashing.</p>
<p id="calibre_link-853" class="calibre19">

Our application also relies on applications that ship as part of Elixir and Erlang. Those are not listed under <span class="cf">deps</span>, but within the <span class="cf">application</span> function in your <span class="cf">mix.exs</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/authentication/rumbl/mix.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">authentication/rumbl/mix.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ application ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  [</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">mod:</em>​ {Rumbl.Application, []},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">extra_applications:</em>​ [​<em class="string">:logger</em>​, ​<em class="string">:runtime_tools</em>​]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-854" class="calibre19">




The <span class="cf">application</span> function tells Mix how to start our <span class="cf">:rumbl</span> application, and we configure Elixir to start <span class="cf">:logger</span> and <span class="cf">:runtime_tools</span>, which are part of the standard library.</p>
<p id="calibre_link-855" class="calibre19">
Now run <span class="cf">mix deps.get</span> to fetch your new dependencies, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">deps.get</strong>​</td></tr></table>
<p id="calibre_link-856" class="calibre19">


This command downloads the <span class="cf">:pbkdf2_elixir</span> dependency into <span class="cf">deps</span> directory. Elixir will make sure to start it before your own <span class="cf">:rumbl</span> application. Now that our preparations are out of the way, we’re ready to begin the implementation.
</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-169"><div id="calibre_link-857" class="calibre2"><h2 id="calibre_link-96" class="calibre20">Managing Registration Changesets</h2>
<p id="calibre_link-858" class="calibre19">



You’ve already seen a changeset for creating a new user, the one that handles the name and username. Let’s review that now:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/authentication/rumbl/lib/rumbl/accounts/user.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">authentication/rumbl/lib/rumbl/accounts/user.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ changeset(user, attrs) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  user</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; cast(attrs, [​<em class="string">:name</em>​, ​<em class="string">:username</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; validate_required([​<em class="string">:name</em>​, ​<em class="string">:username</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; validate_length(​<em class="string">:username</em>​, ​<em class="string">min:</em>​ 1, ​<em class="string">max:</em>​ 20)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-859" class="calibre19">






</p>
<p id="calibre_link-860" class="calibre19">

The <span class="cf">Ecto.Changeset.cast</span> function converts a raw map of user input to a changeset, accepting only the <span class="cf">:name</span> and <span class="cf">:username</span> keys. Then, we fire a validation limiting the length of valid usernames to twenty characters. A failing validation places errors in the changeset so we can display them to the user.</p>
<p id="calibre_link-861" class="calibre19">
As you might expect, you’ll use <span class="calibre4">one changeset per use case</span>. Our existing changeset handles all the attributes except passwords. We can safely use it for updating nonsensitive information such as a form on a profile page. We’ll build a separate changeset to manage more sensitive data such as credential changes.</p>
<p id="calibre_link-862" class="calibre19">For the password changeset, we’ll add two new fields, <span class="cf">:password</span> and <span class="cf">:password_hash</span>. The <span class="cf">:password</span> field will contain the password in plain text, but for security reasons we won’t store that field in the database. Instead, we will hash the password in the <span class="cf">:password_hash</span> field we added to the <span class="cf">users</span> table way back in Chapter 4, <a href="#calibre_link-87" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">​<em class="calibre4">Ecto and Changesets</em>​</a>. Now, we’ll define those two fields in the schema:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/authentication/listings/rumbl/lib/rumbl/accounts/user.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">authentication/listings/rumbl/lib/rumbl/accounts/user.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">field ​<em class="string">:password</em>​, ​<em class="string">:string</em>​, ​<em class="string">virtual:</em>​ true</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">field ​<em class="string">:password_hash</em>​, ​<em class="string">:string</em>​</td></tr></table>
<p id="calibre_link-863" class="calibre19">

We marked the <span class="cf">:password</span> field as <span class="cf">virtual: true</span>. Virtual schema fields in Ecto exist only in the struct, not the database.</p>
<p id="calibre_link-864" class="calibre19">Now let’s create our separate changeset to handle user registrations:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/authentication/listings/rumbl/lib/rumbl/accounts/user.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">authentication/listings/rumbl/lib/rumbl/accounts/user.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ registration_changeset(user, params) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  user</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; changeset(params)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; cast(params, [​<em class="string">:password</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; validate_required([​<em class="string">:password</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; validate_length(​<em class="string">:password</em>​, ​<em class="string">min:</em>​ 6, ​<em class="string">max:</em>​ 100)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; put_pass_hash()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-865" class="calibre19">
There’s not much to see here. We defined a <span class="cf">registration_changeset</span> function which creates a new <span class="cf">changeset</span>,  casts the <span class="cf">:password</span> field and validates it. Then, our function delegates to the <span class="cf">put_pass_hash</span> function to compute and store the user hash in the database, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/authentication/listings/rumbl/lib/rumbl/accounts/user.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">authentication/listings/rumbl/lib/rumbl/accounts/user.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defp</strong>​ put_pass_hash(changeset) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">case</strong>​ changeset ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    %Ecto.Changeset{​<em class="string">valid?:</em>​ true, ​<em class="string">changes:</em>​ %{​<em class="string">password:</em>​ pass}} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      put_change(changeset, ​<em class="string">:password_hash</em>​, Pbkdf2.hash_pwd_salt(pass))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    _ -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      changeset</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-866" class="calibre19">

We check to see if the changeset is valid so we won’t waste time hashing an invalid or missing password. Then, we use <span class="cf">comeonin</span> to hash our password, following the instructions in its <span class="cf">readme</span> file. Finally, we put the result into the changeset as <span class="cf">password_hash</span>.  If the changeset is invalid, we simply return it to the caller.</p><table class="simpletable"><thead class="calibre33"><tr class="calibre34"><th colspan="2" class="outerlines"><p class="calibre31">These password rules are light</p></th></tr></thead><tbody class="calibre35"><tr class="tr"><td class="calibre36">
               <img id="calibre_link-867" class="calibre37" src="images/000012.png" alt="images/aside-icons/warning.png" width="260" height="271" />
             </td><td class="calibre38">

  <p class="calibre31">
  
    We’re creating an intentionally lax password so readers can focus on learning concepts instead of memorizing passwords. You will want to use more strict password requirements in a production system.
  </p>
</td></tr></tbody></table>
<p id="calibre_link-868" class="calibre19">Here you can see how easy it is to compose with changesets. We used our base <span class="cf">User.changeset</span> function to cast and validate the <span class="cf">name</span> and <span class="cf">username</span> parameters. Then we validated our virtual password field inside our registration changeset. Notice that it’s trivial to validate our virtual <span class="cf">password</span> field, though we’re not actually storing that value in the database! Persistence is not strongly coupled to our change policies.</p>
<p id="calibre_link-869" class="calibre19">


Keep in mind that this is an example application, and you should configure your own password rules to fit your scenario. If you would like, OWASP<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-202" href="#calibre_link-170">[17]</a></sup> has an excellent set of guidelines you can follow depending on your specific requirements.</p>
<p id="calibre_link-870" class="calibre19">Let’s take it for a spin.</p>
<p id="calibre_link-871" class="calibre19">Open up a console and follow along. If you’ve been following along and aren’t working on a new console, you can safely skip <span class="cf">alias RumblWeb.Router.Helpers, as: Routes</span>.</p>
<p id="calibre_link-872" class="calibre19">Let’s try out our changeset:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ alias Rumbl.Accounts.User</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ alias RumblWeb.Router.Helpers, ​<em class="string">as:</em>​ Routes</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ changeset = User.registration_changeset(%User{}, %{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​   ​<em class="string">username:</em>​ ​<em class="string">"</em>​​<em class="string">max"</em>​, ​<em class="string">name:</em>​ ​<em class="string">"</em>​​<em class="string">Max"</em>​, ​<em class="string">password:</em>​ ​<em class="string">"</em>​​<em class="string">123"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​ })</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">#Ecto.Changeset&lt;​<span class="coprompt">...&gt;</span>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ changeset.valid?</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">false</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ changeset.changes</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  name: "Max",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  username: "max",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  password: "123"</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">}</td></tr></table>
<p id="calibre_link-873" class="calibre19">As we expected, creating a user with our registration changeset and a bad password results in an invalid changeset. When we inspect the <span class="cf">changeset.changes</span>, we can see that <span class="cf">password_hash</span> is missing because we didn’t bother hashing a password we knew to be invalid.</p>
<p id="calibre_link-874" class="calibre19">Let’s continue and see what happens when we create a valid registration changeset:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ changeset = User.registration_changeset(%User{}, %{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​   ​<em class="string">username:</em>​ ​<em class="string">"</em>​​<em class="string">max"</em>​, ​<em class="string">name:</em>​ ​<em class="string">"</em>​​<em class="string">Max"</em>​, ​<em class="string">password:</em>​ ​<em class="string">"</em>​​<em class="string">asecret"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​ })</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">#Ecto.Changeset&lt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  action: nil,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  changes: %{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    name: "Max",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    username: "max",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    password: "asecret",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    password_hash:</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      "$pbkdf2-sha512$r7zRM4aQgSUGlOy4483cFe1UouMC/9emcOI75MhgDQ6A9WNWBpfr."</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  },</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  errors: [],</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  data: #Rumbl.Accounts.User&lt;&gt;,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  valid?: true</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&gt;</td></tr></table>
<p id="calibre_link-875" class="calibre19">Check to see if it’s valid, and see the changes:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ changeset.valid?</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">true</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ changeset.changes</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  name: "Max",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  username: "max",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  password: "asecret",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  password_hash:</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    "$pbkdf2-sha512$r7zRM4aQgSUGlOy4483cFe1UouMC/9emcOI75MhgDQ6A9WNWBpfr."</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">}</td></tr></table>
<p id="calibre_link-876" class="calibre19">
When given a valid username and password, our changeset applies the <span class="cf">put_pass_hash</span> function and puts a change for our <span class="cf">password_hash</span> field, but we now have an issue. The users we inserted up to this point lack account passwords, which won’t be valid with the system’s new behavior where we expect all accounts to have one. Let’s fix that now by updating our existing users with properly hashed temporary passwords. Key this into your IEx session. If you’re using an existing window, you may need to recompile with <span class="cf">recompile</span>:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ recompile()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ alias Rumbl.Repo</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ for u &lt;- Repo.all(User) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​   Repo.update!(User.registration_changeset(u, %{​<em class="string">password:</em>​ ​<em class="string">"</em>​​<em class="string">temppass"</em>​}))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​ ​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-877" class="calibre19">Now our new and existing users alike will have valid, secure passwords.</p>
<p id="calibre_link-878" class="calibre19">











</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-225"><div id="calibre_link-879" class="calibre2"><h2 id="calibre_link-97" class="calibre20">Creating Users</h2>
<p id="calibre_link-880" class="calibre19">


Now that things are working smoothly and safely, let’s integrate that new code with our web layer through the public API we expose through the <span class="cf">Accounts</span> context. We’ll need to replace <span class="cf">Accounts.create_user</span> with a function that performs proper account registration with passwords.</p>
<p id="calibre_link-881" class="calibre19">Since our <span class="cf">UserController</span> currently calls the <span class="cf">Accounts.create_user</span> function, we hope to get by with minimal changes. Our approach works fine but internally we are only using the base <span class="cf">User.changeset</span> which doesn’t yet include our password hashing.</p>
<p id="calibre_link-882" class="calibre19">At this point, we could change the <span class="cf">Accounts.create_user</span> function to use the <span class="cf">registration_changeset</span>. Instead, we will explicitly build a new function to manage registration details. We’ll maintain <span class="cf">create_user</span> to expose the details <span class="calibre4">any other API</span> will need to build users. So often, applications must create accounts to satisfy a number of different use cases, such as seeding example data, imports, or sending user invitations. For these cases, we want a workflow in our Accounts context that allows us to create a user without the full ceremony that end users use.</p>
<p id="calibre_link-883" class="calibre19">We will write a new <span class="cf">Accounts.register_user</span> function which wraps up all the details of end-user registration, while maintaining our API for simply creating a new user in the system. While we are at it, let’s add a function to expose the registration changeset in the <span class="cf">User</span> schema. Open up your <span class="cf">Accounts</span> context and add these functions:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/authentication/listings/rumbl/lib/rumbl/accounts.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">authentication/listings/rumbl/lib/rumbl/accounts.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ change_registration(%User{} = user, params) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  User.registration_changeset(user, params)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ register_user(attrs \\ %{}) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  %User{}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; User.registration_changeset(attrs)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; Repo.insert()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-884" class="calibre19">Any view that requires the user passwords will need to use a specific changeset for registration. This new function isn’t very exciting, but as we grow our application, our purpose-built functions will pay dividends by simplifying interactions with our controller. For example, as soon as we’re ready to send welcome emails when a new user registers, we have a perfect place for this new code to live.</p>
<p id="calibre_link-885" class="calibre19">Next, we need to make a tiny change in the <span class="cf">UserController</span>. The <span class="cf">create</span> action must now call our new <span class="cf">register_user</span> function and the <span class="cf">new</span> action must pull in our registration changeset, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/authentication/listings/rumbl/lib/rumbl_web/controllers/user_controller.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">authentication/listings/rumbl/lib/rumbl_web/controllers/user_controller.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ new(conn, _params) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  changeset = Accounts.change_registration(%User{}, %{})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  render(conn, ​<em class="string">"</em>​​<em class="string">new.html"</em>​, ​<em class="string">changeset:</em>​ changeset)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ create(conn, %{​<em class="string">"</em>​​<em class="string">user"</em>​ =&gt; user_params}) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">case</strong>​ Accounts.register_user(user_params) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, user} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      |&gt; put_flash(​<em class="string">:info</em>​, ​<em class="string">"</em>​​<em class="string">#{</em>​user.name​<em class="string">}</em>​​<em class="string"> created!"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      |&gt; redirect(​<em class="string">to:</em>​ Routes.user_path(conn, ​<em class="string">:index</em>​))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:error</em>​, %Ecto.Changeset{} = changeset} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      render(conn, ​<em class="string">"</em>​​<em class="string">new.html"</em>​, ​<em class="string">changeset:</em>​ changeset)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-886" class="calibre19">

In <span class="cf">create</span> we use pattern matching to pick off the <span class="cf">user_params</span> and pass them to our new <span class="cf">Accounts.register_user</span> function. If our registration was successful, we redirect as before. If not, we simply render the <span class="cf">new</span> template again, with the changeset, which now has the errors from our failed validations.</p>
<p id="calibre_link-887" class="calibre19">Finally, we need to make one small change to our new user registration form to accept the user password. Open up <span class="cf">lib/rumbl_web/templates/user/new.html.eex</span> and add the following code above the submit button:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/authentication/listings/rumbl/lib/rumbl_web/templates/user/new.change1.html.eex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">authentication/listings/rumbl/lib/rumbl_web/templates/user/new.change1.html.eex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;div&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;%= password_input f, ​<em class="string">:password</em>​, ​<em class="string">placeholder:</em>​ ​<em class="string">"</em>​​<em class="string">Password"</em>​ %&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;%= error_tag f, ​<em class="string">:password</em>​ %&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;/div&gt;</td></tr></table>
<p id="calibre_link-888" class="calibre19">Now, we’re ready to load the registration form at <span class="cf">http://localhost:4000/users/new</span>:</p><div class="praise"><img id="calibre_link-889" class="border5" src="images/000045.png" alt="images/src/authentication/registration_form.png" width="720" height="436" /></div>
<p id="calibre_link-890" class="calibre19">

You should be smiling now. Like plug pipelines, validations are a pipeline of functions that transform the <span class="cf">changeset</span>. Each validation is a step that transforms the changeset, explicitly tracking the changes and their validity. The actual change happens only when we call the repository in the context.</p>
<p id="calibre_link-891" class="calibre19">





Now we should be able to visit <span class="cf">http://localhost:4000/users/new</span> and create new users with our registration changeset. We have a problem, though.  Newly registered users are not automatically logged in, and users still can’t log in or log out at will.</p>
<p id="calibre_link-892" class="calibre19">We need to create an authentication service and make it available throughout our system. You’ve used plugs created by others, but for this job it’s time you learn to create your own. We’ll implement authentication as a plug. That way we can add it to a pipeline in our router so other controllers can use it as needed.




</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-249"><div id="calibre_link-893" class="calibre2"><h2 id="calibre_link-98" class="calibre20">The Anatomy of a Plug</h2>
<p id="calibre_link-894" class="calibre19">







Before we build our plug, let’s take a deep dive into the Plug library and learn how plugs work from the inside. There are two kinds of plugs: <span class="calibre4">module plugs</span> and <span class="calibre4">function plugs</span>. A function plug is a single function. A module plug is a module that provides two functions with some configuration details. Either way, they work the same.</p>
<p id="calibre_link-895" class="calibre19">
We have seen both kinds of plugs in use. From the endpoint module in <span class="cf">lib/rumbl_web/endpoint.ex</span>, you can see an example of a module plug:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">plug Plug.RequestId</td></tr></table>
<p id="calibre_link-896" class="calibre19">
You specify a module plug by providing the module name. In the router, you can see an example of a function plug:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">plug ​<em class="string">:protect_from_forgery</em>​</td></tr></table>
<p id="calibre_link-897" class="calibre19">

You specify a function plug with the name of the function as an atom. Because a module is just a collection of functions, it strengthens the idea that plugs are just functions.</p>
<p id="calibre_link-898" class="calibre19">For our first plug, we’ll write a module plug that encapsulates all the authentication logic in one place.</p><h3 class="calibre22">Module Plugs</h3>
<p id="calibre_link-899" class="calibre19">

Sometimes you might want to share a plug across more than one module. In that case, you can use a module plug. To satisfy the Plug specification, a module plug must have two functions, named <span class="cf">init</span> and <span class="cf">call</span>.</p>
<p id="calibre_link-900" class="calibre19">The simplest possible module plug returns the given options on <span class="cf">init</span> and the given connection on <span class="cf">call</span>. This plug does nothing:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ NothingPlug ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ init(opts) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    opts</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ call(conn, _opts) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-901" class="calibre19">
Remember, a typical plug transforms a connection. The main work of a module plug happens in <span class="cf">call</span>. In our <span class="cf">NothingPlug</span>, we simply pass the connection through without changes. The <span class="cf">call</span> will happen <span class="calibre4">at runtime</span>.</p>
<p id="calibre_link-902" class="calibre19">Sometimes, you might want to let the programmer change the behavior of a plug. We can do that work in the second argument to <span class="cf">call</span>, options. In our <span class="cf">NothingPlug</span>, we don’t need any more information to do our job, so we ignore the options.</p>
<p id="calibre_link-903" class="calibre19">

Sometimes, you might need Phoenix to do some heavy lifting to transform options. That’s the job of the <span class="cf">init</span> function. Plug uses the result of <span class="cf">init</span> as the second argument to <span class="cf">call</span>. In development mode, Phoenix calls <span class="cf">init</span> at runtime, but in production mode, <span class="cf">init</span> is called only once, at <span class="calibre4">compile time</span>. This strategy makes <span class="cf">init</span> the perfect place to validate and transform options without slowing down every request so <span class="cf">call</span> can be as fast as possible. Since <span class="cf">call</span> is the workhorse of Plug, we want it to do as little work as possible.</p>
<p id="calibre_link-904" class="calibre19">

For both module and function plugs, the request interface is the same. <span class="cf">conn</span>, the first argument, is the data we pass through every plug. It has the details for any request, and we morph it in tiny steps until we eventually send a response. All plugs take a <span class="cf">conn</span> and return a <span class="cf">conn</span>.</p>
<p id="calibre_link-905" class="calibre19">You’ll see piped functions using a common data structure over and over in Elixir. The trick that makes this tactic work is having the right common data structure. Since Plug works with web APIs, our data structure will specify the typical details of the web server’s domain.</p>
<p id="calibre_link-906" class="calibre19">
In Phoenix, you’ll see connections, usually abbreviated <span class="cf">conn</span>, literally everywhere. At the end of the day, the <span class="cf">conn</span> is only a <span class="cf">Plug.Conn</span> struct, and it forms the foundation for Plug.</p><h3 class="calibre22">Plug.Conn Fields</h3>
<p id="calibre_link-907" class="calibre19">





You can find great online documentation for <span class="cf">Plug.Conn</span>.<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-203" href="#calibre_link-250">[18]</a></sup> This structure has the various fields that web applications need to understand about web requests and responses. Let’s look at some of the supported fields.</p>
<p id="calibre_link-908" class="calibre19">

Request fields contain information about the inbound request. They’re parsed by the adapter for the web server you’re using. Cowboy is the default web server that Phoenix uses, but you can also choose to plug in your own. These fields contain strings, except where otherwise specified:</p><dl class="calibre42"><dt class="force-newline"></dt><dt class="force-newline"><span class="cf1">host</span></dt><dd class="calibre43">
<p id="calibre_link-909" class="calibre19">The requested host. For example, <span class="cf">www.pragprog.com</span>.</p></dd><dt class="force-newline"></dt><dt class="force-newline"><span class="cf1">method</span></dt><dd class="calibre43">
<p id="calibre_link-910" class="calibre19">The request method. For example, <span class="cf">GET</span> or <span class="cf">POST</span>.</p></dd><dt class="force-newline"></dt><dt class="force-newline"><span class="cf1">path_info</span></dt><dd class="calibre43">
<p id="calibre_link-911" class="calibre19">The path, split into a <span class="cf">List</span> of segments. For example, <span class="cf">["admin", "users"]</span>.</p></dd><dt class="force-newline"></dt><dt class="force-newline"></dt><dt class="force-newline"><span class="cf1">req_headers</span></dt><dd class="calibre43">
<p id="calibre_link-912" class="calibre19">A list of request headers. For example, <span class="cf">[{"content-type", "text/plain"}]</span>.</p></dd><dt class="force-newline"></dt><dt class="force-newline"><span class="cf1">scheme</span></dt><dd class="calibre43">
<p id="calibre_link-913" class="calibre19">The request protocol as an atom. For example, <span class="cf">:https</span>.</p></dd></dl>
<p id="calibre_link-914" class="calibre19">You can get other information as well, such as the query string, the remote IP address, the port, and the like. For Phoenix, if a web request’s information is available from the web server’s adapter, it’s in <span class="cf">Plug.Conn</span>.</p>
<p id="calibre_link-915" class="calibre19">

Next comes a set of <span class="calibre4">fetchable fields</span>. A fetchable field is empty until you explicitly request it. These fields require a little time to process, so they’re left out of the connection by default until you want to explicitly fetch them:</p><dl class="calibre42"><dt class="force-newline"></dt><dt class="force-newline"><span class="cf1">cookies</span></dt><dd class="calibre43">
<p id="calibre_link-916" class="calibre19">These are the request cookies with the response cookies.</p></dd><dt class="force-newline"></dt><dt class="force-newline"></dt><dt class="force-newline"><span class="cf1">params</span></dt><dd class="calibre43">
<p id="calibre_link-917" class="calibre19">These are the request parameters. Some plugs help to parse these parameters from the query string, or from the request body.</p></dd></dl>
<p id="calibre_link-918" class="calibre19">Next are a series of fields that are used to process web requests and keep information about the plug pipeline. Here are some of the fields you’ll encounter:</p><dl class="calibre42"><dt class="force-newline"></dt><dt class="force-newline"><span class="cf1">assigns</span></dt><dd class="calibre43">
<p id="calibre_link-919" class="calibre19">This user-defined map contains anything you want to put in it. For instance, this is where we will keep the authenticated user for the current request.</p></dd><dt class="force-newline"></dt><dt class="force-newline"></dt><dt class="force-newline"></dt><dt class="force-newline"><span class="cf1">halted</span></dt><dd class="calibre43">
<p id="calibre_link-920" class="calibre19">Sometimes a connection must be halted, such as a failed authorization. In this case, the halting plug sets this flag.</p></dd></dl>
<p id="calibre_link-921" class="calibre19">


You can also find a <span class="cf">secret_key_base</span> for everything related to encryption.</p>
<p id="calibre_link-922" class="calibre19">Since the Plug framework handles the whole life cycle of a request, including both the request and the response, <span class="cf">Plug.Conn</span> provides fields for the response:</p><dl class="calibre42"><dt class="force-newline"></dt><dt class="force-newline"></dt><dt class="force-newline"><span class="cf1">resp_body</span></dt><dd class="calibre43">
<p id="calibre_link-923" class="calibre19">Initially an empty string, the response body will contain the HTTP response string when it’s available.</p></dd><dt class="force-newline"></dt><dt class="force-newline"><span class="cf1">resp_cookies</span></dt><dd class="calibre43">
<p id="calibre_link-924" class="calibre19">The <span class="cf">resp_cookies</span> has the outbound cookies for the response.</p></dd><dt class="force-newline"></dt><dt class="force-newline"></dt><dt class="force-newline"><span class="cf1">resp_headers</span></dt><dd class="calibre43">
<p id="calibre_link-925" class="calibre19">These headers follow the HTTP specification and contain information such as the response type and caching rules.</p></dd><dt class="force-newline"></dt><dt class="force-newline"></dt><dt class="force-newline"><span class="cf1">status</span></dt><dd class="calibre43">
<p id="calibre_link-926" class="calibre19">The response code generally contains <span class="cf">200</span>&ndash;<span class="cf">299</span> for success, <span class="cf">300</span>&ndash;<span class="cf">399</span> for redirects, <span class="cf">400</span>&ndash;<span class="cf">499</span> for bad client requests such as not-found, and <span class="cf">500</span>+ for server errors.</p></dd></dl>
<p id="calibre_link-927" class="calibre19">Finally, Plug supports some private fields reserved for the adapter and frameworks:</p><dl class="calibre42"><dt class="force-newline"></dt><dt class="force-newline"><span class="cf1">adapter</span></dt><dd class="calibre43">
<p id="calibre_link-928" class="calibre19">Information about the underlying web server is stored here.</p></dd><dt class="force-newline"></dt><dt class="force-newline"><span class="cf1">private</span></dt><dd class="calibre43">
<p id="calibre_link-929" class="calibre19">This field has a map for the private use of frameworks.</p></dd></dl>
<p id="calibre_link-930" class="calibre19">Initially, a <span class="cf">conn</span> comes in almost blank and is filled out progressively by different plugs in the pipeline. For example, the endpoint may parse parameters, and the application developer will set fields primarily in <span class="cf">assigns</span>. Functions that render set the response fields such as <span class="cf">status</span>, change the <span class="cf">state</span>, and so on.</p>
<p id="calibre_link-931" class="calibre19"><span class="cf">Plug.Conn</span> also defines many functions that directly manipulate those fields, which makes abstracting the work of doing more complex operations such as managing cookies or sending files straightforward.</p>
<p id="calibre_link-932" class="calibre19">Now that you have a little more knowledge, we’re ready to transform the connection by writing our first plug.






</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-280"><div id="calibre_link-933" class="calibre2"><h2 id="calibre_link-99" class="calibre20">Writing an Authentication Plug</h2>
<p id="calibre_link-934" class="calibre19">



The authentication process works in two stages. First, we’ll store the user ID in the session every time a new user registers or a user logs in. Second, we’ll check if there’s a new user in the session and store it in <span class="cf">conn.assigns</span> for every incoming request, so it can be accessed in our controllers and views. Let’s start with the second part because it’s a little easier to follow.</p>
<p id="calibre_link-935" class="calibre19">Create a file called <span class="cf">lib/rumbl_web/controllers/auth.ex</span> that looks like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/authentication/listings/rumbl/lib/rumbl_web/controllers/auth.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">authentication/listings/rumbl/lib/rumbl_web/controllers/auth.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ RumblWeb.Auth ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">import</strong>​ Plug.Conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ init(opts), ​<strong class="kw">do</strong>​: opts</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ call(conn, _opts) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    user_id = get_session(conn, ​<em class="string">:user_id</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    user = user_id &amp;&amp; Rumbl.Accounts.get_user(user_id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    assign(conn, ​<em class="string">:current_user</em>​, user)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-936" class="calibre19">
Don’t let the <span class="cf">init</span> function throw you off. It’s just a simple function to allow compile time options. Plugs allow data to flow through an application at <span class="calibre4">run time</span> through the context. Without <span class="cf">init</span>, our plug can’t accept any <span class="calibre4">compile time</span> options.</p>
<p id="calibre_link-937" class="calibre19">

<span class="cf">call</span> checks if a <span class="cf">:user_id</span> is stored in the session. If one exists, we look it up and assign the result in the connection. <span class="cf">assign</span> is a function imported from <span class="cf">Plug.Conn</span> that slightly transforms the connection&mdash;in this case, storing the user (or <span class="cf">nil</span>) in <span class="cf">conn.assigns</span>. That way, the <span class="cf">:current_user</span> will be available in all downstream functions including controllers and views.</p>
<p id="calibre_link-938" class="calibre19">
Let’s add our plug to the router, at the end of the browser pipeline:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/authentication/listings/rumbl/lib/rumbl_web/router.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">authentication/listings/rumbl/lib/rumbl_web/router.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">pipeline ​<em class="string">:browser</em>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  plug ​<em class="string">:accepts</em>​, [​<em class="string">"</em>​​<em class="string">html"</em>​]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  plug ​<em class="string">:fetch_session</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  plug ​<em class="string">:fetch_flash</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  plug ​<em class="string">:protect_from_forgery</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  plug ​<em class="string">:put_secure_browser_headers</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  plug RumblWeb.Auth</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-939" class="calibre19">With our plug in place, we can begin to use this information downstream.</p><h3 class="calibre22">Restricting Access</h3>
<p id="calibre_link-940" class="calibre19">

The <span class="cf">RumblWeb.Auth</span> plug processes the request information and transforms the <span class="cf">conn</span>, adding <span class="cf">:current_user</span> to <span class="cf">conn.assigns</span>. Now, downstream plugs can use it to find out if a user is logged in.</p>
<p id="calibre_link-941" class="calibre19">

We’ll use this information to restrict access to pages where we list or show user information. Specifically, we don’t want to allow users to access the <span class="cf">:index</span> and <span class="cf">:show</span> actions of <span class="cf">RumblWeb.UserController</span> unless they’re logged in.</p>
<p id="calibre_link-942" class="calibre19">Open up <span class="cf">RumblWeb.UserController</span> and add the following function:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/authentication/listings/rumbl/lib/rumbl_web/controllers/user_controller.change2.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">authentication/listings/rumbl/lib/rumbl_web/controllers/user_controller.change2.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defp</strong>​ authenticate(conn) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">if</strong>​ conn.assigns.current_user ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">else</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; put_flash(​<em class="string">:error</em>​, ​<em class="string">"</em>​​<em class="string">You must be logged in to access that page"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; redirect(​<em class="string">to:</em>​ Routes.page_path(conn, ​<em class="string">:index</em>​))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; halt()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-943" class="calibre19">



If there’s a current user, we return the connection unchanged. Otherwise we store a flash message and redirect back to our application root. We use <span class="cf">halt(conn)</span> to stop any downstream transformations.</p>
<p id="calibre_link-944" class="calibre19">Let’s invoke the <span class="cf">authenticate</span> function from <span class="cf">index</span> to try it out:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/authentication/listings/rumbl/lib/rumbl_web/controllers/user_controller.change2.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">authentication/listings/rumbl/lib/rumbl_web/controllers/user_controller.change2.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ index(conn, _params) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">case</strong>​ authenticate(conn) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    %Plug.Conn{​<em class="string">halted:</em>​ true} = conn -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    conn -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      users = Accounts.list_users()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      render(conn, ​<em class="string">"</em>​​<em class="string">index.html"</em>​, ​<em class="string">users:</em>​ users)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-945" class="calibre19">Now visit <span class="cf">http://localhost:4000/users</span>, where we’re redirected back to the root with a message telling us to log in, as shown in <a href="#calibre_link-281" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">the figure</a>.</p><div id="calibre_link-281" class="praise"><div class="praise"><img id="calibre_link-946" class="border5" src="images/000032.png" alt="images/src/authentication/login_required.png" width="720" height="435" /></div></div>
<p id="calibre_link-947" class="calibre19">We could make the same changes to the <span class="cf">show</span> action, invoking our plug and honoring <span class="cf">halt</span>. And we could do the same thing every time we require authentication. We’d also have code that’s repetitive, ugly, and error prone. We need to <span class="calibre4">plug</span> the <span class="cf">authenticate</span> function for the actions to be protected. Let’s do that.</p>
<p id="calibre_link-948" class="calibre19">



Like endpoints and routers, controllers also have their own plug pipeline. Each plug in the controller pipeline is executed in order, before the action is invoked. The controller pipeline lets us explicitly choose which actions fire any given plug.</p>
<p id="calibre_link-949" class="calibre19">

To plug the <span class="cf">authenticate</span> function, we must first make it a function plug. A function plug is any function that receives two arguments&mdash;the connection and a set of options&mdash;and returns the connection. With a minor tweak, we can satisfy that contract. You need only add an options variable, which you’ll ignore:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/authentication/listings/rumbl/lib/rumbl_web/controllers/user_controller.change3.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">authentication/listings/rumbl/lib/rumbl_web/controllers/user_controller.change3.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defp</strong>​ authenticate(conn, _opts) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">if</strong>​ conn.assigns.current_user ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">else</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; put_flash(​<em class="string">:error</em>​, ​<em class="string">"</em>​​<em class="string">You must be logged in to access that page"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; redirect(​<em class="string">to:</em>​ Routes.page_path(conn, ​<em class="string">:index</em>​))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; halt()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-950" class="calibre19">Now let’s plug it in our controller, right after <span class="cf">alias Rumbl.Accounts.User</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/authentication/listings/rumbl/lib/rumbl_web/controllers/user_controller.change3.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">authentication/listings/rumbl/lib/rumbl_web/controllers/user_controller.change3.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">plug ​<em class="string">:authenticate</em>​ ​<strong class="kw">when</strong>​ action ​<strong class="kw">in</strong>​ [​<em class="string">:index</em>​, ​<em class="string">:show</em>​]</td></tr></table>
<p id="calibre_link-951" class="calibre19">Then, change the <span class="cf">index</span> action back to its previous state, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/authentication/listings/rumbl/lib/rumbl_web/controllers/user_controller.change3.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">authentication/listings/rumbl/lib/rumbl_web/controllers/user_controller.change3.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ index(conn, _params) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  users = Accounts.list_users()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  render(conn, ​<em class="string">"</em>​​<em class="string">index.html"</em>​, ​<em class="string">users:</em>​ users)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-952" class="calibre19">Visit <span class="cf">http://localhost:4000/users</span> to see our plug in action. We redirect, exactly as we should.</p>
<p id="calibre_link-953" class="calibre19">Let’s take a minute to appreciate the code we’ve written so far. A small change to our authentication lets us plug it before every action. We can also share it with any other controllers or even move it to a router pipeline, restricting whole sections of our application with minor changes. None of these features relies on magical inheritance mechanisms, only our explicit lists of functions in our plug pipelines.



</p>
<p id="calibre_link-954" class="calibre19">



At this point, you may also be wondering what happened with <span class="cf">halt</span>. When we changed the <span class="cf">index</span> action, we had to explicitly check if the connection halted or not, before acting on it. Plug pipelines explicitly check for <span class="cf">halted: true</span> between every plug invocation, so the halting concern is neatly solved by Plug.</p>
<p id="calibre_link-955" class="calibre19">
In fact, you’re seeing Elixir macro expansion in action. Let’s take an arbitrary example. Suppose you write code like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">plug ​<em class="string">:one</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">plug Two</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">plug ​<em class="string">:three</em>​, ​<em class="string">some:</em>​ ​<em class="string">:option</em>​</td></tr></table>
<p id="calibre_link-956" class="calibre19">It would compile to:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">case</strong>​ one(conn, []) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  %Plug.Conn{​<em class="string">halted:</em>​ true} = conn -&gt; conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  conn -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">case</strong>​ Two.call(conn, Two.init([])) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      %Plug.Conn{​<em class="string">halted:</em>​ true} = conn -&gt; conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      conn -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">        ​<strong class="kw">case</strong>​ three(conn, ​<em class="string">some:</em>​ ​<em class="string">:option</em>​) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">          %Plug.Conn{​<em class="string">halted:</em>​ true} = conn -&gt; conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">          conn -&gt; conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">        ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-957" class="calibre19">Elixir macros and macro expansion are beyond the scope of this book. What you need to know is that at some point in the compile process, Elixir would translate the first example to the second. Conceptually, not much is happening here, and that’s exactly the beauty behind Plug. For each plug, we invoke it with the given options, check if the returned connection halted, and move forward if it didn’t. It’s a simple abstraction that allows us to express and compose both simple and complex functionality.</p>
<p id="calibre_link-958" class="calibre19">With all that said, we already have a mechanism for loading data from the session and using it to restrict user access. But we still don’t have a mechanism to log the users in.</p><h3 class="calibre22">Logging In</h3>
<p id="calibre_link-959" class="calibre19">






Let’s add a tiny function to <span class="cf">RumblWeb.Auth</span> that receives the connection and the user, and stores the user ID in the session:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/authentication/listings/rumbl/lib/rumbl_web/controllers/auth.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">authentication/listings/rumbl/lib/rumbl_web/controllers/auth.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ login(conn, user) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; assign(​<em class="string">:current_user</em>​, user)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; put_session(​<em class="string">:user_id</em>​, user.id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; configure_session(​<em class="string">renew:</em>​ true)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-960" class="calibre19">





As you recall, the <span class="cf">Plug.Conn</span> struct has a field called <span class="cf">assigns</span>. We call setting a value in that structure an <span class="calibre4">assign</span>. Our function stores the given user as the <span class="cf">:current_user</span> assign, puts the user ID in the session, and finally configures the session, setting the <span class="cf">:renew</span> option to <span class="cf">true</span>. The last step is extremely important and it protects us from session fixation attacks. It tells Plug to send the session cookie back to the client with a different identifier, in case an attacker knew, by any chance, the previous one.</p>
<p id="calibre_link-961" class="calibre19">Let’s go back to the <span class="cf">RumblWeb.UserController.create</span> action and change it to call the <span class="cf">login</span> function after we insert the user in the database:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/authentication/listings/rumbl/lib/rumbl_web/controllers/user_controller.change2.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">authentication/listings/rumbl/lib/rumbl_web/controllers/user_controller.change2.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ create(conn, %{​<em class="string">"</em>​​<em class="string">user"</em>​ =&gt; user_params}) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">case</strong>​ Accounts.register_user(user_params) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, user} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      |&gt; RumblWeb.Auth.login(user)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      |&gt; put_flash(​<em class="string">:info</em>​, ​<em class="string">"</em>​​<em class="string">#{</em>​user.name​<em class="string">}</em>​​<em class="string"> created!"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      |&gt; redirect(​<em class="string">to:</em>​ Routes.user_path(conn, ​<em class="string">:index</em>​))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:error</em>​, %Ecto.Changeset{} = changeset} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      render(conn, ​<em class="string">"</em>​​<em class="string">new.html"</em>​, ​<em class="string">changeset:</em>​ changeset)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-962" class="calibre19">Now visit <span class="cf">http://localhost:4000/users/new</span>, register a new user, and try to access the pages we restricted previously. As you can see, the user can finally access them.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-3"><div id="calibre_link-963" class="calibre2"><h2 id="calibre_link-100" class="calibre20">Implementing Login and Logout</h2>
<p id="calibre_link-964" class="calibre19">

We made great progress in the last section. We created a module plug that loads information from the session, used this information to restrict user access, and finally stored users in the session.</p>
<p id="calibre_link-965" class="calibre19">We’re almost done with our authentication feature. We need to implement both login and logout functionality, as well as change the layout to include links to those pages.</p>
<p id="calibre_link-966" class="calibre19">First things first. Before changing our controllers and views, let’s expose a function that authenticates a given username and password. We will look up a user by username in the database and securely ensure that the user’s password matches the one in the database. The <span class="cf">Accounts</span> context is a perfect place to define this function. Open up <span class="cf">rumbl/accounts.ex</span> and add the new function <span class="cf">authenticate_by_username_and_pass, like this</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/authentication/listings/rumbl/lib/rumbl/accounts.change2.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">authentication/listings/rumbl/lib/rumbl/accounts.change2.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ authenticate_by_username_and_pass(username, given_pass) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  user = get_user_by(​<em class="string">username:</em>​ username)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">cond</strong>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    user &amp;&amp; Pbkdf2.verify_pass(given_pass, user.password_hash) -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      {​<em class="string">:ok</em>​, user}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    user -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      {​<em class="string">:error</em>​, ​<em class="string">:unauthorized</em>​}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    true -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      Pbkdf2.no_user_verify()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      {​<em class="string">:error</em>​, ​<em class="string">:not_found</em>​}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-967" class="calibre19">





We use the existing <span class="cf">get_user_by</span> function to look up a <span class="cf">User</span> by <span class="cf">username</span>. If the user isn’t found, we use <span class="cf">comeonin</span>’s <span class="cf">no_user_verify()</span> function to simulate a password check with variable timing. This hardens our authentication layer against timing attacks,<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-204" href="#calibre_link-4">[19]</a></sup> which is crucial to keeping our application secure. If we find our user and the password matches, we return the user wrapped in an <span class="cf">:ok</span> tuple, otherwise we return <span class="cf">{:error, :unauthorized}</span> for a bad password, or <span class="cf">{:error, :not_found}</span> if the user does not exist for the given username.</p>
<p id="calibre_link-968" class="calibre19">Now we are ready to work on our login and logout pages. Let’s add some new routes to <span class="cf">lib/rumbl_web/router.ex</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/authentication/listings/rumbl/lib/rumbl_web/router.change2.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">authentication/listings/rumbl/lib/rumbl_web/router.change2.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">scope ​<em class="string">"</em>​​<em class="string">/"</em>​, RumblWeb ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  pipe_through ​<em class="string">:browser</em>​ ​<em class="comment"># Use the default browser stack</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  get ​<em class="string">"</em>​​<em class="string">/"</em>​, PageController, ​<em class="string">:index</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  resources ​<em class="string">"</em>​​<em class="string">/users"</em>​, UserController, ​<em class="string">only:</em>​ [​<em class="string">:index</em>​, ​<em class="string">:show</em>​, ​<em class="string">:new</em>​, ​<em class="string">:create</em>​]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  resources ​<em class="string">"</em>​​<em class="string">/sessions"</em>​, SessionController, ​<em class="string">only:</em>​ [​<em class="string">:new</em>​, ​<em class="string">:create</em>​, ​<em class="string">:delete</em>​]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-969" class="calibre19">







We add three of the prepackaged REST routes for <span class="cf">/sessions</span>. We use the REST routes for <span class="cf">GET /sessions/new</span> to show a new session login form, <span class="cf">POST /sessions</span> to log in, and <span class="cf">DELETE /sessions/:id</span> to log out.</p>
<p id="calibre_link-970" class="calibre19">Next, we need a <span class="cf">SessionController</span> to handle those actions. Create a <span class="cf">lib/rumbl_web/controllers/session_controller.ex</span>, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/authentication/listings/rumbl/lib/rumbl_web/controllers/session_controller.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">authentication/listings/rumbl/lib/rumbl_web/controllers/session_controller.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ RumblWeb.SessionController ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ RumblWeb, ​<em class="string">:controller</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ new(conn, _) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    render(conn, ​<em class="string">"</em>​​<em class="string">new.html"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-971" class="calibre19">
The <span class="cf">new</span> action simply renders our login form. We need a second action, <span class="cf">create</span>, to handle the form submission, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/authentication/listings/rumbl/lib/rumbl_web/controllers/session_controller.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">authentication/listings/rumbl/lib/rumbl_web/controllers/session_controller.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ create(</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  conn,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  %{​<em class="string">"</em>​​<em class="string">session"</em>​ =&gt; %{​<em class="string">"</em>​​<em class="string">username"</em>​ =&gt; username, ​<em class="string">"</em>​​<em class="string">password"</em>​ =&gt; pass}}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">case</strong>​ Rumbl.Accounts.authenticate_by_username_and_pass(username, pass) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, user} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      |&gt; RumblWeb.Auth.login(user)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      |&gt; put_flash(​<em class="string">:info</em>​, ​<em class="string">"</em>​​<em class="string">Welcome back!"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      |&gt; redirect(​<em class="string">to:</em>​ Routes.page_path(conn, ​<em class="string">:index</em>​))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:error</em>​, _reason} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      |&gt; put_flash(​<em class="string">:error</em>​, ​<em class="string">"</em>​​<em class="string">Invalid username/password combination"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      |&gt; render(​<em class="string">"</em>​​<em class="string">new.html"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-972" class="calibre19">



That <span class="cf">create</span> action picks off the inbound arguments for <span class="cf">username</span> as <span class="cf">username</span>, and for <span class="cf">password</span> as <span class="cf">pass</span>. Then, we call <span class="cf">authenticate_by_username_and_pass</span>. On success, we report a success flash message to the user and redirect to <span class="cf">Routes.page_path</span>. Otherwise, we report a failure message to our user and render <span class="cf">new</span> again.</p>
<p id="calibre_link-973" class="calibre19">Here we can appreciate the benefits of contexts once again. Instead of the controller dealing with all of the complexity, our context handles three return types: <span class="cf">{:ok, user}</span>, <span class="cf">{:error, :not_found}</span>, and <span class="cf">{:error, :unauthorized}</span>. The controller does not care about the details of how authentication works. The controller’s job is to translate whatever our business logic returns into something meaningful for the user, which is quite trivial to do with pattern matching.</p>
<p id="calibre_link-974" class="calibre19">In particular, we choose to match only on <span class="cf">{:error, _}</span> to ignore the <span class="cf">:unauthorized</span> and <span class="cf">:not_found</span> reason codes, returning only a vague “Invalid username/password combination” message. We could have returned something like “Invalid password for username” or “Username not found”, but this approach might raise privacy issues as anyone would be able to find whether an email is registered on the website.</p>
<p id="calibre_link-975" class="calibre19">

We still need to create our view and template. Create a new <span class="cf">lib/rumbl_web/views/session_view.ex</span> file that looks like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/authentication/listings/rumbl/lib/rumbl_web/views/session_view.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">authentication/listings/rumbl/lib/rumbl_web/views/session_view.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ RumblWeb.SessionView ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ RumblWeb, ​<em class="string">:view</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-976" class="calibre19">

Next, we need a <span class="cf">session</span> directory for our new view, so create a <span class="cf">lib/rumbl_web/templates/session/new.html.eex</span> with our new login form, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/authentication/listings/rumbl/lib/rumbl_web/templates/session/new.html.eex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">authentication/listings/rumbl/lib/rumbl_web/templates/session/new.html.eex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;h1&gt;Login&lt;/h1&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment">&lt;%=</em>​ form_for @conn,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">             Routes.session_path(@conn, ​<em class="string">:create</em>​),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">             [​<em class="string">as:</em>​ ​<em class="string">:session</em>​],</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">             ​<strong class="kw">fn</strong>​ f -&gt; ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;div&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="comment">&lt;%=</em>​ text_input f, ​<em class="string">:username</em>​, ​<em class="string">placeholder:</em>​ ​<em class="string">"</em>​​<em class="string">Username"</em>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;/div&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;div&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="comment">&lt;%=</em>​ password_input f, ​<em class="string">:password</em>​, ​<em class="string">placeholder:</em>​ ​<em class="string">"</em>​​<em class="string">Password"</em>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;/div&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="comment">&lt;%=</em>​ submit ​<em class="string">"</em>​​<em class="string">Log in"</em>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment">&lt;%</em>​ ​<strong class="kw">end</strong>​ ​<em class="comment">%&gt;</em>​</td></tr></table>
<p id="calibre_link-977" class="calibre19">






We use <span class="cf">form_for</span> as in our new-user forms, but instead of passing a changeset, we pass the <span class="cf">%Plug.Conn{}</span> struct. <span class="cf">Plug.conn</span> structs are useful when you’re creating forms that aren’t backed by a changeset, such as a login or search form. To try out the new page, we have to logout, but we haven’t written that functionality yet. As a temporary workaround, instead of logging out you can clear your browser cookies or start a new session in incognito mode, then visit <span class="cf">/sessions/new</span> to try some login attempts.</p>
<p id="calibre_link-978" class="calibre19">With a bad login, we see an error flash notice and our template rerendered as shown in the <a href="#calibre_link-5" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">figure</a>.</p><div id="calibre_link-5" class="praise"><div class="praise"><img id="calibre_link-979" class="border5" src="images/000017.png" alt="images/src/authentication/bad_login.png" width="720" height="479" /></div></div>
<p id="calibre_link-980" class="calibre19">Now let’s try a good login:</p><div class="praise"><div class="praise"><img id="calibre_link-981" class="border5" src="images/000015.png" alt="images/src/authentication/good_login.png" width="720" height="261" /></div></div>
<p id="calibre_link-982" class="calibre19">It works!</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-43"><div id="calibre_link-983" class="calibre2"><h2 id="calibre_link-101" class="calibre20">Presenting User Account Links</h2>
<p id="calibre_link-984" class="calibre19">




We’ve come a long way. We can now authenticate a user in a secure way. We’re using a single function that we can reliably share across each feature of the application that needs it. Now, we can turn our attention to showing customized headers in our layout based on a user’s authentication status. Let’s start with a welcome message and a logout link.</p>
<p id="calibre_link-985" class="calibre19">We want to change the layout of the application to handle the new user features so that other views can also take advantage of these features. Let’s update the layout in <span class="cf">lib/rumbl_web/templates/layout/app.html.eex</span>. Replace your <span class="cf">&lt;nav&gt;</span> section to look like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/authentication/listings/rumbl/lib/rumbl_web/templates/layout/app.change1.html.eex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">authentication/listings/rumbl/lib/rumbl_web/templates/layout/app.change1.html.eex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;section class=​<em class="string">"container"</em>​&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;nav role=​<em class="string">"navigation"</em>​&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    &lt;ul&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<em class="comment">&lt;%=</em>​ ​<strong class="kw">if</strong>​ @current_user ​<strong class="kw">do</strong>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">        &lt;li&gt;​<em class="comment">&lt;%=</em>​ @current_user.username ​<em class="comment">%&gt;</em>​&lt;/li&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">        &lt;li&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">          ​<em class="comment">&lt;%=</em>​ link ​<em class="string">"</em>​​<em class="string">Log out"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">                ​<em class="string">to:</em>​ Routes.session_path(@conn, ​<em class="string">:delete</em>​, @current_user),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">                ​<em class="string">method:</em>​ ​<em class="string">"</em>​​<em class="string">delete"</em>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">        &lt;/li&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<em class="comment">&lt;%</em>​ ​<strong class="kw">else</strong>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">        &lt;li&gt;​<em class="comment">&lt;%=</em>​ link ​<em class="string">"</em>​​<em class="string">Register"</em>​, ​<em class="string">to:</em>​ Routes.user_path(@conn, ​<em class="string">:new</em>​) ​<em class="comment">%&gt;</em>​&lt;/li&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">        &lt;li&gt;​<em class="comment">&lt;%=</em>​ link ​<em class="string">"</em>​​<em class="string">Log in"</em>​, ​<em class="string">to:</em>​ Routes.session_path(@conn, ​<em class="string">:new</em>​) ​<em class="comment">%&gt;</em>​&lt;/li&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<em class="comment">&lt;%</em>​ ​<strong class="kw">end</strong>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    &lt;/ul&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;/nav&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;a href=​<em class="string">"http://phoenixframework.org/"</em>​ class=​<em class="string">"phx-logo"</em>​&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    &lt;img src=​<em class="string">"</em>​​<em class="comment">&lt;%=</em>​ Routes.static_url(@conn, ​<em class="string">"</em>​​<em class="string">/images/phoenix.png"</em>​) ​<em class="comment">%&gt;</em>​​<em class="string">"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">        alt=​<em class="string">"Phoenix Framework Logo"</em>​/&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;/a&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;/section&gt;</td></tr></table>
<p id="calibre_link-986" class="calibre19">You can see our strategy. We test whether the user is authenticated by checking if the <span class="cf">@current_user</span> is present. Because <span class="cf">RumblWeb.Auth.login</span> stored the user under <span class="cf">conn.assigns.current_user</span>, it’s automatically available as <span class="cf">@current_user</span> in our views. To put it more broadly, everything in <span class="cf">conn.assigns</span> is available in our views.</p>
<p id="calibre_link-987" class="calibre19">
If the user is available, we show the username, followed by a logout link. Otherwise, we allow users to register themselves or log in. If you’re watching closely, you can see that this template uses the <span class="cf">Routes.session_path</span> twice when building the login and logout links. Each link function uses it a little differently, as you’ll see when we break it down.</p>
<p id="calibre_link-988" class="calibre19">The code uses the Phoenix helpers to build a link:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">link ​<em class="string">"</em>​​<em class="string">Log out"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="string">to:</em>​ Routes.session_path(@conn, ​<em class="string">:delete</em>​, @current_user),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="string">method:</em>​ ​<em class="string">"</em>​​<em class="string">delete"</em>​</td></tr></table>
<p id="calibre_link-989" class="calibre19">


The link:</p><ul class="calibre28"><li class="calibre29">
<p id="calibre_link-990" class="calibre31">Has the text <span class="cf1">Log out</span></p></li><li class="calibre29">
<p id="calibre_link-991" class="calibre31">Links to the <span class="cf1">Routes.session_path</span> path with the <span class="cf1">@conn</span> connection, the <span class="cf1">:delete</span> action, and the <span class="cf1">@current_user</span> argument</p></li><li class="calibre29">
<p id="calibre_link-992" class="calibre31">Uses the HTTP <span class="cf1">delete</span> method</p></li></ul>
<p id="calibre_link-993" class="calibre19">



By passing the <span class="cf">:method</span> option to <span class="cf">link</span>, Phoenix generates a form tag instead of an anchor tag. Links without a specified HTTP method will default to <span class="cf">GET</span>, and Phoenix will render a simple link.</p>
<p id="calibre_link-994" class="calibre19">Let’s head back to our browser and try it out. When we visit <span class="cf">http://localhost:4000</span>, we see the Log in link in the header:</p><div class="praise"><img id="calibre_link-995" class="border6" src="images/000014.png" alt="images/src/authentication/logged_out_header.png" width="702" height="453" /></div>
<p id="calibre_link-996" class="calibre19">Now sign in with one of the accounts you created earlier:</p><div class="praise"><img id="calibre_link-997" class="border6" src="images/000044.png" alt="images/src/authentication/logged_in_header.png" width="702" height="329" /></div>
<p id="calibre_link-998" class="calibre19">And it works.</p>
<p id="calibre_link-999" class="calibre19">Now that we have a working dynamic header with a “Log out” link, we need to implement the delete action in our <span class="cf">SessionController</span> and handle clearing the user’s session in our auth module. That’s nearly trivial to do.</p>
<p id="calibre_link-1000" class="calibre19">


First let’s do the work to delete the session in <span class="cf">RumblWeb.Auth</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/authentication/listings/rumbl/lib/rumbl_web/controllers/auth.change2.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">authentication/listings/rumbl/lib/rumbl_web/controllers/auth.change2.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ logout(conn) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  configure_session(conn, ​<em class="string">drop:</em>​ true)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1001" class="calibre19">


This time we are invoking <span class="cf">configure_session</span> and setting <span class="cf">:drop</span> to <span class="cf">true</span>, which will drop the whole session at the end of the request. If you want to keep the session around, you could also delete only the user ID information by calling <span class="cf">delete_session(conn, :user_id)</span>.</p>
<p id="calibre_link-1002" class="calibre19">

Now, we need only add the controller action. In <span class="cf">lib/rumbl_web/controllers/session_controller.ex</span>, add the <span class="cf">delete</span> action, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/authentication/listings/rumbl/lib/rumbl_web/controllers/session_controller.change2.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">authentication/listings/rumbl/lib/rumbl_web/controllers/session_controller.change2.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ delete(conn, _) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; RumblWeb.Auth.logout()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; redirect(​<em class="string">to:</em>​ Routes.page_path(conn, ​<em class="string">:index</em>​))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1003" class="calibre19">Following the link in our layout will now clear out the session and redirect us to the root.













</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-200"><div id="calibre_link-1004" class="calibre2"><h2 id="calibre_link-102" class="calibre20">Wrapping Up</h2>
<p id="calibre_link-1005" class="calibre19">This chapter has been challenging, but we have come a long way. Let’s take stock:</p><ul class="calibre28"><li class="calibre29">
<p id="calibre_link-1006" class="calibre31">We used our existing <span class="cf1">Accounts</span> context to look up session users.</p></li><li class="calibre29">
<p id="calibre_link-1007" class="calibre31">We added the <span class="cf1">pbkdf2_elixir</span> dependency to our project for password hashing.</p></li><li class="calibre29">
<p id="calibre_link-1008" class="calibre31">We built our own authentication layer.</p></li><li class="calibre29">
<p id="calibre_link-1009" class="calibre31">We built the associated changesets to handle validation of passwords.</p></li><li class="calibre29">
<p id="calibre_link-1010" class="calibre31">We implemented a module plug that loads the user from the session and made it part of our browser pipeline.</p></li><li class="calibre29">
<p id="calibre_link-1011" class="calibre31">We implemented a function plug and used it alongside some specific actions in our controller pipeline.</p></li></ul>
<p id="calibre_link-1012" class="calibre19">In the next chapter, you’ll dive deeper into Ecto’s waters by exploring relationships. We’ll also begin to flesh out our application, using code generators to speed us along.

</p>

<div class="footnotes">
<h4 class="calibre24">Footnotes</h4>
<dl class="calibre25">
<dt class="footnote-number"><a id="calibre_link-15" href="#calibre_link-201" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[16]</a></dt><dd class="calibre26">
<p id="calibre_link-1013" class="calibre27"><a href="https://github.com/riverrun/comeonin" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://github.com/riverrun/comeonin</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-170" href="#calibre_link-202" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[17]</a></dt><dd class="calibre26">
<p id="calibre_link-1014" class="calibre27"><a href="https://github.com/OWASP/CheatSheetSeries" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://github.com/OWASP/CheatSheetSeries</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-250" href="#calibre_link-203" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[18]</a></dt><dd class="calibre26">
<p id="calibre_link-1015" class="calibre27"><a href="http://hexdocs.pm/plug/Plug.Conn.html" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">http://hexdocs.pm/plug/Plug.Conn.html</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-4" href="#calibre_link-204" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[19]</a></dt><dd class="calibre26">
<p id="calibre_link-1016" class="calibre27"><a href="https://en.wikipedia.org/wiki/Timing_attack" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://en.wikipedia.org/wiki/Timing_attack</a></p></dd></dl></div>
<div class="copyright">Copyright © 2020, The Pragmatic Bookshelf.</div>




</div>



  </div>


<div class="calibre1" id="calibre_link-240"><div id="calibre_link-1017" class="calibre2"><h1 class="pcalibre6 chapter-title" id="calibre_link-103"><span class="chapter-number">
            Chapter
            6</span><br class="calibre18" /><span class="chapter-name">Generators and Relationships</span></h1>

<p id="calibre_link-1018" class="calibre19">So far, our Ecto tour has been pretty basic. We’ve read and written repository data, but we still haven’t connected any schemas together. Relational databases like PostgreSQL are named that way for a reason. Dealing with related data is the defining characteristic of that whole family of databases, so management of relationships is the feature that makes or breaks any persistence layer. This chapter takes you on a deeper dive into Ecto by exploring how to tie our schemas together in the database.</p>
<p id="calibre_link-1019" class="calibre19">Throughout this process, we’ll make some design decisions. Our contexts will continue to be the overarching API that our controllers will access. Sometimes those contexts will tie together united concepts. Other times we’ll use contexts to segregate the different concerns of our application.</p>
<p id="calibre_link-1020" class="calibre19">Along the way, we’ll use code generators to accelerate the process where it’s possible, and you’ll walk through what each of these generators does for us. When you’re through, you’ll know how to take greater advantage of some of the code generators in Phoenix, and you’ll have a better understanding of how to layer together individual Ecto schemas with relationships, and group together related concepts in contexts.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-270"><div id="calibre_link-1021" class="calibre2"><h2 id="calibre_link-104" class="calibre20">Using Generators</h2>
<p id="calibre_link-1022" class="calibre19">




To dig into Ecto, we’re going to have to define relationships, and for that we need to extend the domain of our application. That’s great, because our application is going to need those features. Let’s define our problem in a little more detail.</p><h3 class="calibre22">Adding Videos and Annotations</h3>
<p id="calibre_link-1023" class="calibre19">


The <span class="cf">rumbl</span> application will let users choose a video. Then, they can attach their comments, in real time. Users can play back these videos with comments over time. See what it looks like in the <a href="#calibre_link-271" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">figure</a>.</p><div class="praise"><img id="calibre_link-271" class="calibre44" src="images/000049.png" alt="images/src/relationships/annotation-relationships.png" width="360" height="182" /></div>
<p id="calibre_link-1024" class="calibre19">Users create videos. Then, users can create annotations on those videos. If you’ve ever seen <span class="calibre4">Mystery Science Theater 3000</span>, you know exactly what we’re going for. In that show, some robots sat on the bottom of the screen, throwing in their opinions about bad science fiction.</p>
<p id="calibre_link-1025" class="calibre19">Here’s how it’s going to work. Rather than building everything by hand as we did with the <span class="cf">Accounts</span> context and its <span class="cf">User</span> schema, we’re going to use generators to build the skeleton&mdash;including the migration, context, controllers, and templates to bootstrap the process for us. It’s going to happen fast, and we’re going to move through the boilerplate quickly, so be sure to follow closely.</p><h3 class="calibre22">Generating Web Interfaces</h3>
<p id="calibre_link-1026" class="calibre19">






Phoenix includes two Mix tasks to bootstrap web interfaces. <span class="cf">phx.gen.html</span> creates a simple HTTP scaffold with HTML pages, and <span class="cf">phx.gen.json</span> does the same for a REST-based API using JSON. They give you a simple scaffold for a traditional web-based application with CRUD (create, read, update, and delete) operations. You get migrations, a basic context, controllers, and templates for simple CRUD operations of a resource, as well as tests so you can hit the ground running. You won’t write all your Phoenix code this way, but the generators are a great way to get up and running quickly. They can also help new users learn how the Phoenix layers fit together in the context of a working application.</p>
<p id="calibre_link-1027" class="calibre19">

Our application allows users to annotate videos in real time. We know up-front that we’ll need a video resource, but we need to figure out where it will live within our application. When you’re organizing code, think contexts first. Rumbl enables users to interact around videos in real time, and we can imagine a future expansion to real-time conversations around all types of multimedia-&ndash;-images, books, etc.&mdash;so a <span class="cf">Multimedia</span> context will give us a nice place to group this functionality.</p>
<p id="calibre_link-1028" class="calibre19">

Now that we know where videos will live, we’ll start with a few fields, including:</p><ul class="calibre28"><li class="calibre29">An associated <span class="cf1">User</span></li><li class="calibre29">A creation time for the video</li><li class="calibre29">A URL of the video location</li><li class="calibre29">A title</li><li class="calibre29">The type of the video</li></ul>
<p id="calibre_link-1029" class="calibre19">Later, our application will let users decorate these videos with annotations. But first, we need users to be able to create and show their videos. Let’s use the <span class="cf">phx.gen.html</span> Mix task to generate our resource, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">phx.gen.html</strong>​​<strong class="kw"> </strong>​​<strong class="kw">Multimedia</strong>​​<strong class="kw"> </strong>​​<strong class="kw">Video</strong>​​<strong class="kw"> </strong>​​<strong class="kw">videos</strong>​​<strong class="kw"> </strong>​​<strong class="kw">user_id:references:users</strong>​​<strong class="kw"> </strong>​​<strong class="kw">\</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">url:string</strong>​​<strong class="kw"> </strong>​​<strong class="kw">title:string</strong>​​<strong class="kw"> </strong>​​<strong class="kw">description:text</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating lib/rumbl_web/controllers/video_controller.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating lib/rumbl_web/templates/video/edit.html.eex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating lib/rumbl_web/templates/video/form.html.eex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating lib/rumbl_web/templates/video/index.html.eex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating lib/rumbl_web/templates/video/new.html.eex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating lib/rumbl_web/templates/video/show.html.eex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating lib/rumbl_web/views/video_view.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating test/rumbl_web/controllers/video_controller_test.exs</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating lib/rumbl/multimedia/video.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating priv/repo/migrations/20180408024739_create_videos.exs</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating lib/rumbl/multimedia.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* injecting lib/rumbl/multimedia.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating test/rumbl/multimedia_test.exs</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* injecting test/rumbl/multimedia_test.exs</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Add the resource to your browser scope in lib/rumbl_web/router.ex:</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    resources "/videos", VideoController</td></tr></table>
<p id="calibre_link-1030" class="calibre19">All of the preceding files should look familiar, because you wrote a similar stack of code for the user accounts layer by hand. Let’s break that command down. Following the <span class="cf">mix phx.gen.html</span> command, we have:</p><ul class="calibre28"><li class="calibre29">The name of the context: <span class="cf1">Multimedia</span></li><li class="calibre29">The name of the module that defines the schema: <span class="cf1">Video</span></li><li class="calibre29">The plural form of the schema name: <span class="cf1">videos</span></li><li class="calibre29">Each field, with some type information</li></ul>
<p id="calibre_link-1031" class="calibre19">This <span class="cf">mix</span> command may be more verbose than you’ve seen elsewhere. In some frameworks, you might use simple one-time generator commands, which leave it up to the framework to inflect plural and singular forms as requests come and go. It ends up adding complexity to the framework, and indirectly, to your application. At the end of the day, you save only a few keystrokes every once in a while. <span class="calibre4">Such generators optimize the wrong thing.</span></p>
<p id="calibre_link-1032" class="calibre19">

Sometimes it pays to be explicit. For all things internal, Phoenix frees you from memorizing unnecessary singular and plural conventions by consistently using singular forms in schemas, controllers, and views in most cases. In your application boundaries, such as URLs and table names, you provide a bit more information, because you can use pluralized names. Since creating plural forms is imperfect and rife with exceptions, the generator command is the perfect place to tell Phoenix <span class="calibre4">exactly what we need</span>.</p>
<p id="calibre_link-1033" class="calibre19">

It’s time to follow up on the remaining instructions printed by the generator. First, we need to add the route to <span class="cf">lib/rumbl_web/router.ex</span>:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">resources ​<em class="string">"</em>​​<em class="string">/videos"</em>​, VideoController</td></tr></table>
<p id="calibre_link-1034" class="calibre19">
The question is: in which pipeline? Let’s review what we know and come back to that question shortly.</p>
<p id="calibre_link-1035" class="calibre19">

Our <span class="cf">Multimedia.Video</span> is a REST resource, and these routes work just like the ones we created for <span class="cf">Accounts.User</span>. As with the <span class="cf">index</span> and <span class="cf">show</span> actions in <span class="cf">UserController</span>, we also want to restrict the video actions to logged-in users. We’ve already written the code for authentication in the user controller. Let’s recap that now:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/authentication/listings/rumbl/lib/rumbl_web/controllers/user_controller.change3.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">authentication/listings/rumbl/lib/rumbl_web/controllers/user_controller.change3.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defp</strong>​ authenticate(conn, _opts) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">if</strong>​ conn.assigns.current_user ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">else</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; put_flash(​<em class="string">:error</em>​, ​<em class="string">"</em>​​<em class="string">You must be logged in to access that page"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; redirect(​<em class="string">to:</em>​ Routes.page_path(conn, ​<em class="string">:index</em>​))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; halt()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1036" class="calibre19">







To share this function between routers and controllers, move it to <span class="cf">RumblWeb.Auth</span>, call it <span class="cf">authenticate_user</span> for clarity, make it public (use <span class="cf">def</span> instead of <span class="cf">defp</span>), import our controller functions for <span class="cf">put_flash</span> and <span class="cf">redirect</span>, and alias our router helpers:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/relationships/listings/rumbl/lib/rumbl_web/controllers/auth.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">relationships/listings/rumbl/lib/rumbl_web/controllers/auth.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">import</strong>​ Phoenix.Controller</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">alias RumblWeb.Router.Helpers, ​<em class="string">as:</em>​ Routes</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ authenticate_user(conn, _opts) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">if</strong>​ conn.assigns.current_user ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">else</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; put_flash(​<em class="string">:error</em>​, ​<em class="string">"</em>​​<em class="string">You must be logged in to access that page"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; redirect(​<em class="string">to:</em>​ Routes.page_path(conn, ​<em class="string">:index</em>​))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; halt()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1037" class="calibre19">You might be tempted to import <span class="cf">RumblWeb.Router.Helpers</span> instead of defining an alias, but hold off on that impulse. The router depends on <span class="cf">Rumbl.Auth</span> so importing the router helpers in <span class="cf">Rumbl.Auth</span> would lead to a circular dependency and compilation would fail.</p>
<p id="calibre_link-1038" class="calibre19">Save the <span class="cf">auth.ex</span> file. Since that module provides services our entire application will use, we’ll want to make it easier to integrate. An import should do the trick. First, let’s share <span class="cf">authenticate_user</span> function across all controllers and routers. We will write <span class="cf">import RumblWeb.Auth, only: [authenticate_user: 2]</span>, where the number <span class="cf">2</span> is the number of arguments expected by <span class="cf">authenticate_user</span>. Crack open <span class="cf">lib/rumbl_web.ex</span> and make this change to your controller function:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/relationships/listings/rumbl/lib/rumbl_web.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">relationships/listings/rumbl/lib/rumbl_web.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ controller ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">quote</strong>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">use</strong>​ Phoenix.Controller, ​<em class="string">namespace:</em>​ RumblWeb</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">import</strong>​ Plug.Conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">import</strong>​ RumblWeb.Gettext</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">import</strong>​ RumblWeb.Auth, ​<em class="string">only:</em>​ [​<em class="string">authenticate_user:</em>​ 2] ​<em class="comment"># New import</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    alias RumblWeb.Router.Helpers, ​<em class="string">as:</em>​ Routes</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1039" class="calibre19">In the same file, make a similar change to your router function:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/relationships/listings/rumbl/lib/rumbl_web.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">relationships/listings/rumbl/lib/rumbl_web.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ router ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">quote</strong>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">use</strong>​ Phoenix.Router</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">import</strong>​ Plug.Conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">import</strong>​ Phoenix.Controller</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">import</strong>​ RumblWeb.Auth, ​<em class="string">only:</em>​ [​<em class="string">authenticate_user:</em>​ 2] ​<em class="comment"># New import</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1040" class="calibre19">Next, in <span class="cf">UserController</span>, we want to use the newly imported function. Rename <span class="cf">authenticate</span> to <span class="cf">authenticate_user</span>, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/relationships/listings/rumbl/lib/rumbl_web/controllers/user_controller.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">relationships/listings/rumbl/lib/rumbl_web/controllers/user_controller.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">plug ​<em class="string">:authenticate_user</em>​ ​<strong class="kw">when</strong>​ action ​<strong class="kw">in</strong>​ [​<em class="string">:index</em>​, ​<em class="string">:show</em>​]</td></tr></table>
<p id="calibre_link-1041" class="calibre19">
Now, back to the router. Let’s define a new scope called <span class="cf">/manage</span> containing the video resources. This scope pipes through the browser pipeline and our newly imported <span class="cf">authenticate_user</span> function, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/relationships/listings/rumbl/lib/rumbl_web/router.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">relationships/listings/rumbl/lib/rumbl_web/router.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">scope ​<em class="string">"</em>​​<em class="string">/manage"</em>​, RumblWeb ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  pipe_through [​<em class="string">:browser</em>​, ​<em class="string">:authenticate_user</em>​]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  resources ​<em class="string">"</em>​​<em class="string">/videos"</em>​, VideoController</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1042" class="calibre19">

<span class="cf">pipe_through</span> can work with a single pipeline, and it also supports a list of them. Furthermore, because pipelines are also plugs, we can use <span class="cf">authenticate_user</span> directly in <span class="cf">pipe_through</span>.</p>
<p id="calibre_link-1043" class="calibre19">

We now have a whole group of actions that allow the users to manage content. In a business application, many of those groups of tasks would have a policy, or checklist. Our combination of plugs with <span class="cf">pipe_through</span> allows developers to mix and match those policies at will. You can use these techniques for any group of users that share your plug’s policies, whether they are admins or anonymous users. Applications can use as many plugs and pipelines as they need to do a job, organizing them in scopes.</p>
<p id="calibre_link-1044" class="calibre19">We’re almost ready to give the generated code a try, but first we need to run the last of the generator’s instructions. Go ahead and update the database by running migrations:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">ecto.migrate</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Compiling 24 files (.ex)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Generated rumbl app</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] == Running Rumbl.Repo.Migrations.CreateVideos.change/0 forward</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] create table videos</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] create index videos_user_id_index</td></tr></table>
<p id="calibre_link-1045" class="calibre19">Next start your server:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">$ mix phx.server</td></tr></table>
<p id="calibre_link-1046" class="calibre19">And we’re all set. The migration created the new <span class="cf">video</span> table and an index to keep it fast.  Head over to your browser and visit <span class="cf">http://localhost:4000/manage/videos</span> as a logged-in user. We see an empty list of videos:</p><div class="praise"><div class="praise"><img id="calibre_link-1047" class="border7" src="images/000027.png" alt="images/src/relationships/posts_empty.png" width="810" height="320" /></div></div>
<p id="calibre_link-1048" class="calibre19">


Now take it for a test drive. Click “New video” to create a video. We see the generated form for a new video in the <a href="#calibre_link-272" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">figure</a>.</p><div id="calibre_link-272" class="praise"><div class="praise"><img id="calibre_link-1049" class="border7" src="images/000007.png" alt="images/src/relationships/posts_new.png" width="810" height="685" /></div></div>
<p id="calibre_link-1050" class="calibre19">Fill out the form and click “Save”. The application should create your video and redirect. We’re not yet scoping our video lists to a given user, but we still have a great start. We know that code generators like this one aren’t unique, that dozens of other tools and languages do the same. Still, it’s a useful exercise that can rapidly ramp up your understanding of Phoenix and even Elixir. Let’s take a quick glance at what was generated.</p><h3 class="calibre22">Examining the Generated Context, Controller, and View</h3>
<p id="calibre_link-1051" class="calibre19">


The generated controller is complete. It contains the full spectrum of REST actions. The <span class="cf">Multimedia</span> context handles all of our heavy lifting.</p>
<p id="calibre_link-1052" class="calibre19">

The view looks like an empty module, but at this point we already know that it will pick all templates in <span class="cf">lib/rumbl_web/templates/video</span> and transform them into functions, such as <span class="cf">render("index.html", assigns)</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/relationships/rumbl/lib/rumbl_web/views/video_view.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">relationships/rumbl/lib/rumbl_web/views/video_view.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ RumblWeb.VideoView ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ RumblWeb, ​<em class="string">:view</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1053" class="calibre19">
Take some time and read through the template files in <span class="cf">lib/rumbl_web/templates/video/</span> to see how Phoenix uses forms, links, and other HTML functions. There’s no magic with Phoenix. Everything is explicit so you can see exactly what each function does. With the application boilerplate generated, we can shift our focus to Ecto relationships, starting with the generated migration.</p>
<p id="calibre_link-1054" class="calibre19">First let’s take a look at the generated <span class="cf">Multimedia</span> context in <span class="cf">lib/rumbl/multimedia.ex</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/relationships/listings/rumbl/lib/rumbl/multimedia.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">relationships/listings/rumbl/lib/rumbl/multimedia.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ Rumbl.Multimedia ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">import</strong>​ Ecto.Query, ​<em class="string">warn:</em>​ false</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  alias Rumbl.Repo</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  alias Rumbl.Multimedia.Video</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ list_videos ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    Repo.all(Video)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ get_video!(id), ​<strong class="kw">do</strong>​: Repo.get!(Video, id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ create_video(attrs \\ %{}) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    %Video{}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; Video.changeset(attrs)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; Repo.insert()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ update_video(%Video{} = video, attrs) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    video</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; Video.changeset(attrs)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; Repo.update()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ delete_video(%Video{} = video) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    Repo.delete(video)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ change_video(%Video{} = video) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    Video.changeset(video, %{})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1055" class="calibre19">The <span class="cf">Accounts</span> context we wrote by hand is similar, so this context should look familiar to you. It contains a logical grouping of functions you can use to work with our videos. After all, grouping like functions is what contexts is all about. Let’s shift to the migrations code that will interact directly with the database to create our schema.</p><h3 class="calibre22">Generated Migrations</h3>
<p id="calibre_link-1056" class="calibre19">
Let’s open up the video migration in <span class="cf">priv/repo/migrations</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/relationships/listings/rumbl/priv/repo/migrations/20180408024739_create_videos.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">relationships/listings/rumbl/priv/repo/migrations/20180408024739_create_videos.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ change ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  create table(​<em class="string">:videos</em>​) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    add ​<em class="string">:url</em>​, ​<em class="string">:string</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    add ​<em class="string">:title</em>​, ​<em class="string">:string</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    add ​<em class="string">:description</em>​, ​<em class="string">:text</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    add ​<em class="string">:user_id</em>​, references(​<em class="string">:users</em>​, ​<em class="string">on_delete:</em>​ ​<em class="string">:nothing</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    timestamps()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  create index(​<em class="string">:videos</em>​, [​<em class="string">:user_id</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1057" class="calibre19">



Phoenix generates a migration for all the fields that we passed on the command line, like the migration we created by hand for our users table. You can see that our generator made effective use of the type hints we provided. In relational databases, <span class="calibre4">primary keys</span>, such as our automatically generated <span class="cf">id</span> field, identify rows. <span class="calibre4">Foreign keys</span>, such as our <span class="cf">user_id</span> field, point from one table to the primary key in another one. At the database level, this foreign key lets the database get in on the act of maintaining consistency across our two relationships. Ecto is helping us to do the right thing.</p>
<p id="calibre_link-1058" class="calibre19">




The <span class="cf">change</span> function handles two database changes: one for migrating up and one for migrating down. A migration up applies a migration, and a migration down reverts it. This way, if you make a mistake and need to move a single migration up or down, you can do so.</p>
<p id="calibre_link-1059" class="calibre19">

For example, let’s say you meant to add a <span class="cf">view_count</span> field to your generated <span class="cf">create_video</span> migration before you migrated the database up. You could create a new migration that adds your new field. Since you haven’t pushed your changes upstream yet, you can roll back, make your changes, and then migrate up again. First, you’d roll back your changes:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">ecto.rollback</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] == Running Rumbl.Repo.Migrations.CreateVideos.change/0 backward</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] drop index videos_user_id_index</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] drop table videos</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] == Migrated in 0.0s</td></tr></table>
<p id="calibre_link-1060" class="calibre19">We verify that our database was fully migrated up. Then we run <span class="cf">mix ecto.rollback</span> to undo our <span class="cf">CreateVideos</span> migration. At this point, we could add our missing <span class="cf">view_count</span> field. We don’t need a <span class="cf">view_count</span> at the moment, so let’s migrate back up and carry on:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">ecto.migrate</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] == Running Rumbl.Repo.Migrations.CreateVideos.change/0 forward</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] create table videos</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] create index videos_user_id_index</td></tr></table>
<p id="calibre_link-1061" class="calibre19">The migration sets up the basic relationships between our tables and&mdash;now that we’ve migrated back up&mdash;we’re ready to leverage those relationships in our schemas.





</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-307"><div id="calibre_link-1062" class="calibre2"><h2 id="calibre_link-105" class="calibre20">Building Relationships</h2>
<p id="calibre_link-1063" class="calibre19">





After the migration, Ecto generated a schema. This file is responsible for identifying the fields in a way that ties in to both the database table and the Elixir struct.  Now let’s take a look at the schema in <span class="cf">lib/rumbl/multimedia/video.ex</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/relationships/listings/rumbl/lib/rumbl/multimedia/video.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">relationships/listings/rumbl/lib/rumbl/multimedia/video.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">schema ​<em class="string">"</em>​​<em class="string">videos"</em>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  field ​<em class="string">:description</em>​, ​<em class="string">:string</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  field ​<em class="string">:title</em>​, ​<em class="string">:string</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  field ​<em class="string">:url</em>​, ​<em class="string">:string</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  field ​<em class="string">:user_id</em>​, ​<em class="string">:id</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  timestamps()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1064" class="calibre19">



Our schema sets up a <span class="cf">user_id</span> field, of type <span class="cf">:id</span>, while our migration defines a <span class="cf">:user_id</span> foreign key. To relate our data at the schema level, we need to tell Ecto about our Video to User association. Replace your <span class="cf">field :user_id, :id</span> line in your video schema with the following association:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">belongs_to ​<em class="string">:user</em>​, Rumbl.Accounts.User</td></tr></table>
<p id="calibre_link-1065" class="calibre19">Ecto will now use this information to build the right association between our schemas.</p>
<p id="calibre_link-1066" class="calibre19">


The video module also includes a <span class="cf">changeset</span> function, similar to the one that we defined for <span class="cf">Accounts.User</span>. The top of the pipeline kicks it all off. The <span class="cf">cast</span> function prepares tainted user input containing your specified fields for safe inclusion into the database. We require all fields to be present. <span class="cf">cast</span> uses a whitelist to tell Ecto which fields from user-input <span class="calibre4">may be allowed</span> in the input. <span class="cf">validate_required</span> is a validation that tells Ecto which fields <span class="calibre4">must be present</span> from that list of fields‘.</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/relationships/listings/rumbl/lib/rumbl/multimedia/video.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">relationships/listings/rumbl/lib/rumbl/multimedia/video.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">@doc false</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ changeset(video, attrs) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  video</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; cast(attrs, [​<em class="string">:url</em>​, ​<em class="string">:title</em>​, ​<em class="string">:description</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; validate_required([​<em class="string">:url</em>​, ​<em class="string">:title</em>​, ​<em class="string">:description</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1067" class="calibre19">The <span class="cf">:user_id</span> field is neither castable nor required in the previous example, because many times the field doesn’t come from external data such as forms but, rather, directly from the application. That’s exactly our case. We’ll make sure to associate the current user from the session to each new video.</p>
<p id="calibre_link-1068" class="calibre19">



With our <span class="cf">belongs_to</span> in place, we now have a complete one-to-many association. Now a <span class="cf">user</span> effectively has many <span class="cf">videos</span>. By defining these relationships, we can now use Ecto’s association features. Fire up a new <span class="cf">iex -S mix</span> session so we can put the new <span class="cf">Video</span> code through its paces.</p>
<p id="calibre_link-1069" class="calibre19">Let’s create a new video to see how our new association ties things together:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ {​<em class="string">:ok</em>​, video} = Rumbl.Multimedia.create_video(%{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​   ​<em class="string">title:</em>​ ​<em class="string">"</em>​​<em class="string">New Video"</em>​, ​<em class="string">url:</em>​ ​<em class="string">"</em>​​<em class="string">http://example.com"</em>​, ​<em class="string">description:</em>​ ​<em class="string">"</em>​​<em class="string">new video"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​ })</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{:ok, %Rumbl.Multimedia.Video{...}}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ video.user</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">#Ecto.Association.NotLoaded&lt;association :user is not loaded&gt;</td></tr></table>
<p id="calibre_link-1070" class="calibre19">Ecto associations are explicit! When you want Ecto to fetch some records, you need to ask. When you don’t ask, you can be sure that you won’t get them. This decision may seem tedious at first, but it’s useful. One of the most time-consuming things about dealing with persistence frameworks is that they can often fetch rows you don’t need or fetch in inefficient ways. When these kinds of changes cascade, you can quickly run up a tab that you’re unable to pay.</p>
<p id="calibre_link-1071" class="calibre19">Digging deeper, you can see that referencing <span class="cf">video.user</span> returns <span class="cf">Ecto.Assocation.NotLoaded</span>.</p>
<p id="calibre_link-1072" class="calibre19">Let’s load some videos, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ video = Rumbl.Repo.preload(video, ​<em class="string">:user</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ video.user</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">nil</td></tr></table>
<p id="calibre_link-1073" class="calibre19">
There’s not much to see here yet, but we are making progress. <span class="cf">Repo.preload</span> accepts one name or a collection of association names. It loads the associated data for you&mdash;in this case, <span class="cf">:user</span>. After Ecto tries to fetch the association, we can reference the <span class="cf">video.user</span>, which returns <span class="cf">nil</span> since our video doesn’t yet have an associated user. To make this even more meaningful, we need some associated data.</p>
<p id="calibre_link-1074" class="calibre19">Let’s attach a video to one of our users:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ alias Ecto.Changeset</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ alias Rumbl.Repo</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ user = Rumbl.Accounts.get_user_by(​<em class="string">username:</em>​ ​<em class="string">"</em>​​<em class="string">josevalim"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%Rumbl.Accounts.User{...}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ changeset =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​   video |&gt; Changeset.change() |&gt; Changeset.put_assoc(​<em class="string">:user</em>​, user)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">#Ecto.Changeset&lt;​<span class="coprompt">...&gt;</span>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ video = Repo.update!(changeset)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%Rumbl.Multimedia.Video{...}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ video.user</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%Rumbl.Accounts.User{username: "josevalim"}</td></tr></table>
<p id="calibre_link-1075" class="calibre19">

Part of a framework’s job is to make tedious things easier. In this case, <span class="cf">Ecto.Changeset.put_assoc</span> allows us to place an association as a change into the changeset with a little less ceremony. This is how you would make the same change without the useful <span class="cf">put_assoc</span> function:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ video = \</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​   video \</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​   |&gt; Changeset.change() \</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​   |&gt; Changeset.put_change(​<em class="string">:user_id</em>​, user.id) \</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​   |&gt; Repo.update!()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%Rumbl.Multimedia.Video{}</td></tr></table>
<p id="calibre_link-1076" class="calibre19">You didn’t even have to remember the specific foreign key for the <span class="cf">User</span> association. Now that our video has a user, let’s try preload again:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ video = Repo.get(Rumbl.Multimedia.Video, video.id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%Rumbl.Multimedia.Video{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   ...,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   user: #Ecto.Association.NotLoaded&lt;association :user is not loaded&gt;,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ video = Repo.preload(video, ​<em class="string">:user</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%Rumbl.Multimedia.Video{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ...,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  user: %Rumbl.Accounts.User{username: "josevalim"}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  user_id: 1</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">}</td></tr></table>
<p id="calibre_link-1077" class="calibre19">Preload is great for bundling data. Other times we may want to fetch the user associated with a video, without storing the user in the video struct, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ query = Ecto.assoc(video, ​<em class="string">:user</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">#Ecto.Query&lt;​<span class="coprompt">...&gt;</span>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Repo.one(query)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%Rumbl.Accounts.User{username: "josevalim"}</td></tr></table>
<p id="calibre_link-1078" class="calibre19">


<span class="cf">assoc</span> is another convenient function from <span class="cf">Ecto</span> that returns an <span class="cf">Ecto.Query</span>
with the user scoped to the given video. We convert this query into data by calling <span class="cf">Repo.one</span>. As you’ll learn in the next chapter, we’ll be able to further manipulate this query, allowing us to slice the data in any way we want.</p>
<p id="calibre_link-1079" class="calibre19">If you’re a careful reader, you might have noticed the one-way relationship between videos and users. We generally want to avoid having cyclic dependencies between our contexts. It is expected for the <span class="cf">Video</span> schema to depend on <span class="cf">User</span>, but if we also allow the <span class="cf">User</span> schema to reach out to schemas in other contexts, the responsibilities between the accounts and multimedia contexts will blur over time.</p>
<p id="calibre_link-1080" class="calibre19">Now let’s dig deeper into related data.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-24"><div id="calibre_link-1081" class="calibre2"><h2 id="calibre_link-106" class="calibre20">Managing Related Data</h2>
<p id="calibre_link-1082" class="calibre19">
Our generated video controller gave us the CRUD basics, but as with any generated code, we’re going to need to tailor it to our needs. We want to link videos with users for this social platform. To do so, we need to grab the current user from the connection and scope our operations against the user. Open up your <span class="cf">lib/rumbl_web/controllers/video_controller.ex</span>, and scroll to the <span class="cf">create</span> action:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ create(conn, %{​<em class="string">"</em>​​<em class="string">video"</em>​ =&gt; video_params}) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">case</strong>​ Multimedia.create_video(video_params) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, video} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      |&gt; put_flash(​<em class="string">:info</em>​, ​<em class="string">"</em>​​<em class="string">Video created successfully."</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      |&gt; redirect(​<em class="string">to:</em>​ Routes.video_path(conn, ​<em class="string">:show</em>​, video))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:error</em>​, %Ecto.Changeset{} = changeset} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      render(conn, ​<em class="string">"</em>​​<em class="string">new.html"</em>​, ​<em class="string">changeset:</em>​ changeset)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1083" class="calibre19">



That’s simple enough. We create a video with the <span class="cf">create_video</span> function and then redirect if it’s successful, otherwise we render the errors. That’s a good start, but it’s not sufficient. We need to associate the video with the current user’s session. That user is already in the connection at <span class="cf">conn.assigns.current_user</span>. We know that the <span class="cf">put_assoc</span> function in <span class="cf">Ecto.Changeset</span> does just that. Our multimedia context’s <span class="cf">create_video</span> function has all of the basics and is ready for extension.</p>
<p id="calibre_link-1084" class="calibre19">Let’s rewrite our <span class="cf">create_video</span> to receive and associate a user to the video, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/relationships/listings/rumbl/lib/rumbl/multimedia.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">relationships/listings/rumbl/lib/rumbl/multimedia.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">alias Rumbl.Accounts</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ create_video(%Accounts.User{} = user, attrs \\ %{}) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  %Video{}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; Video.changeset(attrs)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; Ecto.Changeset.put_assoc(​<em class="string">:user</em>​, user)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; Repo.insert()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1085" class="calibre19">Our new implementation receives the user and puts it in the changeset with <span class="cf">Ecto.Changeset.put_assoc</span>, just like we did in iex. The last step is to provide the current user from the controller to  the new <span class="cf">create_video</span> function we wrote in the <span class="cf">Multimedia</span> context. Similarly, we need to touch up the <span class="cf">new</span> and <span class="cf">edit</span> actions to use <span class="cf">current_user</span> in the <span class="cf">change_video</span> function, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/relationships/listings/rumbl/lib/rumbl_web/controllers/video_controller.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">relationships/listings/rumbl/lib/rumbl_web/controllers/video_controller.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ create(conn, %{​<em class="string">"</em>​​<em class="string">video"</em>​ =&gt; video_params}) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">case</strong>​ Multimedia.create_video(conn.assigns.current_user, video_params) ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, video} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">      |&gt; put_flash(​<em class="string">:info</em>​, ​<em class="string">"</em>​​<em class="string">Video created successfully."</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      |&gt; redirect(​<em class="string">to:</em>​ Routes.video_path(conn, ​<em class="string">:show</em>​, video))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    {​<em class="string">:error</em>​, %Ecto.Changeset{} = changeset} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      render(conn, ​<em class="string">"</em>​​<em class="string">new.html"</em>​, ​<em class="string">changeset:</em>​ changeset)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1086" class="calibre19">On line 2 we passed our current user to our modified multimedia context function. This code gives us what we want, mostly. Notice the code <span class="cf">conn.assigns.current_user</span>. That code has a crucial task, and it’s a task we’re going to use in nearly all the actions of this controller. Though that code seems concise, it’s code with a common job and we’ll wind up repeating it often. We could define a <span class="cf">current_user(conn)</span> function, but we can do better. Let’s add the <span class="cf">current_user</span> to the argument list for our actions. We’ll do so with the custom <span class="cf">action</span> function in the controller, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/relationships/listings/rumbl/lib/rumbl_web/controllers/video_controller.change2.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">relationships/listings/rumbl/lib/rumbl_web/controllers/video_controller.change2.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ action(conn, _) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  args = [conn, conn.params, conn.assigns.current_user]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  apply(__MODULE__, action_name(conn), args)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1087" class="calibre19">









Each controller is also a plug. To call a controller, Phoenix invokes the default <span class="cf">action</span> function at the end of the controller pipeline. We’re replacing it because we want to change the API for all of our controller actions. It’s easy enough. We call <span class="cf">apply</span> to call our action the way we want. The <span class="cf">apply</span> function takes the module, the action name, and the arguments. Rather than explicitly using our module’s name, we use the <span class="cf">__MODULE__</span> directive, which expands to the current module, in <span class="cf">atom</span> form. Now, if our module name changes, we do not have to change our code along with it.  The arguments are now the connection, the parameters, and the current user. Presto. Each action has a new signature.</p>
<p id="calibre_link-1088" class="calibre19">

Let’s tweak <span class="cf">new</span> and <span class="cf">create</span> actions to receive all three parameters:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/relationships/listings/rumbl/lib/rumbl_web/controllers/video_controller.change2.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">relationships/listings/rumbl/lib/rumbl_web/controllers/video_controller.change2.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ new(conn, _params, _current_user) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  changeset = Multimedia.change_video(%Video{})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  render(conn, ​<em class="string">"</em>​​<em class="string">new.html"</em>​, ​<em class="string">changeset:</em>​ changeset)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ create(conn, %{​<em class="string">"</em>​​<em class="string">video"</em>​ =&gt; video_params}, current_user) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">case</strong>​ Multimedia.create_video(current_user, video_params) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, video} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      |&gt; put_flash(​<em class="string">:info</em>​, ​<em class="string">"</em>​​<em class="string">Video created successfully."</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      |&gt; redirect(​<em class="string">to:</em>​ Routes.video_path(conn, ​<em class="string">:show</em>​, video))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:error</em>​, %Ecto.Changeset{} = changeset} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      render(conn, ​<em class="string">"</em>​​<em class="string">new.html"</em>​, ​<em class="string">changeset:</em>​ changeset)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1089" class="calibre19">



The <span class="cf">new</span> action does not need to associate videos with users because <span class="cf">new</span> does not insert data into the database. However, if you want to associate them at this moment, there would be no harm either. Next, we make use of the new <span class="cf">current_user</span> parameter in the <span class="cf">create</span> action. This change is not just for utility. <span class="cf">current_user</span> can also help make our application more secure by reminding us to first scope any list of videos to the current user.
</p>
<p id="calibre_link-1090" class="calibre19">


For all of the remaining actions, we will want to let each user manage only the videos that they created. We will need to expose a function in our <span class="cf">Multimedia</span> context to look up the videos for a given user. We will do so in two parts. <span class="cf">user_videos_query</span> will define an Ecto query to return a user’s videos. Then, both the <span class="cf">list_user_videos</span> and <span class="cf">get_user_video!</span> functions will scope a request to the videos a user can see.</p>
<p id="calibre_link-1091" class="calibre19">Let’s do that now:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/relationships/listings/rumbl/lib/rumbl/multimedia.change2.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">relationships/listings/rumbl/lib/rumbl/multimedia.change2.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ list_user_videos(%Accounts.User{} = user) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Video</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; user_videos_query(user)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; Repo.all()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ get_user_video!(%Accounts.User{} = user, id) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Video</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; user_videos_query(user)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; Repo.get!(id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defp</strong>​ user_videos_query(query, %Accounts.User{​<em class="string">id:</em>​ user_id}) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  from(v ​<strong class="kw">in</strong>​ query, ​<em class="string">where:</em>​ v.user_id == ^user_id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1092" class="calibre19">






The <span class="cf">user_videos_query</span> query fetches all of the videos with a matching user ID. <span class="cf">list_user_videos</span> and <span class="cf">get_user_video!</span> make use of that shared query. We also see the composeable nature of Ecto queries. For the most part, our new functions are similar to the original <span class="cf">list_videos</span> and <span class="cf">get_video!</span> functions. The only difference is that we pipe videos through the user query before invoking the repository. Now, we need only use the new functions in the <span class="cf">index</span>, <span class="cf">show</span>, <span class="cf">edit</span>, <span class="cf">update</span>, and <span class="cf">delete</span> actions:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/relationships/listings/rumbl/lib/rumbl_web/controllers/video_controller.change2.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">relationships/listings/rumbl/lib/rumbl_web/controllers/video_controller.change2.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ index(conn, _params, current_user) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">2:&nbsp;</span></td><td class="codeline">  videos = Multimedia.list_user_videos(current_user) </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">3:&nbsp;</span></td><td class="codeline">  render(conn, ​<em class="string">"</em>​​<em class="string">index.html"</em>​, ​<em class="string">videos:</em>​ videos)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">4:&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">6:&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ show(conn, %{​<em class="string">"</em>​​<em class="string">id"</em>​ =&gt; id}, current_user) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">7:&nbsp;</span></td><td class="codeline">  video = Multimedia.get_user_video!(current_user, id) </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">8:&nbsp;</span></td><td class="codeline">  render(conn, ​<em class="string">"</em>​​<em class="string">show.html"</em>​, ​<em class="string">video:</em>​ video)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">9:&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1093" class="calibre19">On lines 2 and 7, we grabbed our <span class="cf">current_user</span> from the action and called our new <span class="cf">Multimedia.list_user_videos</span> and <span class="cf">Multimedia.get_user_video!</span> functions to authorize access. Now, users can only access the information from videos they own. If the user provides an id from any other video, Ecto raises a <span class="cf">not found</span> error. Let’s do the same change to <span class="cf">edit</span> and <span class="cf">update</span> to ensure that they can only change videos coming from the association. Now that we have the supporting functions, the change is easy:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/relationships/listings/rumbl/lib/rumbl_web/controllers/video_controller.change2.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">relationships/listings/rumbl/lib/rumbl_web/controllers/video_controller.change2.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ edit(conn, %{​<em class="string">"</em>​​<em class="string">id"</em>​ =&gt; id}, current_user) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  video = Multimedia.get_user_video!(current_user, id) </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  changeset = Multimedia.change_video(video)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  render(conn, ​<em class="string">"</em>​​<em class="string">edit.html"</em>​, ​<em class="string">video:</em>​ video, ​<em class="string">changeset:</em>​ changeset)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ update(conn, %{​<em class="string">"</em>​​<em class="string">id"</em>​ =&gt; id, ​<em class="string">"</em>​​<em class="string">video"</em>​ =&gt; video_params}, current_user) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  video = Multimedia.get_user_video!(current_user, id) </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">case</strong>​ Multimedia.update_video(video, video_params) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, video} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      |&gt; put_flash(​<em class="string">:info</em>​, ​<em class="string">"</em>​​<em class="string">Video updated successfully."</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      |&gt; redirect(​<em class="string">to:</em>​ Routes.video_path(conn, ​<em class="string">:show</em>​, video))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    {​<em class="string">:error</em>​, %Ecto.Changeset{} = changeset} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      render(conn, ​<em class="string">"</em>​​<em class="string">edit.html"</em>​, ​<em class="string">video:</em>​ video, ​<em class="string">changeset:</em>​ changeset)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1094" class="calibre19">

On lines 2 and 8 we called our new functions to authorize access. As before, we’ll reject any other requests to change another’s content, whether those change requests are malicious or simply our own bugs.</p>
<p id="calibre_link-1095" class="calibre19">


Finally, we need to do the same for <span class="cf">delete</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/relationships/listings/rumbl/lib/rumbl_web/controllers/video_controller.change2.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">relationships/listings/rumbl/lib/rumbl_web/controllers/video_controller.change2.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ delete(conn, %{​<em class="string">"</em>​​<em class="string">id"</em>​ =&gt; id}, current_user) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">2:&nbsp;</span></td><td class="codeline">  video = Multimedia.get_user_video!(current_user, id) </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">3:&nbsp;</span></td><td class="codeline">  {​<em class="string">:ok</em>​, _video} = Multimedia.delete_video(video)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">4:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">  conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">6:&nbsp;</span></td><td class="codeline">  |&gt; put_flash(​<em class="string">:info</em>​, ​<em class="string">"</em>​​<em class="string">Video deleted successfully."</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">7:&nbsp;</span></td><td class="codeline">  |&gt; redirect(​<em class="string">to:</em>​ Routes.video_path(conn, ​<em class="string">:index</em>​))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">8:&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1096" class="calibre19">Once again, we use <span class="cf">Multimedia.get_user_video!</span> to properly lock down access. After those changes, our users have a panel for managing their videos in a safe way. Using simple Ecto queries with well-named context functions, we built a solid authorization rule restricting deletes and updates to the video’s formal owner. Our application is easier to read and more secure thanks to these changes.











</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-189"><div id="calibre_link-1097" class="calibre2"><h2 id="calibre_link-107" class="calibre20">In-context Relationships</h2>
<p id="calibre_link-1098" class="calibre19">



So far, we’ve created a new context each time we create a new resource. However, one of the important ideas behind contexts is to group similar resources, meaning sometimes new resources should go into existing contexts. We already talked about how the <span class="cf">Multimedia</span> context could manage related entities such as videos, books and the like in the future.</p>
<p id="calibre_link-1099" class="calibre19">


Sometimes we’ll define relationships within the same context. For example, let’s add categories to our videos. Categories are simple resources. They have a single category name field that will be something like action, comedy or sci-fi. We expect our categories to be mostly fixed. After we define a few of them, we don’t expect them to change often. For this reason, we don’t need to create a controller with a view and templates to manage them from user input. We can create them programatically instead.</p>
<p id="calibre_link-1100" class="calibre19">Since all multimedia resources have categories and categories are only available to multimedia resources, it makes sense to define these categories within the Multimedia context. We will define the category schema as <span class="cf">Multimedia.Category</span>.</p><table class="simpletable"><thead class="calibre33"><tr class="calibre34"><th colspan="2" class="outerlines"><p class="calibre31">Should I Create Another Context?</p></th></tr></thead><tbody class="calibre35"><tr class="tr"><td class="calibre36">
               <img id="calibre_link-1101" class="calibre37" src="images/000035.png" alt="images/aside-icons/info.png" width="283" height="300" />
             </td><td class="calibre38">

<p class="calibre31">


Sometimes it may be tricky to determine if two resources belong to the same context or not. The fact two resources are related in the database does not imply they belong in the same context. Otherwise, almost all schemas would be within the <span class="cf1">Accounts</span> context, as the majority of entities in a system belong to a user.</p>
<p class="calibre31">For example, users and videos are related, but they clearly belong in different contexts. On the other hand, categories and videos are also related, but we put them together, as categories are only available to multimedia resources and they do not bring much complexity on their own. In cases you are unsure how to group your resources, prefer distinct contexts per resource and refactor later if necessary. Otherwise you can easily end up with large contexts of loosely related entities. Similarly, if a context grows too large over time, you can always break it apart. To sum it up: When in doubt, put your new resource in its own context.</p>
</td></tr></tbody></table>
<p id="calibre_link-1102" class="calibre19">Let’s once again use generators to define our categories, but this time we’ll use a different generator. Let’s study our options.</p><h3 class="calibre22">Schema and Context Generators</h3>
<p id="calibre_link-1103" class="calibre19">

Up to this point, we’ve used the <span class="cf">mix ecto.gen.migration</span> generator and <span class="cf">mix phx.gen.html</span>. Those generators operate at two different ends of the spectrum when it comes to building our app. The <span class="cf">migration</span> generator has a very specific concern and generates only migration files while the <span class="cf">html</span> and <span class="cf">json</span> generators generate migrations, schemas, contexts, as well as controllers, views, and templates.</p>
<p id="calibre_link-1104" class="calibre19">



It just so happens there are two generators that fit between the HTML generator and the migration: context and schema generators. Let’s briefly discuss those generators and when to use them. Remember, you can get more information about any generator by typing <span class="cf">mix help GENERATOR_NAME</span> in your terminal.</p>
<p id="calibre_link-1105" class="calibre19">In the following examples, we’ll use the upcoming <span class="cf">Multimedia.Category</span> as an example. Once we explore all options, we can make an informed generator choice. The candidates are:</p><ul class="calibre28"><li class="calibre29">
<p id="calibre_link-1106" class="calibre31"><span class="cf1">mix phx.gen.html Multimedia Category categories name:string</span>. This command generates a controller, view, and template on the frontend. On the backend, it generates a <span class="cf1">Multimedia</span> context, a <span class="cf1">Multimedia.Category</span> schema, and a migration. This generator, and the similar <span class="cf1">mix phx.gen.json</span> generator, are typically used when we want to define all conveniences to expose a resource over the web interface.</p></li><li class="calibre29">
<p id="calibre_link-1107" class="calibre31"><span class="cf1">mix phx.gen.context Multimedia Category categories name:string</span>. This command makes a <span class="cf1">Multimedia</span> context, a <span class="cf1">Multimedia.Category</span> schema and the associated migration. This generator is useful for generating a resource with all of its context functions <span class="calibre4">without exposing that resource via the web interface</span>. Note that if the context already exists, which is the case for <span class="cf1">Multimedia</span>, the generator will inject the new category functions into the existing context.</p></li><li class="calibre29">
<p id="calibre_link-1108" class="calibre31"><span class="cf1">mix phx.gen.schema Multimedia.Category categories name:string</span>. This command creates a schema with a migration. It’s useful for creating a resource when you want to define the context functions yourself.</p></li><li class="calibre29">
<p id="calibre_link-1109" class="calibre31"><span class="cf1">mix ecto.gen.migration create_categories</span>. This generator builds a new empty migration. Useful when the schema and context are already laid out, and all you need is to update the database

</p></li></ul>
<p id="calibre_link-1110" class="calibre19">In our case, we know our categories won’t be managed via a web interface. That rules out <span class="cf">mix phx.gen.html</span>. We also know that we want a schema, so we can associate it with videos. That rules out <span class="cf">mix ecto.gen.migration</span>, as it does too little.</p>
<p id="calibre_link-1111" class="calibre19">Therefore, we need to choose between <span class="cf">mix phx.gen.context</span> and <span class="cf">mix phx.gen.schema</span>. Both choices work fine. If you want Phoenix to generate more code than you need and then trim from there, you’ll generate the context. If you’d rather generate the minimum amount of code and build what you need from scratch, you’ll use the schema generator. Since categories don’t need a web interface, our hunch is that we won’t need most of the generated context functions so we’ll pick the schema generator.</p>
<p id="calibre_link-1112" class="calibre19">Enough exposition. Let’s get down to business.</p><h3 class="calibre22">Generating Category Migrations</h3>
<p id="calibre_link-1113" class="calibre19">


Generate the <span class="cf">Multimedia.Category</span> schema like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">phx.gen.schema</strong>​​<strong class="kw"> </strong>​​<strong class="kw">Multimedia.Category</strong>​​<strong class="kw"> </strong>​​<strong class="kw">categories</strong>​​<strong class="kw"> </strong>​​<strong class="kw">name:string</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating lib/rumbl/multimedia/category.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating priv/repo/migrations/20180513025558_create_categories.exs</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...</span>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">    $ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">ecto.migrate</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">---- END OF OUTPUT ----</td></tr></table>
<p id="calibre_link-1114" class="calibre19">As expected, the command generated a category schema and a migration. The schema is backed by the “categories” database table with a <span class="cf">name</span> column  of type <span class="cf">string</span>.</p>
<p id="calibre_link-1115" class="calibre19">

Next, let’s edit our migration to mark the <span class="cf">name</span> field as <span class="cf">NOT NULL</span> and create a unique index for it:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/relationships/listings/rumbl/priv/repo/migrations/20180513025558_create_categories.change1.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">relationships/listings/rumbl/priv/repo/migrations/20180513025558_create_categories.change1.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ Rumbl.Repo.Migrations.CreateCategories ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ Ecto.Migration</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ change ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    create table(​<em class="string">:categories</em>​) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      add ​<em class="string">:name</em>​, ​<em class="string">:string</em>​, ​<em class="string">null:</em>​ false</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      timestamps()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    create unique_index(​<em class="string">:categories</em>​, [​<em class="string">:name</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1116" class="calibre19">

Now we can add the referential constraints to our <span class="cf">Video</span> schema. A <span class="cf">Video</span> belongs to a <span class="cf">Category</span>, like so:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/relationships/listings/rumbl/lib/rumbl/multimedia/video.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">relationships/listings/rumbl/lib/rumbl/multimedia/video.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">schema ​<em class="string">"</em>​​<em class="string">videos"</em>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">2:&nbsp;</span></td><td class="codeline">  field ​<em class="string">:description</em>​, ​<em class="string">:string</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">3:&nbsp;</span></td><td class="codeline">  field ​<em class="string">:title</em>​, ​<em class="string">:string</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">4:&nbsp;</span></td><td class="codeline">  field ​<em class="string">:url</em>​, ​<em class="string">:string</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">6:&nbsp;</span></td><td class="codeline">  belongs_to ​<em class="string">:user</em>​, Rumbl.Accounts.User</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">7:&nbsp;</span></td><td class="codeline">  belongs_to ​<em class="string">:category</em>​, Rumbl.Multimedia.Category </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">8:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">9:&nbsp;</span></td><td class="codeline">  timestamps()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1117" class="calibre19">

We created a simple belongs-to relationship, so we need to add the <span class="cf">category_id</span> to the permitted fields for our changeset:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/relationships/listings/rumbl/lib/rumbl/multimedia/video.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">relationships/listings/rumbl/lib/rumbl/multimedia/video.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">@doc false</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">2:&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ changeset(video, attrs) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">3:&nbsp;</span></td><td class="codeline">  video</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">4:&nbsp;</span></td><td class="codeline">  |&gt; cast(attrs, [​<em class="string">:url</em>​, ​<em class="string">:title</em>​, ​<em class="string">:description</em>​, ​<em class="string">:category_id</em>​]) </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">  |&gt; validate_required([​<em class="string">:url</em>​, ​<em class="string">:title</em>​, ​<em class="string">:description</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">6:&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1118" class="calibre19">Now our API users can safely use <span class="cf">category_id</span> in the user input we provide to our changeset. Use <span class="cf">mix ecto.gen.migration</span> to generate a migration to add the <span class="cf">category_id</span> to our <span class="cf">video</span> table:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">ecto.gen.migration</strong>​​<strong class="kw"> </strong>​​<strong class="kw">add_category_id_to_video</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating priv/repo/migrations</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating priv/repo/migrations/20180513030504_add_category_id_to_video.exs</td></tr></table>
<p id="calibre_link-1119" class="calibre19">With the database table updated, this relationship will allow us to add a new category ID to our existing videos. Now open up your new <span class="cf">priv/repo/migrations/xxx_add_category_id_to_video.exs</span> and key this in:</p><div class="livecodelozenge">relationships/listings/rumbl/priv/repo/migratio … 80513030504_add_category_id_to_video.change1.exs</div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ change ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  alter table(​<em class="string">:videos</em>​) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    add ​<em class="string">:category_id</em>​, references(​<em class="string">:categories</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1120" class="calibre19">This code sets up a database constraint between videos and categories, one that will ensure that the <span class="cf">category_id</span> for a <span class="cf">video</span> exists. Finally, migrate your database with your two new migrations:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">ecto.migrate</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] == Running Rumbl.Repo.Migrations.CreateCategories.change/0 forward</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] create table categories</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] create index categories_name_index</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] == Migrated in 0.0s</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] == Running Rumbl.Repo.Migrations.AddCategoryIdToVideo.change/0 forward</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] alter table videos</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] == Migrated in 0.0s</td></tr></table>
<p id="calibre_link-1121" class="calibre19">We migrated our categories and added the proper foreign keys. The database will maintain the database integrity, regardless of what we do on the Phoenix side. With our relationships established, we can safely associate videos with categories in our user interface, by presenting a list of categories whenever a user creates or edits a video. To do that, we need to learn how to effectively query data. That’s exactly what we have in store for you in the next chapter.





</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-233"><div id="calibre_link-1122" class="calibre2"><h2 id="calibre_link-108" class="calibre20">Wrapping Up</h2>
<p id="calibre_link-1123" class="calibre19">In this chapter, we generated a <span class="cf">Video</span> resource with a relationship to <span class="cf">User</span> and made changes to the generated code, learning a lot along the way:</p><ul class="calibre28"><li class="calibre29">
<p id="calibre_link-1124" class="calibre31">We used contexts throughout to craft an easy-to-maintain API layer for our application.</p></li><li class="calibre29">
<p id="calibre_link-1125" class="calibre31">We converted a private plug into a public function and shared it with our controllers and routers.</p></li><li class="calibre29">
<p id="calibre_link-1126" class="calibre31">You learned how to migrate and roll back changes to the database.</p></li><li class="calibre29">
<p id="calibre_link-1127" class="calibre31">We defined relationships between <span class="cf1">User</span> and <span class="cf1">Video</span> schemas and used functions from Ecto to build and retrieve associated data.</p></li><li class="calibre29">
<p id="calibre_link-1128" class="calibre31">We discussed the main generators Phoenix provides to scaffold our applications.</p></li></ul>
<p id="calibre_link-1129" class="calibre19">The next chapter will take everything up a notch by exploring Ecto queries and leveraging the database constraints. When we’re done, you’ll be able to ensure data uniqueness and use the database to maintain data integrity. Turn the page, and let’s get started!</p>

<div class="copyright">Copyright © 2020, The Pragmatic Bookshelf.</div>




</div>



  </div>


<div class="calibre1" id="calibre_link-254"><div id="calibre_link-1130" class="calibre2"><h1 class="pcalibre6 chapter-title" id="calibre_link-109"><span class="chapter-number">
            Chapter
            7</span><br class="calibre18" /><span class="chapter-name">Ecto Queries and Constraints</span></h1>

<p id="calibre_link-1131" class="calibre19">In the previous chapter, we extended our application domain by associating videos to users and categories. Now we want our users to select which category a video belongs to upon video creation. To build this feature, you’ll need to learn how to programmatically populate the database with a hardcoded list of categories and add those new features to our context. Along the way we’ll explore some of the different ways you can use Ecto to retrieve data from the database.</p>
<p id="calibre_link-1132" class="calibre19">




We want to build our feature safely so that corrupt data can’t creep into our database, so we’ll spend some time working with database constraints. Database engines like PostgreSQL are called <span class="calibre4">relational</span> for a reason. A tremendous amount of time and effort has gone into tools and features that help developers define and enforce the relationships between tables. Instead of treating the database as pure dumb storage, Ecto uses the strengths of the database to help keep the data consistent. You’ll learn about error-reporting strategies so you’ll know when to report an error and when to let it crash, letting other application layers handle the problem.</p>
<p id="calibre_link-1133" class="calibre19">Let’s get started.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-301"><div id="calibre_link-1134" class="calibre2"><h2 id="calibre_link-110" class="calibre20">Seeding and Associating Categories</h2>
<p id="calibre_link-1135" class="calibre19">Let’s associate videos and categories. The first step is to make sure categories actually exist in our database by using seed data. Then we will change our web interface to allow users to pick the category for a new video.</p><h3 class="calibre22">Setting Up Category Seed Data</h3>
<p id="calibre_link-1136" class="calibre19">






We need to define a handful of initial categories for our application to use. We could start an IEx session and directly invoke the repository to do that, but this approach has some issues. If we do this work manually, each teammate will have to do the same as soon as they want to take our application for a spin. Once our application grows in size, having to populate each table in our application with relevant data can get long and tedious.</p>
<p id="calibre_link-1137" class="calibre19">Furthermore, categories won’t have a web interface where we can manage them, so we need a mechanism to create them in production programatically. Elixir is a great language for writing scripts so let’s create a small one to insert data in the database. We’ll let that new script use a function in our Multimedia context to create the necessary records.</p>
<p id="calibre_link-1138" class="calibre19">
Phoenix already defines a convention for seeding data. Open up <span class="cf">priv/repo/seeds.exs</span> and read the comments Phoenix generated for us. Phoenix will make sure that our database is appropriately populated. We only need to drop in a script that uses our repository to directly add the data we want. Then, we’ll be able to run Mix commands when it’s time to create the data.</p>
<p id="calibre_link-1139" class="calibre19">

Since the seed script may be executed multiple times, namely every time more seed data is added, we need to make sure our seed script won’t fail or won’t generate duplicated categories every time it runs.</p>
<p id="calibre_link-1140" class="calibre19">Let’s see what happens when we create a category that already exists. Open up IEx and key this in:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Rumbl.Repo.insert! %Rumbl.Multimedia.Category{​<em class="string">name:</em>​ ​<em class="string">"</em>​​<em class="string">Test"</em>​}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%Rumbl.Multimedia.Category{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  __meta__: #Ecto.Schema.Metadata&lt;:loaded, "categories"&gt;,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  id: 1,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  inserted_at: ~N[2019-05-19 13:06:12],</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  name: "hello",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  updated_at: ~N[2019-05-19 13:06:12]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">}</td></tr></table>
<p id="calibre_link-1141" class="calibre19">
So far, so good. We used the <span class="cf">insert!</span> repository function, which will raise an error if anything goes wrong. Let’s run the same command again:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Rumbl.Repo.insert! %Rumbl.Multimedia.Category{​<em class="string">name:</em>​ ​<em class="string">"</em>​​<em class="string">Test"</em>​}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">**</strong>​ (Ecto.ConstraintError) constraint error when attempting to insert struct:</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">*</strong>​ categories_name_index (unique_constraint)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">The changeset has not defined any constraint.</td></tr></table>
<p id="calibre_link-1142" class="calibre19">



Now Ecto has raised an a <span class="cf">ConstraintError</span>, letting us know that the <span class="cf">unique_constraint</span> defined in our database did not allow the operation to succeed. Ecto also tells us how to convert this constraint error into a changeset error, a technique we will employ later in this chapter.</p>
<p id="calibre_link-1143" class="calibre19">However, in this particular case, instead of returning errors as part of a changeset, we would rather create the category only if it doesn’t exist. Perhaps, we could write this operation as:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Repo.get_by(Category, ​<em class="string">name:</em>​ name) || Repo.insert!(%Category{​<em class="string">name:</em>​ name})</td></tr></table>
<p id="calibre_link-1144" class="calibre19">While this behavior would likely be fine for our seed scripts, this idiom is inherently unsafe, and we should generally avoid it. For instance, if two users are trying to create a new category with the same name at the same time, the <span class="cf">Repo.get_by(Category, name: name)</span> would return <span class="cf">nil</span> to both, causing both of them to insert the same category. Thanks to our uniqueness constraint, only one of those operations will succeed and we will not get duplicate categories, but the other user would get an error page, leading to a poor user experience.</p>
<p id="calibre_link-1145" class="calibre19">
The answer to the problem is once more to let the database manage the data integrity. In particular, we want to let the database manage what happens when there is a conflict with the data we are inserting. This feature is commonly known as an “Upsert” because it is common to update the data whenever there is a conflict during an insert. In this case, we want to simply ignore the conflict.</p>
<p id="calibre_link-1146" class="calibre19">Ecto allows us to do exactly that via the <span class="cf">:on_conflict</span> option:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Rumbl.Repo.insert! %Rumbl.Multimedia.Category{​<em class="string">name:</em>​ ​<em class="string">"</em>​​<em class="string">hello"</em>​},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​   ​<em class="string">on_conflict:</em>​ ​<em class="string">:nothing</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%Rumbl.Multimedia.Category{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  __meta__: #Ecto.Schema.Metadata&lt;:loaded, "categories"&gt;,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  id: nil,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  inserted_at: ~N[2019-05-19 13:06:22],</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  name: "hello",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  updated_at: ~N[2019-05-19 13:06:22]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">}</td></tr></table>
<p id="calibre_link-1147" class="calibre19">



The default value for <span class="cf">:on_conflict</span> is <span class="cf">:raise</span>. Once we change it to <span class="cf">:nothing</span>,
no exceptions are raised and you can see the returned category has a <span class="cf">nil</span> <span class="cf">id</span>, indicating that indeed the category was not inserted. Upserts allow us to do many different things in case of conflicts, from updating certain fields to even performing whole queries. The downside is that the upsert behavour is often database specific, so make sure to explore the different options available to your database of choice. You can learn more about upserts in the documention for Repo.insert.<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-215" href="#calibre_link-302">[20]</a></sup></p>
<p id="calibre_link-1148" class="calibre19">Finally, let’s expose this operation in our <span class="cf">Multimedia</span> context with a new function called <span class="cf">create_category!</span>, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/queries/listings/rumbl/lib/rumbl/multimedia.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">queries/listings/rumbl/lib/rumbl/multimedia.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">alias Rumbl.Multimedia.Category</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ create_category!(name) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Repo.insert!(%Category{​<em class="string">name:</em>​ name}, ​<em class="string">on_conflict:</em>​ ​<em class="string">:nothing</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1149" class="calibre19">Now, use the new function in the <span class="cf">seeds</span> script like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/queries/listings/rumbl/priv/repo/seeds.change1.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">queries/listings/rumbl/priv/repo/seeds.change1.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">alias Rumbl.Multimedia</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">for category &lt;- ​<strong class="kw">~</strong>​w(Action Drama Romance Comedy Sci-fi) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Multimedia.create_category!(category)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1150" class="calibre19">


We use the sigil <span class="cf">~w</span> to define a list of words. Each word represents a category. We then traverse the list of category names, writing them to the database with the new <span class="cf">Multimedia.create_category!</span> function.</p>
<p id="calibre_link-1151" class="calibre19">Let’s run the <span class="cf">seeds</span> file with <span class="cf">mix run</span>:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">run</strong>​​<strong class="kw"> </strong>​​<strong class="kw">priv/repo/seeds.exs</strong>​</td></tr></table>
<p id="calibre_link-1152" class="calibre19">Presto! We have categories.



</p><h3 class="calibre22">Associating Videos and Categories</h3>
<p id="calibre_link-1153" class="calibre19">



</p>
<p id="calibre_link-1154" class="calibre19">Now that we’ve populated our database with categories, we want to allow users to choose a category when creating or editing a video. To do so, we’ll do all of the following:</p><ul class="calibre28"><li class="calibre29">Fetch all category names and IDs from the database</li><li class="calibre29">Sort them by the name</li><li class="calibre29">Pass them into the view as part of a <span class="cf1">select</span> input</li></ul>
<p id="calibre_link-1155" class="calibre19">To build this feature, we’ll need to start with a query. Let’s spend a little time with Ecto exploring queries a little more deeply. Fire up your project in IEx, and let’s warm up with some queries:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ ​<strong class="kw">import</strong>​ Ecto.Query</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ alias Rumbl.Repo</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ alias Rumbl.Multimedia.Category</td></tr></table>
<p id="calibre_link-1156" class="calibre19">




Importing <span class="cf">Ecto.Query</span> makes the Ecto query language available to us. That module plays some games with macros to provide a simple and beautiful query syntax with as little ceremony as possible. Since it’s a framework in such a central part of database development, the tradeoff of more complexity for the library against more productivity for users makes sense. We also alias <span class="cf">Repo</span> and <span class="cf">Category</span>. If you find yourself always issuing the same set of commands in a project directory, you can include them in a file called <span class="cf">.iex.exs</span>. If you want more details, you can read about customizing iex.<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-216" href="#calibre_link-303">[21]</a></sup></p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ query = from c ​<strong class="kw">in</strong>​ Category,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​          ​<em class="string">select:</em>​ c.name</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Repo.all query</td></tr></table>
<p id="calibre_link-1157" class="calibre19">


First, we create a query. In this case:</p><ul class="calibre28"><li class="calibre29"><span class="cf1">from</span> is a macro that builds a query.</li><li class="calibre29"><span class="cf1">c in Category</span> means we’re pulling rows (labeled <span class="cf1">c</span>) from the <span class="cf1">Category</span> schema.</li><li class="calibre29"><span class="cf1">select: c.name</span> means we’re going to return only the <span class="cf1">name</span> field.</li></ul>
<p id="calibre_link-1158" class="calibre19"><span class="cf">Repo.all</span> is simply a repository function that takes a query and returns all rows. You can see Ecto returns a few debugging lines that contain the exact SQL query we’re sending to the database, and the resulting five category names:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[debug] QUERY OK source="categories" db=1.9ms</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">SELECT c0."name" FROM "categories" AS c0 []</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">["Action", "Drama", "Romance", "Comedy", "Sci-fi"]</td></tr></table>
<p id="calibre_link-1159" class="calibre19">



Ecto’s real purpose is to efficiently translate Elixir concepts into a language the database understands. For us, that language will be SQL. We can order category names alphabetically by passing the <span class="cf">:order_by</span> option to our query. We can also return a tuple from both the <span class="cf">id</span> and <span class="cf">name</span> fields.</p>
<p id="calibre_link-1160" class="calibre19">Let’s give it another try:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Repo.all from c ​<strong class="kw">in</strong>​ Category,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​          ​<em class="string">order_by:</em>​ c.name,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​          ​<em class="string">select:</em>​ {c.name, c.id}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {"Action", 1},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {"Comedy", 4},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {"Drama", 2},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {"Romance", 3},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {"Sci-fi", 5}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">]</td></tr></table>
<p id="calibre_link-1161" class="calibre19">

However, we rarely need to define the whole query at once. Ecto queries are <span class="calibre4">composable</span>, which means you can define the query bit by bit:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ query = Category</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Category</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ query = from c ​<strong class="kw">in</strong>​ query, ​<em class="string">order_by:</em>​ c.name</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">#Ecto.Query&lt;&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ query = from c ​<strong class="kw">in</strong>​ query, ​<em class="string">select:</em>​ {c.name, c.id}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">#Ecto.Query&lt;&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Repo.all(query)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {"Action", 1},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {"Comedy", 4},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {"Drama", 2},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {"Romance", 3},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {"Sci-fi", 5}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">]</td></tr></table>
<p id="calibre_link-1162" class="calibre19">

This time, instead of building the whole query at once, we write it in small steps, adding a little more information along the way. You’ll see this strategy quite frequently in Elixir because it allows us to use pipes to build complex queries from simpler ones, bit by bit. This strategy works because Ecto defines something called the <span class="cf">queryable</span> protocol. <span class="cf">from</span> receives a <span class="cf">queryable</span>, and you can use any <span class="cf">queryable</span> as a base for a new query. A <span class="cf">queryable</span> is an Elixir protocol. Recall that protocols like <span class="cf">Enumerable</span> (for <span class="cf">Enum</span>) define APIs for specific language features. This one defines the API for something that can be queried.</p>
<p id="calibre_link-1163" class="calibre19">That’s also why we can call <span class="cf">Repo.all</span> either as <span class="cf">Repo.all(Category)</span> or <span class="cf">Repo.all(query)</span>: because both <span class="cf">Category</span> and <span class="cf">query</span> implement the so-called <span class="cf">Ecto.Queryable</span> protocol. By abiding by the protocol, you can quickly layer together sophisticated queries with <span class="cf">Ecto.Query</span>, maintaining clear boundaries between your layers and adding sophistication without complexity.</p>
<p id="calibre_link-1164" class="calibre19">


Let’s talk briefly about which pieces of our categories will go where. We’ll put query functions in our schema layer. Complex interactions, such as those between our multimedia and users, will go in in contexts. This organization will leave controllers as thin and simple as possible.</p>
<p id="calibre_link-1165" class="calibre19">Let’s implement the layered, composable query strategy. To make our queries compose well, we need functions that take a query as the first argument and return a query. We’ll add an <span class="cf">alphabetical</span> function to our <span class="cf">Category</span> module which will sort the results:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/queries/listings/rumbl/lib/rumbl/multimedia/category.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">queries/listings/rumbl/lib/rumbl/multimedia/category.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">import</strong>​ Ecto.Query</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ alphabetical(query) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  from c ​<strong class="kw">in</strong>​ query, ​<em class="string">order_by:</em>​ c.name</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1166" class="calibre19">To be more precise, our alphabetical function must receive and return a <span class="cf">queryable</span>. With our function in place, let’s expose this new feature from a well-named function in our <span class="cf">Multimedia</span> context:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/queries/listings/rumbl/lib/rumbl/multimedia.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">queries/listings/rumbl/lib/rumbl/multimedia.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ list_alphabetical_categories ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Category</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; Category.alphabetical()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; Repo.all()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1167" class="calibre19">In our user interface, we plan to build a picker that will need names for our users and ids for our backend relationships. We added a <span class="cf">Multimedia.list_alphabetical_categories</span> to fetch the data in the order we want. Let’s complete the circle by using our new functions to load all the categories in our <span class="cf">VideoController</span> and shape the data into a select drop-down within our <span class="cf">VideoView</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/queries/listings/rumbl/lib/rumbl_web/controllers/video_controller.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">queries/listings/rumbl/lib/rumbl_web/controllers/video_controller.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">plug ​<em class="string">:load_categories</em>​ ​<strong class="kw">when</strong>​ action ​<strong class="kw">in</strong>​ [​<em class="string">:new</em>​, ​<em class="string">:create</em>​, ​<em class="string">:edit</em>​, ​<em class="string">:update</em>​]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defp</strong>​ load_categories(conn, _) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assign(conn, ​<em class="string">:categories</em>​, Multimedia.list_alphabetical_categories())</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1168" class="calibre19">





We define a plug that calls our new <span class="cf">Multimedia.list_alphabetical_categories</span> function. We also specify the actions that need the categories in the <span class="cf">when</span> clause. Now, all sorted categories are available inside <span class="cf">@categories</span> in our templates for the actions we specified. You can see how adding our context layer simplifies our controller code.</p>
<p id="calibre_link-1169" class="calibre19">Let’s change the video form template at <span class="cf">lib/rumbl_web/templates/video/form.html.eex</span> to include a new <span class="cf">select</span> field:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/queries/listings/rumbl/lib/rumbl_web/templates/video/form.change1.html.eex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">queries/listings/rumbl/lib/rumbl_web/templates/video/form.change1.html.eex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment">&lt;%=</em>​ label f, ​<em class="string">:category_id</em>​, ​<em class="string">"</em>​​<em class="string">Category"</em>​​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment">&lt;%=</em>​ select f, ​<em class="string">:category_id</em>​, category_select_options(@categories),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">prompt:</em>​ ​<em class="string">"</em>​​<em class="string">Choose a category"</em>​ ​<em class="comment">%&gt;</em>​</td></tr></table>
<p id="calibre_link-1170" class="calibre19">
We added a new select field which builds a list of section options using <span class="cf">category_select_options</span>. Since that function is new, let’s implement it inside our <span class="cf">video</span> view in <span class="cf">lib/rumbl_web/views/video_view.ex</span>, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/queries/listings/rumbl/lib/rumbl_web/views/video_view.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">queries/listings/rumbl/lib/rumbl_web/views/video_view.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ RumblWeb.VideoView ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ RumblWeb, ​<em class="string">:view</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ category_select_options(categories) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    for category &lt;- categories, ​<strong class="kw">do</strong>​: {category.name, category.id}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1171" class="calibre19">







Remember, views are just modules with pure functions. We’ll use the <span class="cf">name</span> as the label for each option in a select, and the <span class="cf">id</span> as the option value, and a simple <span class="cf">for</span> comprehension to walk through the available categories.</p>
<p id="calibre_link-1172" class="calibre19">That’s it. Now we can create videos with optional categories. We’re doing so with query logic that lives in its own module so we’ll be able to better test and extend those features. Try it out by visiting <span class="cf">http://localhost:4000/manage/videos/new</span>:</p><div class="praise"><div class="praise"><img id="calibre_link-1173" class="border5" src="images/000031.png" alt="images/src/queries/category-select.png" width="720" height="720" /></div></div>
<p id="calibre_link-1174" class="calibre19">Before we finish this chapter, we’ll add the proper mechanisms to ensure that the category sent by the user is valid. But first, let’s take this opportunity to explore Ecto queries a little more deeply.




</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-16"><div id="calibre_link-1175" class="calibre2"><h2 id="calibre_link-111" class="calibre20">Diving Deeper into Ecto Queries</h2>
<p id="calibre_link-1176" class="calibre19">
So far, you know Ecto queries like a YouTube dog knows how to ride a bike. We’ve written our first query and  we know that queries compose, but we still haven’t explored many concepts. It’s time to take off the training wheels and see more-advanced examples.</p>
<p id="calibre_link-1177" class="calibre19">


Open up IEx once more, and let’s retrieve a single user:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ ​<strong class="kw">import</strong>​ Ecto.Query</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ alias Rumbl.Repo</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ alias Rumbl.Accounts.User</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ alias Rumbl.Multimedia.Video</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ username = ​<em class="string">"</em>​​<em class="string">josevalim"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">"josevalim"</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Repo.one(from u ​<strong class="kw">in</strong>​ User, ​<em class="string">where:</em>​ u.username == ^username)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%Rumbl.Accounts.User{username: "josevalim", ...}</td></tr></table>
<p id="calibre_link-1178" class="calibre19">We’re using the same concepts you learned before:




</p><ul class="calibre28"><li class="calibre29">
<p id="calibre_link-1179" class="calibre31"><span class="cf1">Repo.one</span> means return one row.</p></li><li class="calibre29">
<p id="calibre_link-1180" class="calibre31"><span class="cf1">from u in User</span> means we’re reading from the <span class="cf1">Accounts.User</span> schema.</p></li><li class="calibre29">
<p id="calibre_link-1181" class="calibre31"><span class="cf1">where: u.username == ^username</span> means return the row where <span class="cf1">u.username == ^username</span>. The <span class="cf1">^</span> (caret) is used for injecting a value or expression for interpolation into an Ecto query</p></li><li class="calibre29">
<p id="calibre_link-1182" class="calibre31">When the <span class="cf1">select</span> part is omitted, the whole struct is returned, as if we’d written <span class="cf1">select: u</span>.</p></li></ul>
<p id="calibre_link-1183" class="calibre19"><span class="calibre4"><span class="cf">Repo.one</span> doesn’t mean “return the first result.”</span> It means “one result is expected, so if there’s more, fail.” This query language is a little different from what you may have seen before. This API is not just a composition of strings. By relying on Elixir macros, Ecto knows where user-defined variables are located, so it’s easier to protect the user from security flaws like SQL-injection attacks.






</p>
<p id="calibre_link-1184" class="calibre19">




Ecto queries also do a good part of the query normalization at compile time, so you’ll see better performance while leveraging the information in our schemas for casting values at runtime. Let’s see some of these concepts in action by using an incorrect type in a query:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ username = 123</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">123</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Repo.all(from u ​<strong class="kw">in</strong>​ User, ​<em class="string">where:</em>​ u.username == ^username)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">**</strong>​ (Ecto.Query.CastError) iex:7: value `123` in `where`</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   cannot be cast to type :string in query:</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">from u in Rumbl.Accounts.User,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  where: u.username == ^123,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  select: u</td></tr></table>
<p id="calibre_link-1185" class="calibre19">The <span class="cf">^</span> operator interpolates values into our queries where Ecto can scrub them and safely put them to use, without the risk of SQL injection. Armed with our schema definition, Ecto is able to cast the values properly for us and match up Elixir types with the expected database types.</p>
<p id="calibre_link-1186" class="calibre19">
In other words, we define the repository and schemas and let Ecto changesets and queries tie them up together. This strategy gives developers the proper level of isolation because we mostly work with data, which is straightforward, and leave all complex operations to the repository.</p><h3 class="calibre22">The Query API</h3>
<p id="calibre_link-1187" class="calibre19">






























So far, we’ve used only the <span class="cf">==</span> operator in queries, but Ecto supports a wide range of them:</p><ul class="calibre28"><li class="calibre29">Comparison operators: <span class="cf1">==</span>, <span class="cf1">!=</span>, <span class="cf1">&lt;=</span>, <span class="cf1">&gt;=</span>, <span class="cf1">&lt;</span>, <span class="cf1">&gt;</span></li><li class="calibre29">Boolean operators: <span class="cf1">and</span>, <span class="cf1">or</span>, <span class="cf1">not</span></li><li class="calibre29">Inclusion operator: <span class="cf1">in</span></li><li class="calibre29">Search functions: <span class="cf1">like</span> and <span class="cf1">ilike</span></li><li class="calibre29">Null check functions: <span class="cf1">is_nil</span></li><li class="calibre29">Aggregates: <span class="cf1">count</span>, <span class="cf1">avg</span>, <span class="cf1">sum</span>, <span class="cf1">min</span>, <span class="cf1">max</span></li><li class="calibre29">Date/time intervals: <span class="cf1">datetime_add</span>, <span class="cf1">date_add</span></li><li class="calibre29">General: <span class="cf1">fragment</span>, <span class="cf1">field</span>, and <span class="cf1">type</span></li></ul>
<p id="calibre_link-1188" class="calibre19">



In short, you can use many of the same comparison, inclusion, search, and aggregate operations for a typical query that you’d use in Elixir. You can see documentation and examples for many of them in the <span class="cf">Ecto.Query.API</span> documentation.<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-217" href="#calibre_link-17">[22]</a></sup> Those are the basic features you’re going to use as you build queries. You’ll use them from two APIs: keywords syntax and pipe syntax. Let’s see what each API looks like.</p><h3 class="calibre22">Writing Queries with Keywords Syntax</h3>
<p id="calibre_link-1189" class="calibre19">
The first syntax expresses different parts of the query by using a keyword list. For example, take a look at this code for counting all users with usernames starting with <span class="cf">j</span> or <span class="cf">c</span>. You can see keys for both <span class="cf">:select</span> and <span class="cf">:where</span>:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">iex&gt; Repo.one from u ​<strong class="kw">in</strong>​ User,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">...&gt;          ​<em class="string">select:</em>​ count(u.id),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">...&gt;          ​<em class="string">where:</em>​ ilike(u.username, ​<em class="string">"</em>​​<em class="string">j%"</em>​) ​<strong class="kw">or</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">...&gt;                 ilike(u.username, ​<em class="string">"</em>​​<em class="string">c%"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">2</td></tr></table>
<p id="calibre_link-1190" class="calibre19">

The <span class="cf">u</span> variable is bound as part of Ecto’s <span class="cf">from</span> macro. Throughout the query, it represents entries from the <span class="cf">User</span> schema. If you attempt to access <span class="cf">u.unknown</span> or match against an invalid type, Ecto raises an error. Bindings are useful when our queries need to join across multiple schemas. Each join in a query gets a specific binding.



</p>
<p id="calibre_link-1191" class="calibre19">Let’s also build a query to count all users:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ users_count = from u ​<strong class="kw">in</strong>​ User, ​<em class="string">select:</em>​ count(u.id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">#Ecto.Query&lt;from u in Rumbl.Accounts.User, select: count(u.id)&gt;</td></tr></table>
<p id="calibre_link-1192" class="calibre19">


Simple enough. We use <span class="cf">from</span> to build a query, selecting <span class="cf">count(u.id)</span>. Now, let’s say that we want to take advantage of this fantastic <span class="cf">count</span> feature to build some more-complex queries. Since the best usernames have a <span class="cf">j</span>, let’s count the users that match a case-insensitive search for <span class="cf">j</span>, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ j_users = from u ​<strong class="kw">in</strong>​ users_count, ​<em class="string">where:</em>​ ilike(u.username, ^​<em class="string">"</em>​​<em class="string">%j%"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">#Ecto.Query&lt;from u in Rumbl.Accounts.User,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"> where: ilike(u.username, ^"%j%"), select: count(u.id)&gt;</td></tr></table>
<p id="calibre_link-1193" class="calibre19">Beautiful. You’ve built a new query, based on the old one. Although we’ve used the same binding as before, <span class="cf">u</span>, we didn’t have to. You’re free to name your query variables however you like, because Ecto doesn’t use their names. The following query is equivalent to the previous one:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ j_users = from q ​<strong class="kw">in</strong>​ users_count, ​<em class="string">where:</em>​ ilike(q.username, ^​<em class="string">"</em>​​<em class="string">%j%"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">#Ecto.Query&lt;from u in Rumbl.Accounts.User,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"> where: ilike(u.username, ^"%j%"), select: count(u.id)&gt;</td></tr></table>
<p id="calibre_link-1194" class="calibre19">You can use that composition wherever you have a query, be it written with the keyword syntax or the pipe syntax that you’ll learn next.</p><h3 class="calibre22">Using Queries with the Pipe Syntax</h3>
<p id="calibre_link-1195" class="calibre19">
Let’s look at some other expressions. For example, let’s build some queries with the Elixir pipe.</p>
<p id="calibre_link-1196" class="calibre19">You’ve seen different query expressions constructed with key-value pairs. You can also build queries by piping through query macros.</p>
<p id="calibre_link-1197" class="calibre19">




Most often, you’ll want to import <span class="cf">from</span> to build up a query against a <span class="cf">queryable</span>, but you can also use other query macros such as <span class="cf">where</span> and <span class="cf">select</span> where it makes sense. Each takes a <span class="cf">queryable</span> and returns a <span class="cf">queryable</span>, so you can pipe them together like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ User \</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​ |&gt; select([u], count(u.id)) \</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​ |&gt; where([u], ilike(u.username, ^​<em class="string">"</em>​​<em class="string">j%"</em>​) ​<strong class="kw">or</strong>​ ilike(u.username, ^​<em class="string">"</em>​​<em class="string">c%"</em>​)) \</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​ |&gt; Repo.one()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[debug] QUERY OK source="users" db=1.9ms</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">SELECT count(u0."id") FROM "users" AS u0 WHERE</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">((u0."username" ILIKE $1) OR (u0."username" ILIKE $2)) ["j%", "c%"]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">2</td></tr></table>
<p id="calibre_link-1198" class="calibre19">

Because each query is independent of others, we need to specify the binding manually for each one as part of a list. This binding is conceptually the same as the one we used in <span class="cf">from u in User</span>. We have a single binding, so we use a list with a single element, but we could use a longer list with more bindings if our query had joins.</p>
<p id="calibre_link-1199" class="calibre19">The query syntax you choose depends on your taste and the problems you’re trying to solve. The former syntax is probably more convenient for pulling together ad-hoc queries and solving one-off problems. The latter is probably better for building an application’s unique complex layered query API. Each approach has its advantages.

</p><h3 class="calibre22">Fragments</h3>
<p id="calibre_link-1200" class="calibre19">

A poorly designed API will break down if it does not provide every feature that you need from the underlying storage you are trying to access. If Ecto gives you everything you need from the database layer beneath, that’s great. If not, you do not have to panic and fork Ecto to build your own mapping layer. Since we cannot represent all possible queries in Elixir’s syntax, we need a backup plan.</p>
<p id="calibre_link-1201" class="calibre19">
A programming truism is that the best abstractions offer an escape hatch, one that exposes the user to one deeper level of abstraction on demand. Ecto has such a feature, called the <span class="calibre4">query fragment</span>. A query fragment sends part of a query directly to the database but allows you to construct the query string in a safe way.</p>
<p id="calibre_link-1202" class="calibre19">

Imagine that you want to look up the user by username in a case-insensitive way. Though Ecto doesn’t give us everything we need, you can access that feature by using an Ecto SQL fragment, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">from u ​<strong class="kw">in</strong>​ User,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">     ​<em class="string">where:</em>​ fragment(​<em class="string">"</em>​​<em class="string">lower(username) = ?"</em>​, ^String.downcase(name))</td></tr></table>
<p id="calibre_link-1203" class="calibre19">


Using a fragment allows us to construct a fragment of SQL for the query but safely interpolate the <span class="cf">String.downcase(name)</span> code using a prepared statement. Whether the interpolated values are Ecto query expressions or SQL fragments, Ecto safely escapes all interpolated values.</p>
<p id="calibre_link-1204" class="calibre19">
When everything else fails and even fragments aren’t enough, you can always run direct SQL with <span class="cf">Ecto.Adapters.SQL.query</span>:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">iex&gt; Ecto.Adapters.SQL.query(Repo, ​<em class="string">"</em>​​<em class="string">SELECT power($1, $2)"</em>​, [2, 10])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[debug] QUERY OK db=2.​<strong class="kw">0</strong>​ms</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">SELECT power(​<strong class="kw">$</strong>​1, ​<strong class="kw">$</strong>​2) [2, 10]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{​<em class="string">:ok</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"> %Postgrex.Result{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   ​<em class="string">columns:</em>​ [​<em class="string">"</em>​​<em class="string">power"</em>​],</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   ​<em class="string">command:</em>​ ​<em class="string">:select</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   ​<em class="string">connection_id:</em>​ 33727,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   ​<em class="string">num_rows:</em>​ 1,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   ​<em class="string">rows:</em>​ [[1024.0]]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"> }}</td></tr></table>
<p id="calibre_link-1205" class="calibre19">From the query result, you can fetch all kinds of information, such as the returned columns, the number of rows, and the result set itself. It’s best to stick to Ecto query expressions wherever possible, but you have a safe escape hatch when you need it.</p><h3 class="calibre22">Querying Relationships</h3>
<p id="calibre_link-1206" class="calibre19">

Ecto queries also offer support for associations. When working with relationships, you learned that Ecto associations are explicit, and we used <span class="cf">Repo.preload</span> to fetch associated data. Let’s recap:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ video = Repo.one(from v ​<strong class="kw">in</strong>​ Video, ​<em class="string">limit:</em>​ 1)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%Rumbl.Multimedia.Video{...}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ video.user</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">#Ecto.Association.NotLoaded&lt;association :user is not loaded&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ video = Repo.preload(video, ​<em class="string">:user</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%Rumbl.Multimedia.Video{...}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ video.user</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%Rumbl.Accounts.User{...}</td></tr></table>
<p id="calibre_link-1207" class="calibre19">

However, we don’t always need to preload associations as a separate step. Ecto allows us to preload associations directly as part of a query, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ video = Repo.one(from v ​<strong class="kw">in</strong>​ Video, ​<em class="string">limit:</em>​ 1,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​           ​<em class="string">preload:</em>​ [​<em class="string">:user</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%Rumbl.Multimedia.Video{...}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ video.user</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%Rumbl.Accounts.User{...}</td></tr></table>
<p id="calibre_link-1208" class="calibre19">


Ecto also allows us to join on associations inside queries, filtering them in any way that makes sense:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Repo.all from v ​<strong class="kw">in</strong>​ Video,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​          ​<em class="string">join:</em>​ u ​<strong class="kw">in</strong>​ assoc(v, ​<em class="string">:user</em>​),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​          ​<em class="string">join:</em>​ c ​<strong class="kw">in</strong>​ assoc(v, ​<em class="string">:category</em>​),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​          ​<em class="string">where:</em>​ c.name == ​<em class="string">"</em>​​<em class="string">Comedy"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...&gt;</span>​          ​<em class="string">select:</em>​ {u, v}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[{%Rumbl.Accounts.User{...}, %Rumbl.Multimedia.Video{...}}]</td></tr></table>
<p id="calibre_link-1209" class="calibre19">This time, Ecto returns users and videos side by side as long as the video belongs to the <span class="cf">Comedy</span> category. We use a tuple in <span class="cf">select</span>, but we could also return each entry in a list, or even a map.</p>
<p id="calibre_link-1210" class="calibre19">We expect that you’ll find plenty of joy when you work with Ecto queries. They’re flexible but also extremely readable. They’re composable enough to flex but also rigid enough to offer type support and security when it comes to interacting with tainted external data. However, not all problems can be solved with queries. Sometimes, you’ll need to use the underlying database to help manage database integrity. For those cases, Ecto provides <span class="calibre4">constraints</span>.
</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-171"><div id="calibre_link-1211" class="calibre2"><h2 id="calibre_link-112" class="calibre20">Constraints</h2>
<p id="calibre_link-1212" class="calibre19">







Constraints allow us to use underlying relational database features to help us maintain database integrity. We used constraints to prevent duplicate categories in our application. There are many other ways we can leverage constraints.</p>
<p id="calibre_link-1213" class="calibre19">For instance, when we create a video, we need to make sure that our category exists. We might be tempted to solve this problem by simply performing a query, but such an approach would be unsafe due to race conditions. In most cases, we would expect it to work like this:</p><ol class="calibre28"><li class="toc-chap">The user sends a category ID through the form.</li><li class="toc-chap">We perform a query to check if the category ID exists in the database.</li><li class="toc-chap">If the category ID does exist in the database, we add the video with the category ID to the database.</li></ol>
<p id="calibre_link-1214" class="calibre19">However, someone could delete the category between steps 2 and 3, allowing us to ultimately insert a video without an existing category in the database. In any sufficiently busy application, that approach <span class="calibre4">will lead to inconsistent data</span> over time. Ecto has relentlessly pushed us to define references and indexes in our database because sometimes, doing a query won’t be enough and we’ll need to rely on database constraints.</p>
<p id="calibre_link-1215" class="calibre19">

In Phoenix, we use constraints to manage change in a way that combines the harsh protections of the database with Ecto’s gentle guiding hand to report errors without crashing.</p>
<p id="calibre_link-1216" class="calibre19">Let’s firm up some terminology before we get too far:</p><dl class="calibre42"><dt class="force-newline"></dt><dt class="force-newline"></dt><dt class="force-newline">constraint</dt><dd class="calibre43">
<p id="calibre_link-1217" class="calibre19">An explicit database constraint. This might be a uniqueness constraint on an index, or an integrity constraint between primary and foreign keys.</p></dd><dt class="force-newline"></dt><dt class="force-newline"></dt><dt class="force-newline">constraint error</dt><dd class="calibre43">
<p id="calibre_link-1218" class="calibre19">The <span class="cf">Ecto.ConstraintError</span>. This happens when Ecto identifies a constraint problem, such as trying to insert a record without specifying a required key.</p></dd><dt class="force-newline"></dt><dt class="force-newline"></dt><dt class="force-newline">changeset constraint</dt><dd class="calibre43">
<p id="calibre_link-1219" class="calibre19">A constraint annotation added to the changeset that allows Ecto to convert constraint errors into changeset error messages.</p></dd><dt class="force-newline"></dt><dt class="force-newline"></dt><dt class="force-newline"></dt><dt class="force-newline">changeset error messages</dt><dd class="calibre43">
<p id="calibre_link-1220" class="calibre19">Beautiful error messages for the consumption of humans.</p></dd></dl>
<p id="calibre_link-1221" class="calibre19">
Relational databases deal with relationships between tables. A database constraint is a mechanism for restricting data in a table based on the needs of an application. For example, a given <span class="cf">user_id</span> must exist as the <span class="cf">id</span> field in a <span class="cf">users</span> table, or an <span class="cf">email</span> field must be unique. Ensuring data is consistent across records is a critical job that all database-backed applications need to handle.</p>
<p id="calibre_link-1222" class="calibre19">Ecto allows developers to enjoy many of the guarantees databases offer in terms of data integrity. In fact, Ecto rewards developers for doing exactly this, both in the short term, by transforming constraint errors into user feedback, and in the long term by guaranteeing you won’t be awake at 3:00 a.m. fixing bugs caused by inconsistent data. In the remainder of this chapter, we’re going to walk you through how Ecto manages constraints.</p><h3 class="calibre22">Validating Unique Data</h3>
<p id="calibre_link-1223" class="calibre19">



When we created the users table, we edited the migration to index the username field as unique:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">create unique_index(​<em class="string">:users</em>​, [​<em class="string">:username</em>​])</td></tr></table>
<p id="calibre_link-1224" class="calibre19">Let’s see what happens if we try to create a user with an existing username (as shown in the <a href="#calibre_link-172" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">figure</a>).</p><div id="calibre_link-172" class="praise"><div class="praise"><img id="calibre_link-1225" class="border7" src="images/000038.png" alt="images/src/queries/constraint-error.png" width="810" height="370" /></div></div>
<p id="calibre_link-1226" class="calibre19">Oops. Our application blows up with a constraint error, similar to the one we saw when creating duplicated categories. If we inspect the error message in the terminal, or in the browser, we see:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[error] #PID&lt;0.403.0&gt; running RumblWeb.Endpoint terminated</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Server: localhost:4000 (http)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Request: POST /users</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">** (exit) an exception was raised:</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ** (Ecto.ConstraintError) constraint error when attempting to insert struct:</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  * unique: users_username_index</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">If you would like to convert this constraint into an error, please</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">call unique_constraint/3 in your changeset and define the proper</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">constraint name. The changeset has not defined any constraint.</td></tr></table>
<p id="calibre_link-1227" class="calibre19">
We have seen <span class="cf">ConstraintErrors</span> before when inserting duplicate categories. For categories, we prevented the error by changing the referential constraints, but for duplicate usernames, we need to inform users filling in the form.</p>
<p id="calibre_link-1228" class="calibre19">The previous error message tells us how to proceed next. It suggests converting the constraint error into a changeset error message by calling <span class="cf">unique_constraint</span> in the changeset.</p>
<p id="calibre_link-1229" class="calibre19">Let’s do that. Open up <span class="cf">lib/rumbl/accounts/user.ex</span> and change the <span class="cf">changeset</span> function:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/queries/listings/rumbl/lib/rumbl/accounts/user.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">queries/listings/rumbl/lib/rumbl/accounts/user.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ changeset(user, attrs) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  user</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; cast(attrs, [​<em class="string">:name</em>​, ​<em class="string">:username</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; validate_required([​<em class="string">:name</em>​, ​<em class="string">:username</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; validate_length(​<em class="string">:username</em>​, ​<em class="string">min:</em>​ 1, ​<em class="string">max:</em>​ 20)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; unique_constraint(​<em class="string">:username</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1230" class="calibre19">
We pipe the changeset into <span class="cf">unique_constraint</span>. By default, Ecto infers the constraint name for us, but it can also be given with the <span class="cf">:name</span> option. Calling <span class="cf">unique_constraint</span> won’t perform any validation on the spot. Instead, it stores all the relevant information in the changeset. When it’s time, the repository can convert those constraints into a human-readable error.</p>
<p id="calibre_link-1231" class="calibre19">Let’s try creating a user with an existing username once again:</p><div class="praise"><img id="calibre_link-1232" class="border4" src="images/000023.png" alt="images/src/queries/constraint-validation.png" width="675" height="601" /></div>
<p id="calibre_link-1233" class="calibre19">Excellent, this is exactly what we expected: a nice, beautiful, human-readable error. <span class="cf">unique_constraint</span> is only one of the different constraint mappings that changesets offer. The next kind of constraint is a foreign-key check.</p>
<p id="calibre_link-1234" class="calibre19">



</p><h3 class="calibre22">Validating Foreign Keys</h3>
<p id="calibre_link-1235" class="calibre19">








After taking some time to appreciate our <span class="cf">unique_constraint</span>, let’s continue with our category relationship. When the user picks a category for the video, we could provide some meaningful feedback if the operation fails. Let’s update our <span class="cf">Video</span> changeset, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/queries/listings/rumbl/lib/rumbl/multimedia/video.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">queries/listings/rumbl/lib/rumbl/multimedia/video.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ changeset(video, attrs) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  video</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; cast(attrs, [​<em class="string">:url</em>​, ​<em class="string">:title</em>​, ​<em class="string">:description</em>​, ​<em class="string">:category_id</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; validate_required([​<em class="string">:url</em>​, ​<em class="string">:title</em>​, ​<em class="string">:description</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; assoc_constraint(​<em class="string">:category</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1236" class="calibre19">
That <span class="cf">assoc_constraint</span> converts foreign-key constraint errors into human-readable error messages and guarantees that a video is created only if the category exists in the database. Taking it for a spin, let’s load some data inside <span class="cf">iex -S mix</span>:


</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ ​<strong class="kw">import</strong>​ Ecto.Query</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ alias Rumbl.Repo</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ alias Rumbl.Multimedia.{Video, Category}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ category = Repo.get_by(Category, ​<em class="string">name:</em>​ ​<em class="string">"</em>​​<em class="string">Drama"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%Rumbl.Multimedia.Category{...}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ video = Repo.one(from v ​<strong class="kw">in</strong>​ Video, ​<em class="string">limit:</em>​ 1)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%Rumbl.Multimedia.Video{...}</td></tr></table>
<p id="calibre_link-1237" class="calibre19">Now let’s use the video changeset to associate the video with the category:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ changeset = Video.changeset(video, %{​<em class="string">category_id:</em>​ category.id})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Repo.update(changeset)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{:ok, %Rumbl.Multimedia.Video{...}}</td></tr></table>
<p id="calibre_link-1238" class="calibre19">We updated our video with a category that exists. The update works, but suppose we tried to update a video with a bad category:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ changeset = Video.changeset(video, %{​<em class="string">category_id:</em>​ 12345})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Repo.update(changeset)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{:error, %Ecto.Changeset{}}</td></tr></table>
<p id="calibre_link-1239" class="calibre19">


Oops. We couldn’t update the video. Let’s inspect the returned changeset further. IEx allows us to fetch a previous value by using <span class="cf">v(n)</span>, where <span class="cf">n</span> is the number of the expression. You can also pass a negative value to grab the last n<sup class="calibre23">th</sup> expression:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ {​<em class="string">:error</em>​, changeset} = v(-1)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ changeset.errors</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[category: {"does not exist", []}]</td></tr></table>
<p id="calibre_link-1240" class="calibre19">As with <span class="cf">unique_constraint</span>, when we set up <span class="cf">assoc_constraint</span>, we no longer get <span class="cf">Ecto.ConstraintError</span>. Instead, they’re converted into changeset error messages.</p>
<p id="calibre_link-1241" class="calibre19">You can try to reproduce this constraint error via our web application in a couple of ways. For example, you could load the page, then remove the category from the database and submit the form after choosing the removed category. If you feel a bit more sneaky, you can fiddle the select options in the browser console, changing their value and then submitting the form.</p>
<p id="calibre_link-1242" class="calibre19">
As we move forward, you’ll see how changesets are an essential part of Ecto. <span class="calibre4">Each changeset encapsulates the whole change policy</span>, including allowed fields, detecting change, validations, and messaging the user.








</p><h3 class="calibre22">On Delete</h3>
<p id="calibre_link-1243" class="calibre19">





Our constraints have helped us insert and update database data safely. They should also apply when we remove data.</p>
<p id="calibre_link-1244" class="calibre19">Let’s open up IEx once more:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ alias Rumbl.Repo</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ alias Rumbl.Multimedia.Category</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ category = Repo.get_by(Category, ​<em class="string">name:</em>​ ​<em class="string">"</em>​​<em class="string">Drama"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%Rumbl.Multimedia.Category{...}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Repo.delete(category)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">**</strong>​ (Ecto.ConstraintError) constraint error when attempting to delete</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">struct</td></tr></table>
<p id="calibre_link-1245" class="calibre19">We pick the <span class="cf">Drama</span> category because we added a video to it in the previous section. A video is tied to the category, so we can’t delete the category because it would leave orphaned records.</p>
<p id="calibre_link-1246" class="calibre19">






We could solve this problem in several ways, described briefly here, that you can explore further on your own. The first one is to use changeset constraints. Like insert and update, <span class="cf">Repo.delete</span> also accepts a changeset, and you can use <span class="cf">foreign_key_constraint</span> to ensure that no associated videos exist when a category is deleted; otherwise you get a nice error message. The <span class="cf">foreign_key_constraint</span> function is like the <span class="cf">assoc_constraint</span> we used earlier, except it doesn’t inflect the foreign key from the relationship. This is particularly useful when you want to show the user why you can’t delete the category:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ ​<strong class="kw">import</strong>​ Ecto.Changeset</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ changeset = change(category)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ changeset = foreign_key_constraint(changeset, ​<em class="string">:videos</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  name: :videos_category_id_fkey, message: "still exist")</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Repo.delete(changeset)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{:error,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"> #Ecto.Changeset&lt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   ...,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   errors: [videos: {"still exist", []}],</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   valid?: false</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"> &gt;}</td></tr></table>
<p id="calibre_link-1247" class="calibre19">
This time, we had to be a bit more explicit in the <span class="cf">foreign_key_constraint</span> call, because the foreign key has been set in the videos table. If needed, we could also add <span class="cf">no_assoc_constraint</span> to do the dirty work of lifting up the foreign-key name and setting a good error message. Check the Ecto docs for more information on <span class="cf">no_assoc_constraint</span> and other changeset constraint mappings.</p>
<p id="calibre_link-1248" class="calibre19">
Second, you could configure the database references to either cascade the deletions or simply make the <span class="cf">videos.category_id</span> columns <span class="cf">NULL</span> on delete. Let’s open up the <span class="cf">add_category_id_to_video</span> migration:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">add ​<em class="string">:category_id</em>​, references(​<em class="string">:categories</em>​)</td></tr></table>
<p id="calibre_link-1249" class="calibre19">
The <span class="cf">references</span> function accepts the <span class="cf">:on_delete</span> option, such as <span class="cf">references(:categories, on_delete: :nothing)</span>, with one of the following:</p><dl class="calibre42"><dt class="force-newline"></dt><dt class="force-newline"><span class="cf1">:nothing</span></dt><dd class="calibre43">
<p id="calibre_link-1250" class="calibre19">The default.</p></dd><dt class="force-newline"></dt><dt class="force-newline"><span class="cf1">:delete_all</span></dt><dd class="calibre43">
<p id="calibre_link-1251" class="calibre19">When the category is deleted, all videos in that category are deleted.</p></dd><dt class="force-newline"></dt><dt class="force-newline"><span class="cf1">:nilify_all</span></dt><dd class="calibre43">
<p id="calibre_link-1252" class="calibre19">When a category is deleted, the <span class="cf">category_id</span> of all associated videos is set to <span class="cf">NULL</span>.</p></dd></dl>
<p id="calibre_link-1253" class="calibre19">

There’s no best option here. For the category, which supports a <span class="cf">has_many :videos</span> relationship, <span class="cf">:nilify_all</span> seems like a good choice, because the category isn’t an essential part of the video. However, when deleting a user, you likely want to delete all the videos created by that user, purging all of the user’s data.</p>
<p id="calibre_link-1254" class="calibre19">


The final choice is to set up <span class="cf">:on_delete</span> when configuring <span class="cf">has_many</span> or <span class="cf">belongs_to</span> relationships in your schema, moving the logic effectively to the application domain. This choice, however, is only recommended when you can’t perform one of the preceding operations. After all, <span class="calibre4">the work best suited to the database must be done in the database</span>.</p><h3 class="calibre22">Let It Crash</h3>
<p id="calibre_link-1255" class="calibre19">




You might be expecting us to proceed to add <span class="cf">*_constraint</span> functions to all of our changesets, ensuring that all failed constraint checks are converted into human-readable error messages.</p>
<p id="calibre_link-1256" class="calibre19">We’re not going to do so, and we shouldn’t. When we added a <span class="cf">foreign_key_constraint</span> to the <span class="cf">video belongs_to :category</span> relationship, we knew we wanted to allow the user to choose the video category later on. If a category is removed at some point between the user loading the page and submitting the request to publish the video, setting the changeset constraint allows us to show a nice error message telling the user to pick something else.</p>
<p id="calibre_link-1257" class="calibre19">This isn’t so uncommon. Maybe you’ve started to publish a new video on Friday at 5:00 p.m. but decide to finish the process next Monday. Someone has the whole weekend to remove a category, making your form data outdated.</p>
<p id="calibre_link-1258" class="calibre19">On the other hand, let’s take the <span class="cf">:video belongs_to :user</span> relationship. Our application is the one responsible for setting up the relationship between videos and users. If a
constraint is violated, it can only be a bug in our application or a data-integrity issue.</p>
<p id="calibre_link-1259" class="calibre19">

In such cases, <span class="calibre4">the user can do nothing to fix the error</span>, so crashing is the best option. Something unexpected really happened. But that’s OK. We know Elixir was designed to handle failures, and Phoenix allows us to convert them into nice status pages. Furthermore, we also recommend setting up a notification system that aggregates and emails errors coming from your application, so you can discover and act on potential bugs when your software is running in production.</p>
<p id="calibre_link-1260" class="calibre19">Putting it another way: the <span class="cf">*_constraint</span> changeset functions are useful when the constraint being mapped is triggered by external data, often as part of the user request. <span class="calibre4">Using changeset constraints only makes sense if the error message can be something the user can take action on</span>.













</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-214"><div id="calibre_link-1261" class="calibre2"><h2 id="calibre_link-113" class="calibre20">Wrapping Up</h2>
<p id="calibre_link-1262" class="calibre19">In this chapter, we pushed Ecto a little harder. We started with queries and went deep into the query API. We explored constraints and how Ecto integrates with the database, ensuring that our data is kept clean and consistent. We also built a category layer. Along the way, you learned many things about the Phoenix philosophy:</p><ul class="calibre28"><li class="calibre29">
<p id="calibre_link-1263" class="calibre31">We learned how to seed data and how to use the <span class="cf1">:on_conflict</span> option to manage data conflicts.</p></li><li class="calibre29">
<p id="calibre_link-1264" class="calibre31">We used Ecto’s query API, which is independent of the repository API, to do some basic queries.</p></li><li class="calibre29">
<p id="calibre_link-1265" class="calibre31">We used two forms of queries, a keyword list&ndash;based syntax and a pipe-based syntax.</p></li><li class="calibre29">
<p id="calibre_link-1266" class="calibre31">We used fragments to pass SQL commands through the query API unchanged.</p></li><li class="calibre29">
<p id="calibre_link-1267" class="calibre31">We explored the different ways Ecto queries work with relationships, beyond data preloading.</p></li><li class="calibre29">
<p id="calibre_link-1268" class="calibre31">We wrote constraint-style validations for unique indexes and foreign-key violations.</p></li><li class="calibre29">
<p id="calibre_link-1269" class="calibre31">We learned how to choose between letting constraint errors go and when to report them to the user.</p></li></ul>
<p id="calibre_link-1270" class="calibre19">Next, you’ll learn how to test everything we’ve seen so far.</p>

<div class="footnotes">
<h4 class="calibre24">Footnotes</h4>
<dl class="calibre25">
<dt class="footnote-number"><a id="calibre_link-302" href="#calibre_link-215" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[20]</a></dt><dd class="calibre26">
<p id="calibre_link-1271" class="calibre27"><a href="https://hexdocs.pm/ecto/Ecto.Repo.html#c:insert/2-upserts" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://hexdocs.pm/ecto/Ecto.Repo.html#c:insert/2-upserts</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-303" href="#calibre_link-216" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[21]</a></dt><dd class="calibre26">
<p id="calibre_link-1272" class="calibre27"><a href="https://hexdocs.pm/iex/IEx.html" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://hexdocs.pm/iex/IEx.html</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-17" href="#calibre_link-217" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[22]</a></dt><dd class="calibre26">
<p id="calibre_link-1273" class="calibre27"><a href="http://hexdocs.pm/ecto/Ecto.Query.API.html" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">http://hexdocs.pm/ecto/Ecto.Query.API.html</a></p></dd></dl></div>
<div class="copyright">Copyright © 2020, The Pragmatic Bookshelf.</div>




</div>



  </div>


<div class="calibre1" id="calibre_link-245"><div id="calibre_link-1274" class="calibre2"><h1 class="pcalibre6 chapter-title" id="calibre_link-114"><span class="chapter-number">
            Chapter
            8</span><br class="calibre18" /><span class="chapter-name">Testing MVC</span></h1>

<p id="calibre_link-1275" class="calibre19">After reading through so many chapters, you might be wondering, “Where are all of the tests?” We strongly believe in writing tests as you go, but such an approach could be repetitive, awkward, and distracting in a book. Rather than present tests as we go, we decided to focus on presenting one concept at a time and save the tests for the end of each part. In this chapter, you’ll see us use techniques to test everything we built in the first part of the book. We might not test every single line of code we’ve written so far, but we’ll cover all of the concepts you’ll need to test everything.</p>
<p id="calibre_link-1276" class="calibre19">






Regardless of what you’re building or the language that you’re using, many testing principles remain the same. Let’s look at some of the principles we’d like to emphasize:</p><ul class="calibre28"><li class="calibre29">
<p id="calibre_link-1277" class="calibre31">Fast: We’re going to make sure our tests run quickly and can run concurrently wherever possible.</p></li><li class="calibre29">
<p id="calibre_link-1278" class="calibre31">Isolated: We want to have the right level of isolation in our tests. Tests that are too isolated won’t have enough context to be useful. Tests that aren’t isolated enough will be difficult to understand and maintain.</p></li><li class="calibre29">
<p id="calibre_link-1279" class="calibre31">DRY (Don’t Repeat Yourself): We want to eliminate unnecessary repetition in our tests.</p></li><li class="calibre29">
<p id="calibre_link-1280" class="calibre31">Repeatable: We want the same test on the same code to always yield the same result.</p></li></ul>
<p id="calibre_link-1281" class="calibre19">
Both the Phoenix platform and Elixir have many features that simplify testing. Clean contracts between layers of the application make it easy to get to the right level of isolation. The focus on immutability, concurrency, and speed will help our tests run quickly. Functional programming will help keep our tests DRY and repeatable.</p>
<p id="calibre_link-1282" class="calibre19">
Before we go too much further, let’s settle on some common terminology, since different testing terms mean different things depending on which framework or language you’re using.</p>
<p id="calibre_link-1283" class="calibre19">

A <span class="calibre4">unit test</span> exercises a function for one layer of your application. For example, if you’re testing a web calculator, unit tests would exercise the <span class="cf">Calculator</span> module supporting your arithmetic. You might dedicate one or more tests to the <span class="cf">add</span> function on your calculator module.</p>
<p id="calibre_link-1284" class="calibre19">
An <span class="calibre4">integration test</span> focuses on the way different layers of an application fit together. Our integration tests in this chapter will generally do a request to a controller to use the things we’ve created so far. A single test will begin at our endpoint, run through our pipelines, read from the database, and render templates through views just as Phoenix requests would.</p>
<p id="calibre_link-1285" class="calibre19">



You may also encounter types of tests that we don’t cover here. For a larger project, you’d also possibly want to test how multiple actions work together. For example, a single <span class="calibre4">acceptance test case</span> might sign the user on, perform several calculations that might build on each other, and then sign off. You might also consider <span class="calibre4">performance testing</span> to see how your application performs under load. In this book, we focus strictly on unit and integration tests.</p>
<p id="calibre_link-1286" class="calibre19">Enough background! We’re going to work through the various layers of our application. We’ll start with some of the tools we can use to run tests and shape the tests we write. Next, we’ll work through some integration tests and then focus on unit-testing the individual components.</p>
<p id="calibre_link-1287" class="calibre19">Let’s get started.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-282"><div id="calibre_link-1288" class="calibre2"><h2 id="calibre_link-115" class="calibre20">Understanding ExUnit</h2>
<p id="calibre_link-1289" class="calibre19">



When you’re testing with Phoenix, the framework builds default tests for you that help you keep the basic structure of your tests straight. Those templates even go a long way toward showing you how to build tests to cover your MVC code.  Still, it’s best to start at the beginning: a walkthrough of using ExUnit, Elixir’s testing framework. Let’s take a look at a basic Elixir test, one without Phoenix involved at all.</p>
<p id="calibre_link-1290" class="calibre19">


ExUnit has three main macros. The <span class="cf">setup</span> macro specifies some setup code that runs once before each test. The <span class="cf">test</span> macro defines a single isolated test. The <span class="cf">assert</span> macro specifies something we believe to be true about our code. If the assertion is true, the test passes. If it’s false, the test fails. Either way, ExUnit reports the results, accumulating a list of failures and exceptions. Let’s use these three macros in a simple test:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ MyTest ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ ExUnit.Case, ​<em class="string">async:</em>​ true</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  setup ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="comment"># run some tedious setup code</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">:ok</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  test ​<em class="string">"</em>​​<em class="string">pass"</em>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    assert true</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  test ​<em class="string">"</em>​​<em class="string">fail"</em>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    assert false</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1291" class="calibre19">This code runs two tests. The first runs the <span class="cf">setup</span> function and then the <span class="cf">pass</span> test. The second again runs the <span class="cf">setup</span> function and then the <span class="cf">fail</span> test. The output will include a passing test and a failing test.</p>
<p id="calibre_link-1292" class="calibre19">




The <span class="cf">async: true</span> flag allows the tests in this module to run concurrently with tests defined in other modules. However, tests in the same module are always executed sequentially, in random order to avoid implicit dependencies between tests.</p>
<p id="calibre_link-1293" class="calibre19">



If you need to know more about Elixir tests, excellent online resources exist, such as the  ExUnit documentation.<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-309" href="#calibre_link-283">[23]</a></sup> For now, let’s move on to specifically testing Phoenix functions.</p><h3 class="calibre22">Using Mix to Run Tests</h3>
<p id="calibre_link-1294" class="calibre19">





Most developers, including the authors of this book, write tests as they build their application, piece by piece. Such a flow works well for a developer’s day, but might seem repetitive when writing a book. In our case, we’re going to write tests at the end of the two main parts of our book. This one captures testing contexts and controllers.</p>
<p id="calibre_link-1295" class="calibre19">

Whether you knew it or not, Phoenix has already been generating default tests for you, such as <span class="cf">test/rumbl_web/controllers/video_controller_test.exs</span>, <span class="cf">test/rumbl/accounts/</span>, and <span class="cf">test/rumbl/multimedia/</span>. You can use those tests to better understand the overall testing philosophy and structure behind Phoenix. We can go ahead and remove those files and directories since they were built for generic functionality, not the features we’ve specifically built into our controller and contexts. We’ve added user authentication, validations, and the like to our videos, so we’ll start fresh with our <span class="cf">VideoController</span> tests. Delete the <span class="cf">test/rumbl_web/controllers/video_controller_test.exs</span> file now, followed by the <span class="cf">test/rumbl/accounts</span> and <span class="cf">test/rumbl/multimedia</span> directories, and then let’s see where our test suite stands:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  1) test GET / (RumblWeb.PageControllerTest)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">     test/rumbl_web/controllers/page_controller_test.exs:4</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">     Assertion with =~ failed</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">     code:  assert html_response(conn, 200) =~ "Welcome to Phoenix!"</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">     left:  "&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">     &lt;meta charset=\"utf-8\"/&gt;\n</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">     &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"/&gt;\n..."</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">     right: "Welcome to Phoenix!"</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">     stacktrace:</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">       test/rumbl_web/controllers/page_controller_test.exs:6: (test)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Finished in 0.09 seconds</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">3 tests, 1 failure</td></tr></table>
<p id="calibre_link-1296" class="calibre19">
We have one basic test that was generated along with the standard Phoenix installation. Since our controller has some changes, the tests fail. Let’s fix that so we can start our test additions clean and green, from a passing state. It looks like we were expecting our “Welcome to Phoenix!” message to exist, but we’ve changed that message along the way. Let’s update the test:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_mvc/listings/rumbl/test/rumbl_web/controllers/page_controller_test.change1.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_mvc/listings/rumbl/test/rumbl_web/controllers/page_controller_test.change1.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">test ​<em class="string">"</em>​​<em class="string">GET /"</em>​, %{​<em class="string">conn:</em>​ conn} ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  conn = get conn, ​<em class="string">"</em>​​<em class="string">/"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assert html_response(conn, 200) =~ ​<em class="string">"</em>​​<em class="string">Welcome to Rumbl.io!"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1297" class="calibre19">Now you can run your test with a better result. This time, let’s run a
single test, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test/rumbl_web/controllers/page_controller_test.exs:4</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Including tags: [line: "4"]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Excluding tags: [:test]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">.</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Finished in 0.07 seconds</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">1 test, 0 failures</td></tr></table>
<p id="calibre_link-1298" class="calibre19">It passes! The page test we just fixed is an integration test because it tests the integration of our basic contexts with the Phoenix features that make it available with the web, page by page. We’ll write plenty of those in a bit. Let’s start with the context and application tests. Then, we’ll test their integration with our web stack.</p><h3 class="calibre22">Creating Test Data</h3>
<p id="calibre_link-1299" class="calibre19">




In this chapter we’re going to write tests for user registration and our video controller. To do so, we need to be able to rapidly create video and user records to support our tests. Let’s create some fixture functions for creating users and videos. Create a <span class="cf">test/support/test_helpers.ex</span> file and key this in:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_mvc/listings/rumbl/test/support/test_helpers.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_mvc/listings/rumbl/test/support/test_helpers.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ Rumbl.TestHelpers ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  alias Rumbl.{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    Accounts,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    Multimedia</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ user_fixture(attrs \\ %{}) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, user} =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      attrs</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      |&gt; Enum.into(%{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">        ​<em class="string">name:</em>​ ​<em class="string">"</em>​​<em class="string">Some User"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">        ​<em class="string">username:</em>​ ​<em class="string">"</em>​​<em class="string">user</em>​​<em class="string">#{</em>​System.unique_integer([​<em class="string">:positive</em>​])​<em class="string">}</em>​​<em class="string">"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">        ​<em class="string">password:</em>​ attrs[​<em class="string">:password</em>​] || ​<em class="string">"</em>​​<em class="string">supersecret"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      })</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      |&gt; Accounts.register_user()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    user</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ video_fixture(%Accounts.User{} = user, attrs \\ %{}) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    attrs =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      Enum.into(attrs, %{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">        ​<em class="string">title:</em>​ ​<em class="string">"</em>​​<em class="string">A Title"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">        ​<em class="string">url:</em>​ ​<em class="string">"</em>​​<em class="string">http://example.com"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">        ​<em class="string">description:</em>​ ​<em class="string">"</em>​​<em class="string">a description"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      })</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, video} = Multimedia.create_video(user, attrs)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    video</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1300" class="calibre19">



We add a <span class="cf">user_fixture</span> function that accepts a map of attributes and creates a persistent user with them. Then, we do the same with a function called <span class="cf">video_fixture</span>. That function must also take the <span class="cf">Accounts.User</span> that created the video. We’ll use this file as a convenient base for common helpers like <span class="cf">user_fixture</span>.</p>
<p id="calibre_link-1301" class="calibre19">Notice that the functions in those two files are extremely thin. They simply integrate with the context features we’ve already written. Such thin functions don’t necessarily mean that your design is right, but it is a data point. By testing, we force our context APIs to satisfy the needs of two clients, both controllers and tests, and that often gives a good sanity check for our designs.</p>
<p id="calibre_link-1302" class="calibre19">

You might be tempted to automatically reach for complex factory libraries, as you would in other languages, or approaches that let you specify fixtures. For simple data with a few well-defined relationships and mostly static attributes, you might find that simple functions work much better. For applications like ours, such an approach has much less ceremony and will serve perfectly well.</p>
<p id="calibre_link-1303" class="calibre19">Keep in mind, though, that absolutes of any kind can get you into trouble. A contract exists between your tests and your test data, whether you choose to make it explicit or not. The best approach is to start slowly with functions. Later, as your needs&mdash;such as faked unique or structured data&mdash;grow, you can decide to adopt a library based on the specific needs of your application. The context is the right place to anchor such data generation clients. Libraries are like macros. Don’t use one when a simple function will do the job.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-2"><div id="calibre_link-1304" class="calibre2"><h2 id="calibre_link-116" class="calibre20">Testing Contexts</h2>
<p id="calibre_link-1305" class="calibre19">







It’s time to test the M of the MVC, models. Phoenix generates a module in <span class="cf">test/support/data_case.ex</span> to serve as a foundation for your tests that interact with the database. In our case, <span class="cf">Accounts</span> and <span class="cf">Multimedia</span> contexts both work with the database. The <span class="cf">data_case</span> handles setup and teardown of the database and integrates with <span class="cf">Ecto.Sandbox</span> to allow concurrent transactional tests. Crack it open and import the fixtures we just defined:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_mvc/listings/rumbl/test/support/data_case.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_mvc/listings/rumbl/test/support/data_case.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ Rumbl.DataCase ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ ExUnit.CaseTemplate</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  using ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">    ​<strong class="kw">quote</strong>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      alias Rumbl.Repo</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      ​<strong class="kw">import</strong>​ Ecto</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      ​<strong class="kw">import</strong>​ Ecto.Changeset</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">      ​<strong class="kw">import</strong>​ Ecto.Query</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      ​<strong class="kw">import</strong>​ Rumbl.DataCase</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      ​<strong class="kw">import</strong>​ Rumbl.TestHelpers </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  setup tags ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<em class="string">:ok</em>​ = Ecto.Adapters.SQL.Sandbox.checkout(Rumbl.Repo)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">unless</strong>​ tags[​<em class="string">:async</em>​] ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">20:&nbsp;</span></td><td class="codeline">      Ecto.Adapters.SQL.Sandbox.mode(Rumbl.Repo, {​<em class="string">:shared</em>​, self()})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<em class="string">:ok</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">25:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ errors_on(changeset) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    Ecto.Changeset.traverse_errors(changeset, ​<strong class="kw">fn</strong>​ {message, opts} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      Regex.replace(​<strong class="kw">~</strong>​r​<em class="string">"</em>​​<em class="string">%{(\w+)}"</em>​, message, ​<strong class="kw">fn</strong>​ _, key -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">        opts |&gt; Keyword.get(String.to_existing_atom(key), key) |&gt; to_string()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">30:&nbsp;</span></td><td class="codeline">      ​<strong class="kw">end</strong>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1306" class="calibre19">




Let’s take a look in more detail.</p>
<p id="calibre_link-1307" class="calibre19">On line 12 we import our test helpers inside the <span class="cf">using</span> block. The <span class="cf">using</span> block serves as a place for defining macros, common imports and aliases. We also see a <span class="cf">setup</span> block for handling transactional tests. A transactional test runs a test and rolls back any changes made during the test. This transactional technique allows tests to reset the database to a known state quickly between tests.</p>
<p id="calibre_link-1308" class="calibre19">



Phoenix also generates an <span class="cf">errors_on</span> function for quickly accessing a list of error messages for attributes on a given schema. You’ll see that function come into play as we write tests for our contexts.</p><h3 class="calibre22">Testing User Accounts</h3>
<p id="calibre_link-1309" class="calibre19">


Let’s start with user account registration. In truth, most context-related functionality will be tested with our integration tests as they insert and update records, but not all. Error and exception flows are some of the trickiest parts of our application to get right. We will explicitly try to catch some error conditions <span class="calibre4">as close to the breaking point as possible</span>. For us, since our context layer is the one that interacts directly with our database code, we’ll build such cases there. Create a new file <span class="cf">test/rumbl/accounts_test.exs</span> that looks like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_mvc/listings/rumbl/test/rumbl/accounts_test.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_mvc/listings/rumbl/test/rumbl/accounts_test.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ Rumbl.AccountsTest ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ Rumbl.DataCase, ​<em class="string">async:</em>​ true </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  alias Rumbl.Accounts</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">  alias Rumbl.Accounts.User</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  describe ​<em class="string">"</em>​​<em class="string">register_user/1"</em>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    @valid_attrs %{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      ​<em class="string">name:</em>​ ​<em class="string">"</em>​​<em class="string">User"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">      ​<em class="string">username:</em>​ ​<em class="string">"</em>​​<em class="string">eva"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      ​<em class="string">password:</em>​ ​<em class="string">"</em>​​<em class="string">secret"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    @invalid_attrs %{}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline">    test ​<em class="string">"</em>​​<em class="string">with valid data inserts user"</em>​ ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      assert {​<em class="string">:ok</em>​, %User{​<em class="string">id:</em>​ id}=user} = Accounts.register_user(@valid_attrs)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      assert user.name == ​<em class="string">"</em>​​<em class="string">User"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      assert user.username == ​<em class="string">"</em>​​<em class="string">eva"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      assert [%User{​<em class="string">id:</em>​ ^id}] = Accounts.list_users()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">20:&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    test ​<em class="string">"</em>​​<em class="string">with invalid data does not insert user"</em>​ ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      assert {​<em class="string">:error</em>​, _changeset} = Accounts.register_user(@invalid_attrs)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      assert Accounts.list_users() == []</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">25:&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    test ​<em class="string">"</em>​​<em class="string">enforces unique usernames"</em>​ ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      assert {​<em class="string">:ok</em>​, %User{​<em class="string">id:</em>​ id}} = Accounts.register_user(@valid_attrs)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      assert {​<em class="string">:error</em>​, changeset} = Accounts.register_user(@valid_attrs)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">30:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      assert %{​<em class="string">username:</em>​ [​<em class="string">"</em>​​<em class="string">has already been taken"</em>​]} =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">             errors_on(changeset)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      assert [%User{​<em class="string">id:</em>​ ^id}] = Accounts.list_users()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">35:&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    test ​<em class="string">"</em>​​<em class="string">does not accept long usernames"</em>​ ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      attrs = Map.put(@valid_attrs, ​<em class="string">:username</em>​, String.duplicate(​<em class="string">"</em>​​<em class="string">a"</em>​, 30))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      {​<em class="string">:error</em>​, changeset} = Accounts.register_user(attrs)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">40:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      assert %{​<em class="string">username:</em>​ [​<em class="string">"</em>​​<em class="string">should be at most 20 character(s)"</em>​]} =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">             errors_on(changeset)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      assert Accounts.list_users() == []</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">45:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    test ​<em class="string">"</em>​​<em class="string">requires password to be at least 6 chars long"</em>​ ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      attrs = Map.put(@valid_attrs, ​<em class="string">:password</em>​, ​<em class="string">"</em>​​<em class="string">12345"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      {​<em class="string">:error</em>​, changeset} = Accounts.register_user(attrs)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">50:&nbsp;</span></td><td class="codeline">      assert %{​<em class="string">password:</em>​ [​<em class="string">"</em>​​<em class="string">should be at least 6 character(s)"</em>​]} =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">         errors_on(changeset)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      assert Accounts.list_users() == []</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">55:&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1310" class="calibre19">


On line 2, we use <span class="cf">Rumbl.DataCase</span> to set up our DB dependent tests. We pass the <span class="cf">async: true</span> option so the test runs concurrently. Then, on lines 15 and 22, we build valid and invalid users and assert the expected results of trying to register a new user account with <span class="cf">Accounts.register_user</span>. In the remaining tests, on lines 37, 46, and 27, our error checking is a bit more intentional. We set a <span class="cf">username</span> that’s too long and <span class="cf">assert</span> that we got a specific error back. Likewise, we set a password that is too short and then test for a specific error.</p>
<p id="calibre_link-1311" class="calibre19">



We close by setting a password that is too short and then test for a specific error. For these tests, we use the <span class="cf">errors_on</span> function defined on <span class="cf">Rumbl.DataCase</span>. <span class="cf">errors_on</span> is convenient for quickly retrieving errors from the <span class="cf">changeset</span>. Keep in mind <span class="cf">errors_on</span> is just a function. You can create a custom version if you need to test custom behavior.</p>
<p id="calibre_link-1312" class="calibre19">Now let’s run our tests:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test/rumbl/accounts_test.exs</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">.......</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Finished in 0.1 seconds</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">5 tests, 0 failures</td></tr></table>
<p id="calibre_link-1313" class="calibre19">All green.</p>
<p id="calibre_link-1314" class="calibre19">






Next, let’s introduce a testing feature in <span class="cf">ExUnit</span> called the <span class="cf">describe</span> block. Sometimes, you need to apply the same setup code to many different tests. Describe blocks allow us to apply different test setups to a whole block of tests. For example, we need a user record to test <span class="cf">Accounts.authenticate_by_username_and_pass</span>, so we create a <span class="cf">describe</span> block with its own setup and three tests, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_mvc/listings/rumbl/test/rumbl/accounts_test.change1.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_mvc/listings/rumbl/test/rumbl/accounts_test.change1.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">describe ​<em class="string">"</em>​​<em class="string">authenticate_by_username_and_pass/2"</em>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  @pass ​<em class="string">"</em>​​<em class="string">123456"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  setup ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, ​<em class="string">user:</em>​ user_fixture(​<em class="string">password:</em>​ @pass)}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  test ​<em class="string">"</em>​​<em class="string">returns user with correct password"</em>​, %{​<em class="string">user:</em>​ user} ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    assert {​<em class="string">:ok</em>​, auth_user} =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">           Accounts.authenticate_by_username_and_pass(user.username, @pass)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    assert auth_user.id == user.id</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline">  test ​<em class="string">"</em>​​<em class="string">returns unauthorized error with invalid password"</em>​, %{​<em class="string">user:</em>​ user} ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    assert {​<em class="string">:error</em>​, ​<em class="string">:unauthorized</em>​} =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">        Accounts.authenticate_by_username_and_pass(user.username, ​<em class="string">"</em>​​<em class="string">badpass"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">20:&nbsp;</span></td><td class="codeline">  test ​<em class="string">"</em>​​<em class="string">returns not found error with no matching user for email"</em>​ ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    assert {​<em class="string">:error</em>​, ​<em class="string">:not_found</em>​} =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">           Accounts.authenticate_by_username_and_pass(​<em class="string">"</em>​​<em class="string">unknownuser"</em>​, @pass)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1315" class="calibre19">Let’s break it down. We start by defining a new describe block on line 4 which creates a user fixture having a hardcoded valid email and password.</p>
<p id="calibre_link-1316" class="calibre19">Next, on line 8, we test that <span class="cf">authenticate_by_username_and_pass</span> returns our user when we provide a correct email and password. Following our valid authentication tests, we then test for the two possibile user authentication failures, a bad password or missing email on lines 15 and 20.</p>
<p id="calibre_link-1317" class="calibre19">Now let’s run our tests again:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test/rumbl/accounts_test.exs</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">.......</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Finished in 0.1 seconds</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">8 tests, 0 failures</td></tr></table>
<p id="calibre_link-1318" class="calibre19">We’re still happily green.


</p><h3 class="calibre22">Testing the Multimedia Context</h3>
<p id="calibre_link-1319" class="calibre19">Let’s test the data access features in our Multimedia context. Create a new file at <span class="cf">test/rumbl/multimedia_test.exs</span> that looks like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_mvc/listings/rumbl/test/rumbl/multimedia_test.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_mvc/listings/rumbl/test/rumbl/multimedia_test.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ Rumbl.MultimediaTest ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ Rumbl.DataCase, ​<em class="string">async:</em>​ true</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  alias Rumbl.Multimedia</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  alias Rumbl.Multimedia.Category</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  describe ​<em class="string">"</em>​​<em class="string">categories"</em>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    test ​<em class="string">"</em>​​<em class="string">list_alphabetical_categories/0"</em>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      for name &lt;- ​<strong class="kw">~</strong>​w(Drama Action Comedy) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">        Multimedia.create_category!(name)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      alpha_names =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">        for %Category{​<em class="string">name:</em>​ name} &lt;-</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">          Multimedia.list_alphabetical_categories() ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">          name</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">        ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      assert alpha_names == ​<strong class="kw">~</strong>​w(Action Comedy Drama)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1320" class="calibre19">We programmatically create categories and later fetch them. Our tests verify that they are in alphabetical order. Now let’s run our tests:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test/rumbl/multimedia_test.exs</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">.</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Finished in 0.07 seconds</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">1 test, 0 failures</td></tr></table>
<p id="calibre_link-1321" class="calibre19">


Success!</p>
<p id="calibre_link-1322" class="calibre19">Everything looks good, so let’s now test the video functions of our Multimedia context, which is a little more involved than the previous tests:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_mvc/listings/rumbl/test/rumbl/multimedia_test.change1.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_mvc/listings/rumbl/test/rumbl/multimedia_test.change1.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">describe ​<em class="string">"</em>​​<em class="string">videos"</em>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  alias Rumbl.Multimedia.Video</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  @valid_attrs %{​<em class="string">description:</em>​ ​<em class="string">"</em>​​<em class="string">desc"</em>​, ​<em class="string">title:</em>​ ​<em class="string">"</em>​​<em class="string">title"</em>​, ​<em class="string">url:</em>​ ​<em class="string">"</em>​​<em class="string">http://local"</em>​}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">  @invalid_attrs %{​<em class="string">description:</em>​ nil, ​<em class="string">title:</em>​ nil, ​<em class="string">url:</em>​ nil}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  test ​<em class="string">"</em>​​<em class="string">list_videos/0 returns all videos"</em>​ ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    owner = user_fixture()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    %Video{​<em class="string">id:</em>​ id1} = video_fixture(owner)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">    assert [%Video{​<em class="string">id:</em>​ ^id1}] = Multimedia.list_videos()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    %Video{​<em class="string">id:</em>​ id2} = video_fixture(owner)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    assert [%Video{​<em class="string">id:</em>​ ^id1}, %Video{​<em class="string">id:</em>​ ^id2}] = Multimedia.list_videos()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline">  test ​<em class="string">"</em>​​<em class="string">get_video!/1 returns the video with given id"</em>​ ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    owner = user_fixture()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    %Video{​<em class="string">id:</em>​ id} = video_fixture(owner)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    assert %Video{​<em class="string">id:</em>​ ^id} = Multimedia.get_video!(id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">20:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">   test ​<em class="string">"</em>​​<em class="string">create_video/2 with valid data creates a video"</em>​ ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">     owner = user_fixture()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">     assert {​<em class="string">:ok</em>​, %Video{} = video} =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">25:&nbsp;</span></td><td class="codeline">       Multimedia.create_video(owner, @valid_attrs)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">     assert video.description == ​<em class="string">"</em>​​<em class="string">desc"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">     assert video.title == ​<em class="string">"</em>​​<em class="string">title"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">     assert video.url == ​<em class="string">"</em>​​<em class="string">http://local"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">30:&nbsp;</span></td><td class="codeline">   ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">   test ​<em class="string">"</em>​​<em class="string">create_video/2 with invalid data returns error changeset"</em>​ ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">     owner = user_fixture()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">     assert {​<em class="string">:error</em>​, %Ecto.Changeset{}} =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">35:&nbsp;</span></td><td class="codeline">       Multimedia.create_video(owner, @invalid_attrs)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">   ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">   test ​<em class="string">"</em>​​<em class="string">update_video/2 with valid data updates the video"</em>​ ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">     owner = user_fixture()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">40:&nbsp;</span></td><td class="codeline">     video = video_fixture(owner)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">     assert {​<em class="string">:ok</em>​, video} =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">       Multimedia.update_video(video, %{​<em class="string">title:</em>​ ​<em class="string">"</em>​​<em class="string">updated title"</em>​})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">     assert %Video{} = video</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">     assert video.title == ​<em class="string">"</em>​​<em class="string">updated title"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">45:&nbsp;</span></td><td class="codeline">   ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">   test ​<em class="string">"</em>​​<em class="string">update_video/2 with invalid data returns error changeset"</em>​ ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">     owner = user_fixture()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">     %Video{​<em class="string">id:</em>​ id} = video = video_fixture(owner)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">50:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">     assert {​<em class="string">:error</em>​, %Ecto.Changeset{}} =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">       Multimedia.update_video(video, @invalid_attrs)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">     assert %Video{​<em class="string">id:</em>​ ^id} = Multimedia.get_video!(id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">55:&nbsp;</span></td><td class="codeline">   ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">   test ​<em class="string">"</em>​​<em class="string">delete_video/1 deletes the video"</em>​ ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">     owner = user_fixture()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">     video = video_fixture(owner)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">60:&nbsp;</span></td><td class="codeline">     assert {​<em class="string">:ok</em>​, %Video{}} = Multimedia.delete_video(video)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">     assert Multimedia.list_videos() == []</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">   ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">   test ​<em class="string">"</em>​​<em class="string">change_video/1 returns a video changeset"</em>​ ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">65:&nbsp;</span></td><td class="codeline">     owner = user_fixture()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">     video = video_fixture(owner)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">     assert %Ecto.Changeset{} = Multimedia.change_video(video)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">   ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1323" class="calibre19">We started by grouping our tests together with a new describe block for testing video functionality. On line 7, we create a video, picking off the <span class="cf">id</span> field with a pattern match. When we fetch a video, we verify correctness by matching against the <span class="cf">id</span> key of the <span class="cf">Video</span> record. Then, we do the same with a second video record. This test handles fetching a list of videos. Next, on line 15, we test the <span class="cf">get_video</span> function.  We use the same technique to fetch a single video using <span class="cf">get_video</span>.</p>
<p id="calibre_link-1324" class="calibre19">Next, on line 21 and 32 we test creation of videos with both valid and invalid user input. We verify a few attributes for the valid test and match against an error tuple for the invalid one. We’re specifically testing our change set functionality. We used a similar approach to test video updates on lines 38 and 47.</p>
<p id="calibre_link-1325" class="calibre19">



Next, we tested <span class="cf">delete_video</span>. We ran assertions to verify both the <span class="cf">:ok</span> tuple and that the video no longer exists on a subsequent fetch.</p>
<p id="calibre_link-1326" class="calibre19">Finally, we checked out the ability to return a changeset for tracking video changes on line  64. These tests cover a lot of ground, but they’re quite simple.</p>
<p id="calibre_link-1327" class="calibre19">Now let’s run our tests:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test/rumbl/multimedia_test.exs</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">.........</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Finished in 0.2 seconds</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">9 tests, 0 failures</td></tr></table>
<p id="calibre_link-1328" class="calibre19">As expected, they are all green. Before we write more tests, let’s take a short break and talk about the Ecto Sandbox.






</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-44"><div id="calibre_link-1329" class="calibre2"><h2 id="calibre_link-117" class="calibre20">Using Ecto Sandbox for Test Isolation and Concurrency</h2>
<p id="calibre_link-1330" class="calibre19">







We mentioned that <span class="cf">DataCase</span> uses some aliases, imports, and macros to give us the functionality our tests need. One of the features that file provides is the <span class="calibre4">Ecto Sandbox</span>. The role of the sandbox is to undo all changes we have done to the database during our tests. These database transaction rollbacks give us test isolation.</p>
<p id="calibre_link-1331" class="calibre19">The way the sandbox operates is quite efficient too: instead of deleting all of the data once the suite finishes, which would be expensive, it just wraps each test in a transaction. Once the test is done, the transaction is rolled back and everything behaves as if the data was never there.</p>
<p id="calibre_link-1332" class="calibre19">




While a database sandbox is commonplace in many web frameworks or database libraries, what sets the Ecto Sandbox apart is that it enables <span class="calibre4">concurrent testing within the same database</span>. In other words, you can run multiple tests that interact with the database at the same time, and they won’t affect each other. <span class="calibre4">This is a big deal</span> since most developers must make compromises between slow tests that sequentially hit the DB and “fast” tests that stub out all DB calls altogether. With the Ecto Sandbox, we can make full use of the database and still use all of our machine resources, making sure the test suite runs as fast as it possibly can. We can do all of this without having to manage multiple database instances.</p>
<p id="calibre_link-1333" class="calibre19">
Note, however, that tests do not run concurrently by default. In order to enable concurrency, we need to pass the <span class="cf">async: true</span> true option when using <span class="cf">Rumbl.DataCase</span>, which is exactly what we have done in both <span class="cf">AccountsTest</span> and <span class="cf">MultimediaTest</span>:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ Rumbl.AccountsTest ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ Rumbl.DataCase, ​<em class="string">async:</em>​ true</td></tr></table>
<p id="calibre_link-1334" class="calibre19">Then back in <span class="cf">Rumbl.DataCase</span>, Phoenix defines a setup block that configures the sandbox for us:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_mvc/rumbl/test/support/data_case.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_mvc/rumbl/test/support/data_case.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">setup tags ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">2:&nbsp;</span></td><td class="codeline">  ​<em class="string">:ok</em>​ = Ecto.Adapters.SQL.Sandbox.checkout(Rumbl.Repo) </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">3:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">4:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">unless</strong>​ tags[​<em class="string">:async</em>​] ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">    Ecto.Adapters.SQL.Sandbox.mode(Rumbl.Repo, {​<em class="string">:shared</em>​, self()}) </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">6:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">7:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">8:&nbsp;</span></td><td class="codeline">  ​<em class="string">:ok</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">9:&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1335" class="calibre19">On line 2, we check out a connection from the sandbox. The sandbox wraps the connection in a transaction which is automatically rolled back at the end of the test. Then we check if the test is running asynchronously. If the test is not asynchronous, we make sure the connection is shared across all processes on line 5. We are going to see a use case for sharing the connection in Chapter 13, <a href="#calibre_link-45" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">​<em class="calibre4">Testing Channels and OTP</em>​</a>.</p>
<p id="calibre_link-1336" class="calibre19">


 You can find out more about how the sandbox works by checking out the Hex documentation.<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-310" href="#calibre_link-46">[24]</a></sup> Now let’s move on to views and controllers.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-195"><div id="calibre_link-1337" class="calibre2"><h2 id="calibre_link-118" class="calibre20">Integration Tests</h2>
<p id="calibre_link-1338" class="calibre19">

We’ve begun by testing our contexts. Since our contexts deal with database-backed applications, those tests checked the way we created, deleted, fetched, and updated data from the database. We also paid special attention to how we processed changes and errors. Our context API exposed those features through changesets.</p>
<p id="calibre_link-1339" class="calibre19">


Now it’s time to shift to integration tests. One of our basic principles for testing is isolation, but that doesn’t mean that the most extreme isolation is always the right answer. The interactions among parts of your software are the very things that make it interesting. When you test your Phoenix applications, getting the right level of isolation is critical. Sometimes, a function is the perfect level of isolation. Sometimes, though, you’ll want to run a test that encompasses multiple layers of your application. This is the realm of the integration test.</p>
<p id="calibre_link-1340" class="calibre19">






Fortunately, we have a natural architectural barrier that enforces the perfect balance. We’re going to fully test the route through the endpoint, as a real web request will do. That way, we’ll execute each plug and pick up all of the little transformations that occur along the way. We won’t have to do any complex test setup, and we won’t have any mismatch between the ways the tests and production server use our application. We’ll make sure our controller actions return success, redirect, or error codes as they should. We will test the behaviors we expect for authorization.
To top it off, testing through the endpoint is superfast, so we pay virtually no penalty.</p><h3 class="calibre22">Warming Up with the Page Controller</h3>
<p id="calibre_link-1341" class="calibre19">Let’s get started. Start by opening <span class="cf">test/rumbl_web/controllers/page_controller_test.exs</span> to take another look:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_mvc/rumbl/test/rumbl_web/controllers/page_controller_test.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_mvc/rumbl/test/rumbl_web/controllers/page_controller_test.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ RumblWeb.PageControllerTest ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ RumblWeb.ConnCase</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  test ​<em class="string">"</em>​​<em class="string">GET /"</em>​, %{​<em class="string">conn:</em>​ conn} ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    conn = get conn, ​<em class="string">"</em>​​<em class="string">/"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    assert html_response(conn, 200) =~ ​<em class="string">"</em>​​<em class="string">Welcome to Rumbl.io!"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1342" class="calibre19">



This test is pretty sparse, but let’s see what we can glean. Notice <span class="cf">RumblWeb.ConnCase</span>. Phoenix adds a <span class="cf">test/support/conn_case.ex</span> file to each new project. That file extends <span class="cf">Phoenix.ConnTest</span> to provide the services your test suite will need to run locally. It will help your tests set up connections, call your endpoints with specific routes and the like. Open <span class="cf">RumblWeb.ConnCase</span> to see what’s provided by default:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_mvc/rumbl/test/support/conn_case.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_mvc/rumbl/test/support/conn_case.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ RumblWeb.ConnCase ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ ExUnit.CaseTemplate</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  using ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">quote</strong>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<em class="comment"># Import conveniences for testing with connections</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<strong class="kw">use</strong>​ Phoenix.ConnTest</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      alias RumblWeb.Router.Helpers, ​<em class="string">as:</em>​ Routes</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<em class="comment"># The default endpoint for testing</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      @endpoint RumblWeb.Endpoint</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  setup tags ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">:ok</em>​ = Ecto.Adapters.SQL.Sandbox.checkout(Rumbl.Repo)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">unless</strong>​ tags[​<em class="string">:async</em>​] ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      Ecto.Adapters.SQL.Sandbox.mode(Rumbl.Repo, {​<em class="string">:shared</em>​, self()})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, ​<em class="string">conn:</em>​ Phoenix.ConnTest.build_conn()}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1343" class="calibre19">


As you’d expect, we use <span class="cf">Phoenix.ConnTest</span> to set up that API. Next, it imports convenient aliases we’ll use throughout our tests. Finally, it sets the <span class="cf">@endpoint</span> module attribute, which is required for <span class="cf">Phoenix.ConnTest</span>. This attribute lets Phoenix know which endpoint to call when you directly call a route in your tests.</p>
<p id="calibre_link-1344" class="calibre19">



Also notice our <span class="cf">setup</span> block. It sets up the Ecto Sandbox, as in <span class="cf">DataCase</span>, but the last line here is different. It returns <span class="cf">{:ok, conn: ...}</span>, which places a base <span class="cf">conn</span> into our test metadata, which flows into our <span class="cf">page_controller_test</span> as an optional second argument to the <span class="cf">test</span> macro.</p>
<p id="calibre_link-1345" class="calibre19">These small bits of code let Phoenix tests use real endpoints, pipelines, and <span class="cf">Plug.Conn</span> connections that pass through your application code, just as the Phoenix framework would. After all, these are integration tests that should use the same paths production code uses whenever possible.</p>
<p id="calibre_link-1346" class="calibre19">For example, in your <span class="cf">page_controller_test</span>, we called our controller with <span class="cf">get conn, "/"</span> rather than calling the <span class="cf">index</span> action on our controller directly. This practice ensures that we’re testing the router and pipelines because we’re using the controller the same way Phoenix does.</p>
<p id="calibre_link-1347" class="calibre19">

Phoenix also gives us some helpers to test responses and keep our tests clean, such as the assertion from <span class="cf">page_controller_test</span>:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">assert html_response(conn, 200) =~ ​<em class="string">"</em>​​<em class="string">Welcome to Rumbl.io!"</em>​</td></tr></table>
<p id="calibre_link-1348" class="calibre19">



These functions pack a lot of punch in a single function call. The simple statement <span class="cf">html_response(conn, 200)</span> does the following:</p><ul class="calibre28"><li class="calibre29">Asserts that the conn’s response was <span class="cf1">200</span></li><li class="calibre29">Asserts that the response <span class="cf1">content-type</span> was <span class="cf1">text/html</span></li><li class="calibre29">Returns the response body, allowing us to match on the contents</li></ul>
<p id="calibre_link-1349" class="calibre19">

If our request had been a JSON response, we could have used another response assertion called <span class="cf">json_response</span> to match on any field of a response body. For example, you might write a <span class="cf">json_response</span> assertion like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">assert %{​<em class="string">user_id:</em>​ ^user_id} = json_response(conn, 200)</td></tr></table>
<p id="calibre_link-1350" class="calibre19">Keep in mind <span class="cf">RumblWeb.ConnCase</span> is just a foundation. You can personalize it to your own application as needed. Let’s learn more about integration tests by writing our own VideoController tests from scratch, starting with the actions available while logged out.</p><h3 class="calibre22">Testing Logged-Out Users</h3>
<p id="calibre_link-1351" class="calibre19">








We will need to create data so we will add factory helpers to our application so we can use <span class="cf">user_fixture</span> and <span class="cf">video_fixture</span>. Add <span class="cf">import Rumbl.TestHelpers</span> to your <span class="cf">ConnCase</span> <span class="cf">using</span> block to bring in our helpers in all our connection-related tests, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_mvc/listings/rumbl/test/support/conn_case.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_mvc/listings/rumbl/test/support/conn_case.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">using ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">quote</strong>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<em class="comment"># Import conveniences for testing with connections</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">use</strong>​ Phoenix.ConnTest</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">    ​<strong class="kw">import</strong>​ Rumbl.TestHelpers </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    alias RumblWeb.Router.Helpers, ​<em class="string">as:</em>​ Routes</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<em class="comment"># The default endpoint for testing</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    @endpoint RumblWeb.Endpoint</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1352" class="calibre19">With our fixture functions accessible, we can start testing our <span class="cf">VideoController</span>. Create a file called <span class="cf">test/rumbl_web/controllers/video_controller_test.exs</span> and make it look like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_mvc/listings/rumbl/test/rumbl_web/controllers/video_controller_test.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_mvc/listings/rumbl/test/rumbl_web/controllers/video_controller_test.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ RumblWeb.VideoControllerTest ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ RumblWeb.ConnCase, ​<em class="string">async:</em>​ true</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  test ​<em class="string">"</em>​​<em class="string">requires user authentication on all actions"</em>​, %{​<em class="string">conn:</em>​ conn} ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    Enum.each([</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      get(conn, Routes.video_path(conn, ​<em class="string">:new</em>​)),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      get(conn, Routes.video_path(conn, ​<em class="string">:index</em>​)),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      get(conn, Routes.video_path(conn, ​<em class="string">:show</em>​, ​<em class="string">"</em>​​<em class="string">123"</em>​)),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      get(conn, Routes.video_path(conn, ​<em class="string">:edit</em>​, ​<em class="string">"</em>​​<em class="string">123"</em>​)),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      put(conn, Routes.video_path(conn, ​<em class="string">:update</em>​, ​<em class="string">"</em>​​<em class="string">123"</em>​, %{})),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      post(conn, Routes.video_path(conn, ​<em class="string">:create</em>​, %{})),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      delete(conn, Routes.video_path(conn, ​<em class="string">:delete</em>​, ​<em class="string">"</em>​​<em class="string">123"</em>​)),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ], ​<strong class="kw">fn</strong>​ conn -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      assert html_response(conn, 302)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      assert conn.halted</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1353" class="calibre19">




Since our video controller is locked behind user authentication, we want to make sure that our authentication pipeline halts every action. Since all of those tests are the same except for the routes, we use <span class="cf">Enum.each</span> to iterate over all of the routes we want, and we make the same assertion for each response. Since we’re verifying a halted connection that kicks logged-out visitors back to the home page, we assert a <span class="cf">html_response</span> of <span class="cf">302</span>.</p>
<p id="calibre_link-1354" class="calibre19">Let’s try our tests out:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test/rumbl_web</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">....</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Finished in 0.1 seconds</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">4 tests, 0 failures</td></tr></table>
<p id="calibre_link-1355" class="calibre19">And they pass. Now that we’ve tested all routes as logged-out users, we need to check the behavior as logged-in users.



</p><h3 class="calibre22">Preparing for Logged-In Users</h3>
<p id="calibre_link-1356" class="calibre19">


You might be tempted to place the <span class="cf">user_id</span> in the session for the <span class="cf">Auth</span> plug to pick up, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">conn()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">|&gt; fetch_session()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">|&gt; put_session(​<em class="string">:user_id</em>​, user.id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">|&gt; get(​<em class="string">"</em>​​<em class="string">/videos"</em>​)</td></tr></table>
<p id="calibre_link-1357" class="calibre19">This approach is a little messy because it assumes an implementation. We don’t want to store anything directly in the session, because we don’t want to leak implementation details. Alternatively, we could do a direct request to the session controller every time we want to log in. However, this would quickly become expensive, because most tests will require a logged-in user. There’s a better way.</p>
<p id="calibre_link-1358" class="calibre19">







Instead, we choose to test our login mechanism in isolation and build a bypass mechanism for the rest of our test cases. We simply pass any <span class="cf">user</span> through in our <span class="cf">conn.assigns</span> as a pass-through for our <span class="cf">Auth</span> plug. Update your <span class="cf">web/controllers/auth.ex</span>, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_mvc/listings/rumbl/lib/rumbl_web/controllers/auth.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_mvc/listings/rumbl/lib/rumbl_web/controllers/auth.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ call(conn, _opts) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  user_id = get_session(conn, ​<em class="string">:user_id</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">cond</strong>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    conn.assigns[​<em class="string">:current_user</em>​] -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    user = user_id &amp;&amp; Rumbl.Accounts.get_user(user_id) -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      assign(conn, ​<em class="string">:current_user</em>​, user)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    true -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      assign(conn, ​<em class="string">:current_user</em>​, nil)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1359" class="calibre19">

We’ve rewritten our <span class="cf">call</span> function using <span class="cf">cond</span> to check for multiple conditions, with our new condition at the top.  Its sole job is to match on the <span class="cf">current_user</span> already in place in the assigns. If we see that we already have a <span class="cf">current_user</span>, we return the connection as is.</p>
<p id="calibre_link-1360" class="calibre19">Let’s be clear. What we’re doing here is controversial. We’re adding this code to make our implementation more testable. We think the trade-off is worth it. We are <span class="calibre4">improving the contract</span>. If a <span class="cf">user</span> is in the <span class="cf">conn.assigns</span>, we honor it, no matter how it got there. We have an improved testing story that doesn’t require us to write mocks or any other elaborate scaffolding.</p>
<p id="calibre_link-1361" class="calibre19">Now, all of our tests for logged-in users will be much cleaner.</p><h3 class="calibre22">Testing Logged-In Users</h3>
<p id="calibre_link-1362" class="calibre19">Now, we’re free to add tests. We add a new test for <span class="cf">/videos</span> to <span class="cf">test/rumbl_web/controllers/video_controller_test.exs</span>, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_mvc/listings/rumbl/test/rumbl_web/controllers/video_controller_test.change1.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_mvc/listings/rumbl/test/rumbl_web/controllers/video_controller_test.change1.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">setup %{​<em class="string">conn:</em>​ conn, ​<em class="string">login_as:</em>​ username} ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  user = user_fixture(​<em class="string">username:</em>​ username)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  conn = assign(conn, ​<em class="string">:current_user</em>​, user)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {​<em class="string">:ok</em>​, ​<em class="string">conn:</em>​ conn, ​<em class="string">user:</em>​ user}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">test ​<em class="string">"</em>​​<em class="string">lists all user's videos on index"</em>​, %{​<em class="string">conn:</em>​ conn, ​<em class="string">user:</em>​ user} ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  user_video  = video_fixture(user, ​<em class="string">title:</em>​ ​<em class="string">"</em>​​<em class="string">funny cats"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  other_video = video_fixture(</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    user_fixture(​<em class="string">username:</em>​ ​<em class="string">"</em>​​<em class="string">other"</em>​),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">title:</em>​ ​<em class="string">"</em>​​<em class="string">another video"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  conn = get conn, Routes.video_path(conn, ​<em class="string">:index</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assert html_response(conn, 200) =~ ​<em class="string">~r/Listing Videos/</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assert String.contains?(conn.resp_body, user_video.title)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  refute String.contains?(conn.resp_body, other_video.title)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1363" class="calibre19">







In our <span class="cf">setup</span> block, we seed a user to the database by using our <span class="cf">user_fixture</span> helper function. <span class="cf">ConnCase</span> takes care of running our tests in isolation. Any seeded fixtures in the database will be wiped between test blocks.</p>
<p id="calibre_link-1364" class="calibre19">However, our new setup block causes the previous tests to break, because they expect a connection without a logged-in user. To fix our failing tests, let’s use describe blocks and tags.</p><h3 class="calibre22">Using Tags</h3>
<p id="calibre_link-1365" class="calibre19">





Some of our tests require logging in and some don’t. Let’s wrap our new test case in a describe block to allow setup for only logged-in users. We’ll also use a <span class="cf">:login_as</span> tag to specify which user we’d like to log in. Tagging allows you to mark specific tests with attributes you can use later. You can access these attributes from the test context blocks. Tests outside of the describe block will then skip the login requirement:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_mvc/listings/rumbl/test/rumbl_web/controllers/video_controller_test.change2.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_mvc/listings/rumbl/test/rumbl_web/controllers/video_controller_test.change2.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">describe ​<em class="string">"</em>​​<em class="string">with a logged-in user"</em>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  setup %{​<em class="string">conn:</em>​ conn, ​<em class="string">login_as:</em>​ username} ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    user = user_fixture(​<em class="string">username:</em>​ username)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">    conn = assign(conn, ​<em class="string">:current_user</em>​, user)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, ​<em class="string">conn:</em>​ conn, ​<em class="string">user:</em>​ user}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">  @tag ​<em class="string">login_as:</em>​ ​<em class="string">"</em>​​<em class="string">max"</em>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  test ​<em class="string">"</em>​​<em class="string">lists all user's videos on index"</em>​, %{​<em class="string">conn:</em>​ conn, ​<em class="string">user:</em>​ user} ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    user_video  = video_fixture(user, ​<em class="string">title:</em>​ ​<em class="string">"</em>​​<em class="string">funny cats"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    other_video = video_fixture(</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      user_fixture(​<em class="string">username:</em>​ ​<em class="string">"</em>​​<em class="string">other"</em>​),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline">      ​<em class="string">title:</em>​ ​<em class="string">"</em>​​<em class="string">another video"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    conn = get conn, Routes.video_path(conn, ​<em class="string">:index</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    response = html_response(conn, 200)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    assert response =~ ​<em class="string">~r/Listing Videos/</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">20:&nbsp;</span></td><td class="codeline">    assert response =~ user_video.title</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    refute response =~ other_video.title</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1366" class="calibre19">We wrapped our setup block and video listing tests in a new describe block. Then, on line 10, we add a <span class="cf">:login_as</span> tag with our username. We consume that <span class="cf">:login_as</span> tag on line 3. Since Ex::Unit passes tags along with the test context, we can simply match on the tag, grabbing the value opposite the <span class="cf">:login_as</span> tag as <span class="cf">username</span>.</p>
<p id="calibre_link-1367" class="calibre19">


The <span class="cf">tag</span> module attribute accepts a keyword list or an atom. Passing an atom is a shorthand way to set flag style options. For example <span class="cf">@tag :logged_in</span> is equivalent to <span class="cf">@tag logged_in: true</span>. We rewrite our <span class="cf">setup</span> block to grab the <span class="cf">config</span> map, which holds our metadata with the <span class="cf">conn</span> and tags which we use to populate our user fixture.</p>
<p id="calibre_link-1368" class="calibre19">Our tests now pass, because they only seed the database when necessary. We can also use the tags to run tests only matching a particular tag, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test/rumbl_web</strong>​​<strong class="kw"> </strong>​​<strong class="kw">--only</strong>​​<strong class="kw"> </strong>​​<strong class="kw">login_as</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Including tags: [:login_as]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Excluding tags: [:test]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">.</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Finished in 0.1 seconds</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">5 tests, 0 failures, 4 skipped</td></tr></table>
<p id="calibre_link-1369" class="calibre19">Perfect. In short, we’ll use tags anywhere we want to mark attributes for a block of tests and describes to scope setups to a block of tests. Our tests now exercise the video listing, but we still haven’t used the controller to create a video. Let’s build a test to create a video, making sure to define the new code <span class="calibre4">inside</span> our logged-in describe block like this:
</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_mvc/listings/rumbl/test/rumbl_web/controllers/video_controller_test.change3.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_mvc/listings/rumbl/test/rumbl_web/controllers/video_controller_test.change3.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">alias Rumbl.Multimedia</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">@create_attrs %{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="string">url:</em>​ ​<em class="string">"</em>​​<em class="string">http://youtu.be"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="string">title:</em>​ ​<em class="string">"</em>​​<em class="string">vid"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="string">description:</em>​ ​<em class="string">"</em>​​<em class="string">a vid"</em>​}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">@invalid_attrs %{​<em class="string">title:</em>​ ​<em class="string">"</em>​​<em class="string">invalid"</em>​}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defp</strong>​ video_count, ​<strong class="kw">do</strong>​: Enum.count(Multimedia.list_videos())</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">@tag ​<em class="string">login_as:</em>​ ​<em class="string">"</em>​​<em class="string">max"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">test ​<em class="string">"</em>​​<em class="string">creates user video and redirects"</em>​, %{​<em class="string">conn:</em>​ conn, ​<em class="string">user:</em>​ user} ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  create_conn =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    post conn, Routes.video_path(conn, ​<em class="string">:create</em>​), ​<em class="string">video:</em>​ @create_attrs</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assert %{​<em class="string">id:</em>​ id} = redirected_params(create_conn)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assert redirected_to(create_conn) ==</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    Routes.video_path(create_conn, ​<em class="string">:show</em>​, id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  conn = get conn, Routes.video_path(conn, ​<em class="string">:show</em>​, id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assert html_response(conn, 200) =~ ​<em class="string">"</em>​​<em class="string">Show Video"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assert Multimedia.get_video!(id).user_id == user.id</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">@tag ​<em class="string">login_as:</em>​ ​<em class="string">"</em>​​<em class="string">max"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">test ​<em class="string">"</em>​​<em class="string">does not create vid, renders errors when invalid"</em>​, %{​<em class="string">conn:</em>​ conn} ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  count_before = video_count()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  conn =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    post conn, Routes.video_path(conn, ​<em class="string">:create</em>​), ​<em class="string">video:</em>​ @invalid_attrs</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assert html_response(conn, 200) =~ ​<em class="string">"</em>​​<em class="string">check the errors"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assert video_count() == count_before</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1370" class="calibre19">

In this example, we want to test the successful and unsuccessful paths for creating a video. To keep things clear and easy to understand, we create some module attributes for both valid and invalid changesets. This touch keeps our intentions clear. With one tweak, we can keep our tests DRY so changes in validations require only trivial adjustments to our controller tests. We’ll have another set of tests we can use to fully handle our changesets, but for now this strategy will work fine.</p>
<p id="calibre_link-1371" class="calibre19">

Next, we create the test case for the successful case. We use the <span class="cf">create</span> route with our valid attributes and then <span class="cf">assert</span> that we’re returning the right values and redirecting to the right place. Then, we confirm that our test impacts the database in the ways we expect. We don’t need to test all of the attributes, but we should pay attention to the elements of this operation that are likely to break. We <span class="cf">assert</span> that our new record exists and has the correct owner. This test makes sure that our happy path is indeed happy.</p>
<p id="calibre_link-1372" class="calibre19">

Writing negative integration tests is a delicate balance. We don’t want to cover all possible failure conditions, as those must be fully covered when unit testing the context. Instead, we’re handling concerns we choose to expose to the user, especially those that change the flow of our code. We test the case of trying to create an invalid video, the redirect, error messages, and so on.</p>
<p id="calibre_link-1373" class="calibre19">


Our other persistence tests will follow much the same approach. You can find the full CRUD test listing in the downloadable source code for the book.<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-311" href="#calibre_link-196">[25]</a></sup></p>
<p id="calibre_link-1374" class="calibre19">


As you recall, we left a hole in our code coverage when we worked around authentication. Let’s shift gears and handle the authorization cases of our controller. We must test that other users cannot view, edit, update, or destroy videos of another user. Crack open our test case and key this in. Remember, since we’re not logged in, we want to add this test outside of our logged-in describe block:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_mvc/listings/rumbl/test/rumbl_web/controllers/video_controller_test.change4.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_mvc/listings/rumbl/test/rumbl_web/controllers/video_controller_test.change4.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">test ​<em class="string">"</em>​​<em class="string">authorizes actions against access by other users"</em>​, %{​<em class="string">conn:</em>​ conn} ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  owner = user_fixture(​<em class="string">username:</em>​ ​<em class="string">"</em>​​<em class="string">owner"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  video = video_fixture(owner, @create_attrs)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  non_owner = user_fixture(​<em class="string">username:</em>​ ​<em class="string">"</em>​​<em class="string">sneaky"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  conn = assign(conn, ​<em class="string">:current_user</em>​, non_owner)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assert_error_sent ​<em class="string">:not_found</em>​, ​<strong class="kw">fn</strong>​ -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    get(conn, Routes.video_path(conn, ​<em class="string">:show</em>​, video))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assert_error_sent ​<em class="string">:not_found</em>​, ​<strong class="kw">fn</strong>​ -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    get(conn, Routes.video_path(conn, ​<em class="string">:edit</em>​, video))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assert_error_sent ​<em class="string">:not_found</em>​, ​<strong class="kw">fn</strong>​ -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    put(conn, Routes.video_path(conn, ​<em class="string">:update</em>​, video, ​<em class="string">video:</em>​ @create_attrs))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assert_error_sent ​<em class="string">:not_found</em>​, ​<strong class="kw">fn</strong>​ -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    delete(conn, Routes.video_path(conn, ​<em class="string">:delete</em>​, video))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1375" class="calibre19">





That test does a lot, so let’s break it down. First we create a new user to act as the <span class="cf">owner</span> for a video. Then, we set up our <span class="cf">conn</span> to log in a newly created user named <span class="cf">sneaky</span>, one that doesn’t own our existing video. Using descriptive variable names in tests can provide that extra bit of documentation to make your test’s intentions clear.</p>
<p id="calibre_link-1376" class="calibre19">
We use the same approach we used when we tested the basic path without logging in. In this case, the context is raising the <span class="cf">Ecto.NoResultsError</span>, since there is no video with the given ID associated to the given user. Instead of letting this error blow up in the user’s face, there is a protocol between Plug and Ecto where Plug is told to treat all <span class="cf">Ecto.NoResultsError</span> as a 404 response status, which we can also refer to as <span class="cf">:not_found</span>. We use a new function called <span class="cf">assert_error_sent</span> to test precisely that an error happened but it became a 404 when handled by Phoenix.</p>
<p id="calibre_link-1377" class="calibre19">Though we don’t cover every controller action, these test cases provide a pretty good cross section for the overall approach. For practice, you can use these techniques to round out our integration tests.</p>
<p id="calibre_link-1378" class="calibre19">


As we work from the top down, we have one plug that we extracted into its own module, since it plays a critical role across multiple sections of our application. We’ll test that plug next, in isolation. We’re going to adhere to our principle for getting the right level of isolation.







</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-241"><div id="calibre_link-1379" class="calibre2"><h2 id="calibre_link-119" class="calibre20">Unit-Testing Plugs</h2>
<p id="calibre_link-1380" class="calibre19">





If your code is worth writing, it’s worth testing. Earlier, we bypassed our authentication plug, so we should test it now. The good news is that since our plug is essentially a function, it’s relatively easy to build a set of tests that will confirm that it does what we need.</p>
<p id="calibre_link-1381" class="calibre19">Create a <span class="cf">test/rumbl_web/controllers/auth_test.exs</span> and key in the following contents. We’re going to break the test file into parts to keep things simple.</p>
<p id="calibre_link-1382" class="calibre19">
First, test the <span class="cf">authenticate_user</span> function that does the lion’s share of the work:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_mvc/listings/rumbl/test/rumbl_web/controllers/auth_test.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_mvc/listings/rumbl/test/rumbl_web/controllers/auth_test.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ RumblWeb.AuthTest ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ RumblWeb.ConnCase, ​<em class="string">async:</em>​ true</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  alias RumblWeb.Auth</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  test ​<em class="string">"</em>​​<em class="string">authenticate_user halts when no current_user exists"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">       %{​<em class="string">conn:</em>​ conn} ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    conn = Auth.authenticate_user(conn, [])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    assert conn.halted</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  test ​<em class="string">"</em>​​<em class="string">authenticate_user for existing current_user"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">       %{​<em class="string">conn:</em>​ conn} ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    conn =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      |&gt; assign(​<em class="string">:current_user</em>​, %Rumbl.Accounts.User{})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      |&gt; Auth.authenticate_user([])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    refute conn.halted</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1383" class="calibre19">That’s as simple as it gets. If we try to authenticate without a user, we shouldn’t authenticate. Otherwise, we should.</p>
<p id="calibre_link-1384" class="calibre19">Let’s run that much to make sure things continue to work:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test/rumbl_web/controllers/auth_test.exs</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">.</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">1)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">test authenticate_user halts when no current_user exists (RumblWeb.AuthTest)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">test/rumbl_web/controllers/auth_test.exs:5</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">** (KeyError) key :current_user not found in: %{}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">code: conn = Auth.authenticate_user(conn, [])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">stacktrace:</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  (rumbl) lib/rumbl_web/controllers/auth.ex:47: Auth.authenticate_user/2</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  test/rumbl_web/controllers/auth_test.exs:8: (test)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Finished in 0.05 seconds</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">2 tests, 1 failure</td></tr></table>
<p id="calibre_link-1385" class="calibre19">That was surprising. What happened?</p>
<p id="calibre_link-1386" class="calibre19">Since our <span class="cf">Auth</span> plug assumes that a <span class="cf">:current_user</span> assign exists in the connection, the test errors.</p>
<p id="calibre_link-1387" class="calibre19">Let’s try to quickly fix this by injecting a nil <span class="cf">:current_user</span> in our first test case, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">conn =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; assign(​<em class="string">:current_user</em>​, nil)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; Auth.authenticate_user([])</td></tr></table>
<p id="calibre_link-1388" class="calibre19">Now let’s rerun the tests:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test/rumbl_web/controllers/auth_test.exs</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">1)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">test authenticate_user halts when no current_user exists (RumblWeb.AuthTest)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">test/rumbl_web/controllers/auth_test.exs:5</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">** (ArgumentError) flash not fetched, call fetch_flash/2</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">code: |&gt; Auth.authenticate_user([])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">stacktrace:</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  (phoenix) lib/phoenix/controller.ex:1265: Phoenix.Controller.get_flash/1</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  (phoenix) lib/phoenix/controller.ex:1247: Phoenix.Controller.put_flash/3</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  (rumbl) lib/rumbl_web/controllers/auth.ex:51: Auth.authenticate_user/2</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  test/rumbl_web/controllers/auth_test.exs:11: (test)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Finished in 0.06 seconds</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">2 tests, 1 failure</td></tr></table>
<p id="calibre_link-1389" class="calibre19">

Another error.</p>
<p id="calibre_link-1390" class="calibre19">It looks like our <span class="cf">authenticate_user</span> raised an error because it puts a message in the flash, which isn’t available. If you look at the <span class="cf">:browser</span> pipeline in the router, you see that it plugs <span class="cf">fetch_flash</span> to set up the flash.</p>
<p id="calibre_link-1391" class="calibre19">So let’s do the same:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">conn =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  conn()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; fetch_flash()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; Auth.authenticate_user([])</td></tr></table>
<p id="calibre_link-1392" class="calibre19">We receive a <span class="cf">** (ArgumentError) session not fetched, call fetch_session/2</span> error. We could attempt to solve this one too, but we would get yet another error about the <span class="cf">Plug.Session</span> not being configured.</p>
<p id="calibre_link-1393" class="calibre19">




The issue here is that we want to unit test <span class="cf">authenticate_user</span> but it depends on other functionality from the Plug pipeline. These are the kinds of issues that integration testing through the endpoint avoids.</p>
<p id="calibre_link-1394" class="calibre19">We could reimplement our whole endpoint and router pipeline in order to test <span class="cf">authenticate_user</span> but Phoenix gives us another option. For unit tests, Phoenix includes a <span class="cf">bypass_through</span> test helper that allows us to do a request that goes through the whole pipeline but bypasses the router dispatch. This approach gives you a connection wired up with all the transformations your specific tests require, such as fetching the session and adding flash messages:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_mvc/listings/rumbl/test/rumbl_web/controllers/auth_test.change1.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_mvc/listings/rumbl/test/rumbl_web/controllers/auth_test.change1.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">setup %{​<em class="string">conn:</em>​ conn} ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  conn =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; bypass_through(RumblWeb.Router, ​<em class="string">:browser</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; get(​<em class="string">"</em>​​<em class="string">/"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {​<em class="string">:ok</em>​, %{​<em class="string">conn:</em>​ conn}}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">test ​<em class="string">"</em>​​<em class="string">authenticate_user halts when no current_user exists"</em>​, %{​<em class="string">conn:</em>​ conn} ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  conn = Auth.authenticate_user(conn, [])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assert conn.halted</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">test ​<em class="string">"</em>​​<em class="string">authenticate_user for existing current_user"</em>​, %{​<em class="string">conn:</em>​ conn} ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  conn =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; assign(​<em class="string">:current_user</em>​, %Rumbl.Accounts.User{})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; Auth.authenticate_user([])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  refute conn.halted</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1395" class="calibre19">

We add a <span class="cf">setup</span> block, which calls <span class="cf">bypass_through</span>, passing our router and the <span class="cf">:browser</span> pipeline to invoke. Then we perform a request with <span class="cf">get</span>, which accesses the endpoint and stops at the browser pipeline, as requested. The path given to <span class="cf">get</span> isn’t used by the router when bypassing; it’s simply stored in the connection. This gives us all the requirements for a plug with a valid session and flash message support. Next, we pull the <span class="cf">conn</span> from the context passed to the <span class="cf">test</span> macro and use our bypassed <span class="cf">conn</span> as the base for our test blocks.</p>
<p id="calibre_link-1396" class="calibre19">Now let’s rerun our tests:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test/rumbl_web/controllers/auth_test.exs</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">..</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Finished in 0.08 seconds</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">2 tests, 0 failures</td></tr></table>
<p id="calibre_link-1397" class="calibre19">


And boom. Now test the rest of our <span class="cf">Auth</span> plug, like the <span class="cf">login</span> and <span class="cf">logout</span> features:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_mvc/listings/rumbl/test/rumbl_web/controllers/auth_test.change2.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_mvc/listings/rumbl/test/rumbl_web/controllers/auth_test.change2.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">test ​<em class="string">"</em>​​<em class="string">login puts the user in the session"</em>​, %{​<em class="string">conn:</em>​ conn} ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  login_conn =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; Auth.login(%Rumbl.Accounts.User{​<em class="string">id:</em>​ 123})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; send_resp(​<em class="string">:ok</em>​, ​<em class="string">"</em>​​<em class="string">"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  next_conn = get(login_conn, ​<em class="string">"</em>​​<em class="string">/"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assert get_session(next_conn, ​<em class="string">:user_id</em>​) == 123</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1398" class="calibre19">

Here, we test our ability to log in. We create a new connection called <span class="cf">login_conn</span>. We take a basic <span class="cf">conn</span>, log the user in with <span class="cf">Auth.login</span>, and call <span class="cf">send_resp</span>, which sends the response to the client with a given status and response body. To make sure that our new user survives the next request, we make a new request with that connection and make sure the user is still in the session. That’s easy enough. A test for <span class="cf">logout</span> is similar:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_mvc/listings/rumbl/test/rumbl_web/controllers/auth_test.change2.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_mvc/listings/rumbl/test/rumbl_web/controllers/auth_test.change2.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">test ​<em class="string">"</em>​​<em class="string">logout drops the session"</em>​, %{​<em class="string">conn:</em>​ conn} ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  logout_conn =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; put_session(​<em class="string">:user_id</em>​, 123)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; Auth.logout()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; send_resp(​<em class="string">:ok</em>​, ​<em class="string">"</em>​​<em class="string">"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  next_conn = get(logout_conn, ​<em class="string">"</em>​​<em class="string">/"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  refute get_session(next_conn, ​<em class="string">:user_id</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1399" class="calibre19">We create a connection, put a <span class="cf">user_id</span> into our session, and then call <span class="cf">Auth.logout</span>. To make sure the logout will persist through a request, we then make a request with <span class="cf">get</span>, and finally make sure that no <span class="cf">user_id</span> is in the session.</p>
<p id="calibre_link-1400" class="calibre19">
Now, let’s test the main interface for our plug&mdash;the <span class="cf">call</span> function, which calls the plug directly to wire up the <span class="cf">current_user</span> from the session:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_mvc/listings/rumbl/test/rumbl_web/controllers/auth_test.change3.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_mvc/listings/rumbl/test/rumbl_web/controllers/auth_test.change3.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">test ​<em class="string">"</em>​​<em class="string">call places user from session into assigns"</em>​, %{​<em class="string">conn:</em>​ conn} ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  user = user_fixture()  </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  conn =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">    |&gt; put_session(​<em class="string">:user_id</em>​, user.id)  </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    |&gt; Auth.call(Auth.init([]))  </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  assert conn.assigns.current_user.id == user.id</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">test ​<em class="string">"</em>​​<em class="string">call with no session sets current_user assign to nil"</em>​, %{​<em class="string">conn:</em>​ conn} ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  conn = Auth.call(conn, Auth.init([]))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  assert conn.assigns.current_user == nil</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1401" class="calibre19">The tests are simple and light. On line 2, we create a user for the test. Next, on line 5, we place that user’s ID in the session. On line 6, we call <span class="cf">Auth.call</span>, and then assert that the <span class="cf">current_user</span> in <span class="cf">conn.assigns</span> matches our seeded user. We know that <span class="calibre4">logged-in users can get in</span>.</p>
<p id="calibre_link-1402" class="calibre19">
We have a workable positive test, but it’s also important to test the negative condition. We want to make sure that <span class="calibre4">logged-out users stay out</span>. The test looks a lot like the positive test, but we never put any user in the session, and we match on <span class="cf">nil</span> instead.</p>
<p id="calibre_link-1403" class="calibre19">Now let’s run our new tests:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test/rumbl_web/controllers/auth_test.exs</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">.........</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Finished in 1.9 seconds</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">9 tests, 0 failures</td></tr></table>
<p id="calibre_link-1404" class="calibre19">

All pass, but if you look closely, we have a problem. We are waiting two seconds for nine small tests. The test time is growing quickly. You have probably been noticing how the test times have crept up as we have seeded more and more users. If your tests are slow, you won’t run them as much. We have to fix it.</p>
<p id="calibre_link-1405" class="calibre19">




The reason our tests are slow is that we seed users with our registration changeset, which hashes passwords. Hashing passwords is intentionally expensive. Doing this extra bit of work makes our passwords harder to crack, but we don’t need all of that security in the test environment.</p>
<p id="calibre_link-1406" class="calibre19">Let’s ease up the number of hashing rounds to speed up our test suite by adding this configuration line to <span class="cf">config/test.exs</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_mvc/listings/rumbl/config/test.change1.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_mvc/listings/rumbl/config/test.change1.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">config ​<em class="string">:pbkdf2_elixir</em>​, ​<em class="string">:rounds</em>​, 1</td></tr></table>
<p id="calibre_link-1407" class="calibre19">Now let’s rerun our authentication tests:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test/rumbl_web/controllers/auth_test.exs</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">.........</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Finished in 0.1 seconds</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">9 tests, 0 failures</td></tr></table>
<p id="calibre_link-1408" class="calibre19">One-tenth of a second! Time to shift into views.











</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-273"><div id="calibre_link-1409" class="calibre2"><h2 id="calibre_link-120" class="calibre20">Testing Views and Templates</h2>
<p id="calibre_link-1410" class="calibre19">



As we’ve said, any code worth writing is code worth testing, and your views are no exception. As you saw in Chapter 3, <a href="#calibre_link-80" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">​<em class="calibre4">Controllers</em>​</a>, Phoenix templates are simply functions in a parent’s view module. You can test these functions like any other. In this section, you’ll see how to test views and templates in isolation.</p>
<p id="calibre_link-1411" class="calibre19">Create a <span class="cf">test/rumbl_web/views/video_view_test.exs</span> and key this in:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_mvc/listings/rumbl/test/rumbl_web/views/video_view_test.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_mvc/listings/rumbl/test/rumbl_web/views/video_view_test.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ RumblWeb.VideoViewTest ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ RumblWeb.ConnCase, ​<em class="string">async:</em>​ true</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">import</strong>​ Phoenix.View</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">  test ​<em class="string">"</em>​​<em class="string">renders index.html"</em>​, %{​<em class="string">conn:</em>​ conn} ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    videos = [</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      %Rumbl.Multimedia.Video{​<em class="string">id:</em>​ ​<em class="string">"</em>​​<em class="string">1"</em>​, ​<em class="string">title:</em>​ ​<em class="string">"</em>​​<em class="string">dogs"</em>​},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      %Rumbl.Multimedia.Video{​<em class="string">id:</em>​ ​<em class="string">"</em>​​<em class="string">2"</em>​, ​<em class="string">title:</em>​ ​<em class="string">"</em>​​<em class="string">cats"</em>​}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    content = render_to_string(</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      RumblWeb.VideoView,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      ​<em class="string">"</em>​​<em class="string">index.html"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      ​<em class="string">conn:</em>​ conn,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline">      ​<em class="string">videos:</em>​ videos)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    assert String.contains?(content, ​<em class="string">"</em>​​<em class="string">Listing Videos"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    for video &lt;- videos ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">20:&nbsp;</span></td><td class="codeline">      assert String.contains?(content, video.title)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  test ​<em class="string">"</em>​​<em class="string">renders new.html"</em>​, %{​<em class="string">conn:</em>​ conn} ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">25:&nbsp;</span></td><td class="codeline">    owner = %Rumbl.Accounts.User{}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    changeset = Rumbl.Multimedia.change_video(%Rumbl.Multimedia.Video{})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    categories = [%Rumbl.Multimedia.Category{​<em class="string">id:</em>​ 123, ​<em class="string">name:</em>​ ​<em class="string">"</em>​​<em class="string">cats"</em>​}]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    content =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">30:&nbsp;</span></td><td class="codeline">      render_to_string(RumblWeb.VideoView, ​<em class="string">"</em>​​<em class="string">new.html"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">        ​<em class="string">conn:</em>​ conn,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">        ​<em class="string">changeset:</em>​ changeset,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">        ​<em class="string">categories:</em>​ categories</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      )</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">35:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    assert String.contains?(content, ​<em class="string">"</em>​​<em class="string">New Video"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1412" class="calibre19">


Our test needs some videos, so on line 5, we set up our required <span class="cf">@videos</span> assigns. With all of the prerequisites in place, we call <span class="cf">Phoenix.View.render_to_string</span> to render our HTML template as a simple string. Then, we make sure that all of the video titles are present on the page.</p>
<p id="calibre_link-1413" class="calibre19">On line 24, we again set up our necessary <span class="cf">@changeset</span> and <span class="cf">@categories</span> assigns before rendering our template as a string and asserting that our render contents place us on the new video page.</p>
<p id="calibre_link-1414" class="calibre19">Sometimes, views are simple enough that your integration tests will be enough. Many other times, you won’t test the templates directly, but the functions that you create to help move the logic away from the templates and into code. Our goal with this section is to once again highlight the fact that because a template is just a function in the view, templates are easy to test because they aren’t coupled with the controller layer. And this will apply to any function you create in your view, because all arguments are received explicitly. With Phoenix, you’ll have all of the tools you need to do so easily.  We’ve covered a lot of ground so it’s a good time to wrap up.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-308"><div id="calibre_link-1415" class="calibre2"><h2 id="calibre_link-121" class="calibre20">Wrapping Up</h2>
<p id="calibre_link-1416" class="calibre19">With these final tests, we’re finally done. We’ve accomplished a lot.</p>
<p id="calibre_link-1417" class="calibre19">We started by writing some unit tests. The goal of these tests is to check a single layer of our application in isolation. We tested our basic contexts, the user and multimedia contexts. Since both of these contexts provided persistence services, we made sure to exercise the database. The <span class="cf">Ecto.Sandbox</span> preserved isolation and allowed concurrent testing and the <span class="cf">describe</span> keyword allowed us to apply setup code to multiple tests at once, saving duplication. We paid special attention to change sets which surface errors and change tracking through the API.</p>
<p id="calibre_link-1418" class="calibre19">Next we worked with integration tests. The goal of integration tests is to test the layers of our application working together. Our integration tests used not only controller code but also the entire Phoenix pipeline and used actual endpoints to make sure to exercise the whole application stack. We used tagging to specify individual users to create data or log in. We also used Phoenix helpers to make multiple assertions in a compact way. To preserve the entire Plug pipeline, we wrote a bypass to skip only the authentication plugs.</p>
<p id="calibre_link-1419" class="calibre19">Finally, we tested our plugs and views. Since these were simple functions, it was easy and fast to test them.</p>
<p id="calibre_link-1420" class="calibre19">Raise a cheer, because we’re through Part I! You should now be able to use Plug, Ecto, and Phoenix to build traditional request/response features for your application and test each of those concepts.  Part II will be even more exciting, focusing on the features that prompted the creation of Phoenix. You’ll see channels, OTP, and more. Get ready. We’re going to push Phoenix harder.</p>

<div class="footnotes">
<h4 class="calibre24">Footnotes</h4>
<dl class="calibre25">
<dt class="footnote-number"><a id="calibre_link-283" href="#calibre_link-309" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[23]</a></dt><dd class="calibre26">
<p id="calibre_link-1421" class="calibre27"><a href="http://elixir-lang.org/docs/stable/ex_unit/ExUnit.Case.html" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">http://elixir-lang.org/docs/stable/ex_unit/ExUnit.Case.html</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-46" href="#calibre_link-310" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[24]</a></dt><dd class="calibre26">
<p id="calibre_link-1422" class="calibre27"><a href="https://hexdocs.pm/ecto_sql/Ecto.Adapters.SQL.Sandbox.html" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://hexdocs.pm/ecto_sql/Ecto.Adapters.SQL.Sandbox.html</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-196" href="#calibre_link-311" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[25]</a></dt><dd class="calibre26">
<p id="calibre_link-1423" class="calibre27"><a href="http://pragprog.com/book/phoenix/source_code" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">http://pragprog.com/book/phoenix/source_code</a></p></dd></dl></div>
<div class="copyright">Copyright © 2020, The Pragmatic Bookshelf.</div>

</div>



  </div>


<div class="calibre1" id="calibre_link-21"><div id="calibre_link-1424" class="calibre2"><br class="about-pb" />


</div>



  </div>


<div class="calibre1" id="calibre_link-181"><div id="calibre_link-1425" class="calibre2"><h1 class="part-title" id="calibre_link-122"><span class="part-number">Part 2</span><br class="calibre18" />Writing Interactive and Maintainable Applications</h1><blockquote class="partintro" id="calibre_link-1426">
<p id="calibre_link-1427" class="calibre32">In Part II, we’ll explore the features that will help you build a new generation of web applications. You’ll learn to use channels to build highly concurrent interactive applications using a new set of abstractions. Then, you’ll learn to build service layers with the OTP API, the famous Erlang library for building supervised, fault-tolerant services. You’ll manage all of this with Mix, Elixir’s build tool, allowing us to break a single monolithic application into smaller ones, separately maintainable but conveniently integrated. Finally, you’ll learn to test channels and OTP features. You’ll learn to build interactive applications that scale well and are easy to understand.</p></blockquote>


</div>



  </div>


<div class="calibre1" id="calibre_link-234"><div id="calibre_link-1428" class="calibre2"><h1 class="pcalibre6 chapter-title" id="calibre_link-123"><span class="chapter-number">
            Chapter
            9</span><br class="calibre18" /><span class="chapter-name">Watching Videos</span></h1>

<p id="calibre_link-1429" class="calibre19">

We’ve accomplished quite a bit. We’ve built some basic web application features in a short time. We used Plug to build pipelines of functions that let us build organized, DRY code. We used Ecto to deal with our relational database in a functional way, favoring explicitness over hidden behaviors. We also organized our code into contexts to provide the domain API for other layers of our application to use. Phoenix wired it all together into a streamlined workflow, with live reloading, HTML support, and more.</p>
<p id="calibre_link-1430" class="calibre19">Everything we’ve done so far highlights how well Phoenix encourages beautiful and maintainable applications. Those improvements bring a slightly different look to traditional web development, but nothing you’ve seen up to now is drastically different from what you already knew.</p>
<p id="calibre_link-1431" class="calibre19">Now you’re ready to see what makes Phoenix shine. This chapter starts with preparing some common ground by adding a page to watch videos. Then you’ll look into Ecto custom types, which allow you to integrate your own requirements into queries, changesets, and structs. Along the way, we’ll continue to expand our business logic within the Multimedia context, adding new application features one at a time. At the close of this chapter you’ll customize URLs by tapping into the extensible power behind Elixir’s protocols.</p>
<p id="calibre_link-1432" class="calibre19">Tighten your seat belts. This ride will be unforgettable.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-255"><div id="calibre_link-1433" class="calibre2"><h2 id="calibre_link-124" class="calibre20">Watching Videos</h2>
<p id="calibre_link-1434" class="calibre19">

Our <span class="cf">rumbl</span> application will allow us to add messages to videos in real time. We’ll do some groundwork to make this process more convenient when the time comes. We’ll tweak our views to make it easy to watch videos. Then, we’ll create a new controller explicitly for watching a video, along with its view and template. Next, we’ll tweak the router to pick up our new routes. Finally, we’ll add some JavaScript to plug in to YouTube’s API. You’ll work through these features quickly, because they don’t involve much new ground.</p>
<p id="calibre_link-1435" class="calibre19">
Let’s let the user watch a video. First let’s enhance our layout header with a link to My Videos for the current user in <span class="cf">lib/rumbl_web/templates/layout/app.html.eex</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/watching_videos/listings/rumbl/lib/rumbl_web/templates/layout/app.change1.html.eex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">watching_videos/listings/rumbl/lib/rumbl_web/templates/layout/app.change1.html.eex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;nav role=​<em class="string">"navigation"</em>​&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;ul&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="comment">&lt;%=</em>​ ​<strong class="kw">if</strong>​ @current_user ​<strong class="kw">do</strong>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      &lt;li&gt;​<em class="comment">&lt;%=</em>​ @current_user.username ​<em class="comment">%&gt;</em>​&lt;/li&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      &lt;li&gt;​<em class="comment">&lt;%=</em>​ link ​<em class="string">"</em>​​<em class="string">My Videos"</em>​, ​<em class="string">to:</em>​ Routes.video_path(@conn, ​<em class="string">:index</em>​) ​<em class="comment">%&gt;</em>​&lt;/li&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      &lt;li&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">        ​<em class="comment">&lt;%=</em>​ link ​<em class="string">"</em>​​<em class="string">Log out"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">              ​<em class="string">to:</em>​ Routes.session_path(@conn, ​<em class="string">:delete</em>​, @current_user),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">              ​<em class="string">method:</em>​ ​<em class="string">"</em>​​<em class="string">delete"</em>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      &lt;/li&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="comment">&lt;%</em>​ ​<strong class="kw">else</strong>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      &lt;li&gt;​<em class="comment">&lt;%=</em>​ link ​<em class="string">"</em>​​<em class="string">Register"</em>​, ​<em class="string">to:</em>​ Routes.user_path(@conn, ​<em class="string">:new</em>​) ​<em class="comment">%&gt;</em>​&lt;/li&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      &lt;li&gt;​<em class="comment">&lt;%=</em>​ link ​<em class="string">"</em>​​<em class="string">Log in"</em>​, ​<em class="string">to:</em>​ Routes.session_path(@conn, ​<em class="string">:new</em>​) ​<em class="comment">%&gt;</em>​&lt;/li&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="comment">&lt;%</em>​ ​<strong class="kw">end</strong>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;/ul&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;/nav&gt;</td></tr></table>
<p id="calibre_link-1436" class="calibre19">Clicking My Videos routes a logged-in user directly to <span class="cf">VideoController.index</span> action.</p>
<p id="calibre_link-1437" class="calibre19">This action is restricted to the current user, thanks to our scoping rules in the controller. In fact, there’s no public URL we can share with our friends when it comes to watching videos. Let’s address this by creating a <span class="cf">WatchController</span> for watching user videos, available to any user. Create a new <span class="cf">lib/rumbl_web/controllers/watch_controller.ex</span> file and key this in:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/watching_videos/listings/rumbl/lib/rumbl_web/controllers/watch_controller.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">watching_videos/listings/rumbl/lib/rumbl_web/controllers/watch_controller.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ RumblWeb.WatchController ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ RumblWeb, ​<em class="string">:controller</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  alias Rumbl.Multimedia</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ show(conn, %{​<em class="string">"</em>​​<em class="string">id"</em>​ =&gt; id}) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    video = Multimedia.get_video!(id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    render(conn, ​<em class="string">"</em>​​<em class="string">show.html"</em>​, ​<em class="string">video:</em>​ video)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1438" class="calibre19">
Now, let’s create a new template directory for the controller in <span class="cf">lib/rumbl_web/templates/watch</span> and add a new <span class="cf">show.html.eex</span> template file with these contents:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/watching_videos/listings/rumbl/lib/rumbl_web/templates/watch/show.html.eex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">watching_videos/listings/rumbl/lib/rumbl_web/templates/watch/show.html.eex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;div class=​<em class="string">"row"</em>​&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;div class=​<em class="string">"column column-60"</em>​&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    &lt;h1&gt;​<em class="comment">&lt;%=</em>​ @video.title ​<em class="comment">%&gt;</em>​&lt;/h1&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="comment">&lt;%=</em>​ content_tag ​<em class="string">:div</em>​, ​<em class="string">id:</em>​ ​<em class="string">"</em>​​<em class="string">video"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">        ​<em class="string">data:</em>​ [​<em class="string">id:</em>​ @video.id, ​<em class="string">player_id:</em>​ player_id(@video)] ​<strong class="kw">do</strong>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="comment">&lt;%</em>​ ​<strong class="kw">end</strong>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;/div&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;div class=​<em class="string">"column annotations"</em>​&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    &lt;h3&gt;Annotations&lt;/h3&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    &lt;div id=​<em class="string">"msg-container"</em>​&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    &lt;/div&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    &lt;div&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      &lt;textarea id=​<em class="string">"msg-input"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">                rows=​<em class="string">"3"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">                placeholder=​<em class="string">"Comment..."</em>​&gt;&lt;/textarea&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      &lt;button id=​<em class="string">"msg-submit"</em>​ class=​<em class="string">"button column"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">              type=​<em class="string">"submit"</em>​&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">        Post</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      &lt;/button&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    &lt;/div&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;/div&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;/div&gt;</td></tr></table>
<p id="calibre_link-1439" class="calibre19">



The template is mostly markup, with the exception of the title and the video <span class="cf">div</span>, which includes the <span class="cf">id</span>, <span class="cf">data-id</span>, and <span class="cf">data-player-id</span> attributes. We extract the player ID from the video <span class="cf">url</span> field by a function aptly named <span class="cf">player_id</span>. Since templates are just functions in the view module, the view is the perfect place to define such a function.</p>
<p id="calibre_link-1440" class="calibre19">Create a new <span class="cf">lib/rumbl_web/views/watch_view.ex</span> and make it look like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/watching_videos/listings/rumbl/lib/rumbl_web/views/watch_view.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">watching_videos/listings/rumbl/lib/rumbl_web/views/watch_view.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ RumblWeb.WatchView ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ RumblWeb, ​<em class="string">:view</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ player_id(video) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">~</strong>​r{^.*(​<em class="string">?:</em>​youtu\.be/|\w+/|v=)(​<em class="string">?&lt;</em>​id&gt;[^​<em class="comment">#&amp;?]*)}</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; Regex.named_captures(video.url)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; get_in([​<em class="string">"</em>​​<em class="string">id"</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1441" class="calibre19">







Unfortunately, YouTube URLs come in a variety of formats. We need a regular expression to extract the video ID from the URL. Regular expressions are beyond the scope of this book, but here are the basics. A regular expression<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-174" href="#calibre_link-256">[26]</a></sup> uses patterns to match specific patterns within strings. We’re naming a pattern called <span class="cf">id</span> and then piping our expression into a function called <span class="cf">named_captures</span>, which extracts the <span class="cf">id</span> field given our URL name. Then, we build a map that returns the <span class="cf">id</span> key with its value.</p>
<p id="calibre_link-1442" class="calibre19">Finally, let’s add an entry to our router’s <span class="cf">:browser</span> pipeline to the new <span class="cf">WatchController</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/watching_videos/listings/rumbl/lib/rumbl_web/router.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">watching_videos/listings/rumbl/lib/rumbl_web/router.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">scope ​<em class="string">"</em>​​<em class="string">/"</em>​, RumblWeb ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  pipe_through ​<em class="string">:browser</em>​ ​<em class="comment"># Use the default browser stack</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  get ​<em class="string">"</em>​​<em class="string">/"</em>​, PageController, ​<em class="string">:index</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  resources ​<em class="string">"</em>​​<em class="string">/users"</em>​, UserController, ​<em class="string">only:</em>​ [​<em class="string">:index</em>​, ​<em class="string">:show</em>​, ​<em class="string">:new</em>​, ​<em class="string">:create</em>​]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  resources ​<em class="string">"</em>​​<em class="string">/sessions"</em>​, SessionController, ​<em class="string">only:</em>​ [​<em class="string">:new</em>​, ​<em class="string">:create</em>​, ​<em class="string">:delete</em>​]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  get ​<em class="string">"</em>​​<em class="string">/watch/:id"</em>​, WatchController, ​<em class="string">:show</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1443" class="calibre19">

Now let’s change the link for each entry in the My Videos page to point to <span class="cf">watch</span> instead of <span class="cf">show</span>.  Open up <span class="cf">lib/rumbl_web/templates/video/index.html.eex</span> and replace <span class="cf">show</span> with this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/watching_videos/listings/rumbl/lib/rumbl_web/templates/video/index.change1.html.eex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">watching_videos/listings/rumbl/lib/rumbl_web/templates/video/index.change1.html.eex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;table&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;thead&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    &lt;tr&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      &lt;th&gt;Title&lt;/th&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      &lt;th&gt;&lt;/th&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      &lt;th&gt;&lt;/th&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      &lt;th&gt;&lt;/th&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    &lt;/tr&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;/thead&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;tbody&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment">&lt;%=</em>​ for video &lt;- @videos ​<strong class="kw">do</strong>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    &lt;tr&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      &lt;td&gt;​<em class="comment">&lt;%=</em>​ video.title ​<em class="comment">%&gt;</em>​&lt;/td&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      &lt;td&gt;​<em class="comment">&lt;%=</em>​ link ​<em class="string">"</em>​​<em class="string">Edit"</em>​, ​<em class="string">to:</em>​ Routes.video_path(@conn, ​<em class="string">:edit</em>​, video) ​<em class="comment">%&gt;</em>​&lt;/td&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      &lt;td&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">        ​<em class="comment">&lt;%=</em>​ link ​<em class="string">"</em>​​<em class="string">Delete"</em>​, ​<em class="string">to:</em>​ Routes.video_path(@conn, ​<em class="string">:delete</em>​, video),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">                           ​<em class="string">method:</em>​ ​<em class="string">:delete</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">                           ​<em class="string">data:</em>​ [​<em class="string">confirm:</em>​ ​<em class="string">"</em>​​<em class="string">Are you sure?"</em>​] ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      &lt;/td&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      &lt;td&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">        ​<em class="comment">&lt;%=</em>​ link ​<em class="string">"</em>​​<em class="string">Watch"</em>​, ​<em class="string">to:</em>​ Routes.watch_path(@conn, ​<em class="string">:show</em>​, video),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">                          ​<em class="string">class:</em>​ ​<em class="string">"</em>​​<em class="string">button"</em>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      &lt;/td&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    &lt;/tr&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment">&lt;%</em>​ ​<strong class="kw">end</strong>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;/tbody&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;/table&gt;</td></tr></table>
<p id="calibre_link-1444" class="calibre19">
First, we changed the table header to simplify the listing. We trimmed the headings to only the title with three empty headings for our edit, delete, and watch links. To match, we removed our <span class="cf">url</span> and <span class="cf">description</span> columns. We used the <span class="cf">Routes.watch_path</span> helper generated by the new route.</p>
<p id="calibre_link-1445" class="calibre19">Not much exciting is happening here but this early preparation will lead to a great fireworks show later. Now, things will start to get a little more interesting. Let’s add the JavaScript required to let us watch videos.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-291"><div id="calibre_link-1446" class="calibre2"><h2 id="calibre_link-125" class="calibre20">Adding JavaScript</h2>
<p id="calibre_link-1447" class="calibre19">




webpack<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-175" href="#calibre_link-292">[27]</a></sup> is a build tool written in Node.js. We’ll use webpack to build, transform, and minify<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-176" href="#calibre_link-293">[28]</a></sup> JavaScript and CSS code. Processing assets in this way makes your page load much more efficiently. webpack not only takes care of JavaScript but also CSS and all of our application assets, such as images.</p>
<p id="calibre_link-1448" class="calibre19">



The asset structure is laid out in the <span class="cf">assets</span> directory:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">assets/</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">├── css/</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">├── js/</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">├── static/</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">├── vendor/</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">├── package.json</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">└── webpack.config.js</td></tr></table>
<p id="calibre_link-1449" class="calibre19">We put everything in <span class="cf">assets/static</span> that doesn’t need to be transformed by webpack. The build tool will simply copy those static assets just as they are to <span class="cf">priv/static</span>, where they’ll be served by <span class="cf">Plug.Static</span> in our endpoint.</p>
<p id="calibre_link-1450" class="calibre19">
We keep CSS and JavaScript files in their respective directories. The <span class="cf">vendor</span> directory is used to keep any third-party tools you need, such as jQuery. This structure helps us organize code, but we’re also being practical. Let’s see why.</p>
<p id="calibre_link-1451" class="calibre19">Open up <span class="cf">assets/js/app.js</span> and take a look as its contents:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment">// We need to import the CSS so that webpack will load it</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">import</strong>​ css ​<strong class="kw">from</strong>​ ​<em class="string">"../css/app.css"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment">// webpack automatically bundles all modules in your</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment">// entry points. Those entry points can be configured</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment">// in "webpack.config.js".</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment">//</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment">// Import dependencies</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment">//</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">import</strong>​ ​<em class="string">"phoenix_html"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment">// Import local files</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment">// ...</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment">// import socket from "./socket"</em>​</td></tr></table>
<p id="calibre_link-1452" class="calibre19">

Phoenix configures webpack to use ECMAScript 6 (ES6)&mdash;the latest JavaScript specification we’ll use in this book&mdash;to provide the necessary <span class="cf">import</span> statements. webpack wraps the contents for each JavaScript file you add to <span class="cf">assets/js</span> in a function and collects them into <span class="cf">priv/static/js/app.js</span>. That’s the file loaded by browsers at the end of <span class="cf">lib/rumbl_web/templates/layout/app.html.eex</span> when we call <span class="cf">Routes.static_url(@conn, "/js/app.js")</span>.</p>
<p id="calibre_link-1453" class="calibre19">
Since each file is wrapped in a function, it won’t be automatically executed by browsers unless you explicitly import it in your <span class="cf">app.js</span> file. In this way, the <span class="cf">app.js</span> file is like a manifest. It’s where you import and wire up your JavaScript dependencies. For example, we have imported <span class="cf">phoenix_html</span> as it provides some functionality to our HTML forms and buttons.</p>
<p id="calibre_link-1454" class="calibre19">The <span class="cf">assets/vendor</span> directory is the exception to this rule. If you add an external JavaScript file to <span class="cf">assets/vendor</span>, it’ll be automatically concatenated to your <span class="cf">priv/static/app.js</span> bundle and executed when your page loads. That way, external dependencies are never imported and available on the global JavaScript scope, such as <span class="cf">window</span>.</p>
<p id="calibre_link-1455" class="calibre19">


You can configure the webpack tool in the <span class="cf">assets/webpack.config.js</span> file. Take a look at it on your own time. The file is short and simple, so you can easily tell what’s happening.</p>
<p id="calibre_link-1456" class="calibre19">

webpack ships with a command-line tool, and using it is straightforward. You need to know only a few commands:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">webpack</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">webpack</strong>​​<strong class="kw"> </strong>​​<strong class="kw">--watch</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">webpack</strong>​​<strong class="kw"> </strong>​​<strong class="kw">--mode</strong>​​<strong class="kw"> </strong>​​<strong class="kw">production</strong>​</td></tr></table>
<p id="calibre_link-1457" class="calibre19">


Since each of these commands builds your assets for a different context, let’s talk about each in turn. <span class="cf">webpack</span> just compiles the assets into static files and copies the results to <span class="cf">priv/static</span> before exiting. During development as you’re actively working on your JavaScript, you can add the   <span class="cf">-watch</span> option. After you do so, webpack will monitor the files and automatically recompile them as they change. Use the <span class="cf">--mode production</span> flag to do everything you need to generally prepare your JavaScripts and style sheets for production, such as building and minifying them.</p>
<p id="calibre_link-1458" class="calibre19">
In all likelihood, you’ll never type the first couple commands directly, because Phoenix does it for you. If you open up your <span class="cf">config/dev.exs</span>, you see this line:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">watchers: [node: ["node_modules/webpack/bin/webpack.js",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  "--mode", "development", "--watch-stdin", "--colors",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  cd: Path.expand("../assets", __DIR__)]]</td></tr></table>
<p id="calibre_link-1459" class="calibre19">
That code will automatically run <span class="cf">webpack --watch-stdin</span> when your Phoenix app starts in development. The <span class="cf">--watch-stdin</span> option makes the <span class="cf">webpack</span> program abort when Phoenix shuts down.</p>
<p id="calibre_link-1460" class="calibre19">With the webpack introduction out of the way, it’s time to write some JavaScript. First, we’ll create a <span class="cf">Player</span> object to receive the <span class="cf">data-player-id</span> and embed the YouTube video. Later, we’ll use the <span class="cf">Player</span> object to send and receive information about the video so we’ll know exactly when an annotation is added.</p>
<p id="calibre_link-1461" class="calibre19">Create a new file called <span class="cf">assets/js/player.js</span> with these contents:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/watching_videos/listings/rumbl/assets/js/player.js" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">watching_videos/listings/rumbl/assets/js/player.js</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">let</strong>​ Player = {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  player: ​<strong class="kw">null</strong>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  init(domId, playerId, onReady){</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    window.onYouTubeIframeAPIReady = () =&gt; {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<strong class="kw">this</strong>​.onIframeReady(domId, playerId, onReady)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">let</strong>​ youtubeScriptTag = document.createElement(​<em class="string">"script"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    youtubeScriptTag.src = ​<em class="string">"//www.youtube.com/iframe_api"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    document.head.appendChild(youtubeScriptTag)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  },</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  onIframeReady(domId, playerId, onReady){</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">this</strong>​.player = ​<strong class="kw">new</strong>​ YT.Player(domId, {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      height: ​<em class="string">"360"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      width: ​<em class="string">"420"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      videoId: playerId,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      events: {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">        ​<em class="string">"onReady"</em>​:  (event =&gt; onReady(event) ),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">        ​<em class="string">"onStateChange"</em>​: (event =&gt; ​<strong class="kw">this</strong>​.onPlayerStateChange(event) )</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    })</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  },</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  onPlayerStateChange(event){ },</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  getCurrentTime(){ ​<strong class="kw">return</strong>​ Math.floor(​<strong class="kw">this</strong>​.player.getCurrentTime() * 1000) },</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  seekTo(millsec){ ​<strong class="kw">return</strong>​ ​<strong class="kw">this</strong>​.player.seekTo(millsec / 1000) }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">export</strong>​ ​<strong class="kw">default</strong>​ Player</td></tr></table>
<p id="calibre_link-1462" class="calibre19">That’s a fairly long example, so we should break it down piece by piece.</p>
<p id="calibre_link-1463" class="calibre19">

First, we will be creating a <span class="cf">Player</span> object that wires up YouTube’s special <span class="cf">window.onYouTubeIframeAPIReady</span> callback. We inject a YouTube <span class="cf">iframe</span> tag, which will trigger our event when the player is ready.</p>
<p id="calibre_link-1464" class="calibre19">




Next, we implement a <span class="cf">onIframeReady</span> function to create the player with the YouTube iframe API. We finish by adding convenience functions like <span class="cf">getCurrentTime</span> and <span class="cf">seekTo</span>, since we want to bind messages to a point in time for the video playback.</p>
<p id="calibre_link-1465" class="calibre19">




This abstraction is more than a convenient wrapper. It builds an API for video players with the most important features for our application. Our <span class="cf">Player</span> API will insulate us from changes in YouTube and also let us add other video players over time. Our <span class="cf">onYouTubeReady</span> function needs the HTML container ID to hold the <span class="cf">iframe</span>. We’ll pass this in from higher up in our JavaScript stack in a moment.</p><div class="xxxsays"><div class="heading"><div class="persons-picture"><img src="images/000048.png" alt="Chris says:" class="calibre40" /></div><div class="label">Chris says:</div><div class="title">Why webpack?</div></div><div class="praise">
<p id="calibre_link-1466" class="calibre14">

Instead of building yet another asset-build tool, the Phoenix team decided to leverage one of the many tools available in the Node.js ecosystem. webpack is the de facto choice in the Node.js community and the Phoenix team loves its adoption, solid documentation, and minimal out-of-the-box configuration.
</p>
<p id="calibre_link-1467" class="calibre14">




We know this choice might not resonate with all developers, so Phoenix allows you to use the build tool of your choice. Not a single line of code in Phoenix knows about webpack. All the configuration is in your application. You can even skip webpack altogether when creating a new app by using the <span class="cf">--no-webpack</span> option. If you can tell your build tool to compile your static files to <span class="cf">priv/static</span>, you’re good to go. You can even change your <span class="cf">config/dev.exs</span> file so Phoenix sets up a watcher for your favorite tool.
</p></div></div>
<p id="calibre_link-1468" class="calibre19">Our YouTube player is all set, but YouTube’s JavaScript API expects a specific video ID, and all we have is the URL.</p>
<p id="calibre_link-1469" class="calibre19">Remember, our <span class="cf">player.js</span> file won’t be executed unless we import it. Let’s do this in <span class="cf">assets/js/app.js</span> by importing the <span class="cf">Player</span> and starting it with the video and player ID if one exists:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/watching_videos/listings/rumbl/assets/js/app.change1.js" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">watching_videos/listings/rumbl/assets/js/app.change1.js</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">import</strong>​ Player ​<strong class="kw">from</strong>​ ​<em class="string">"./player"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">let</strong>​ video = document.getElementById(​<em class="string">"video"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">if</strong>​(video) {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Player.init(video.id, video.getAttribute(​<em class="string">"data-player-id"</em>​), () =&gt; {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    console.log(​<em class="string">"player ready!"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  })</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">}</td></tr></table>
<p id="calibre_link-1470" class="calibre19">

Next, let’s tidy up our annotations box with a sprinkle of CSS. Create an <span class="cf">assets/css/video.css</span> file and key this in:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/watching_videos/listings/rumbl/assets/css/video.css" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">watching_videos/listings/rumbl/assets/css/video.css</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">.annotations {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  border-left: 1px solid #eaeaea;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">#msg-container</strong>​ {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"> min-height: 260px;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">}</td></tr></table>
<p id="calibre_link-1471" class="calibre19">Now we can import our new <span class="cf">video.css</span> file in <span class="cf">assets/css/app.css</span> so our application can use it, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/watching_videos/listings/rumbl/assets/css/app.change1.css" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">watching_videos/listings/rumbl/assets/css/app.change1.css</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment">/* This file is for your main application css. */</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">@import</strong>​ ​<em class="string">"./phoenix.css"</em>​;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">@import</strong>​ ​<em class="string">"./video.css"</em>​;</td></tr></table>
<p id="calibre_link-1472" class="calibre19">We imported <span class="cf">video.css</span> after <span class="cf">phoenix.css</span>, a style sheet Phoenix includes for default styling.</p>
<p id="calibre_link-1473" class="calibre19">Next, we’ll create a new video with a YouTube URL, and you’re now ready to watch it:</p><div class="praise"><img id="calibre_link-1474" class="border7" src="images/000002.png" alt="images/src/watching_videos/player.png" width="810" height="463" /></div>
<p id="calibre_link-1475" class="calibre19">You can even start sharing the video URL with your friends with a URL that looks like <span class="cf">/watch/13</span>&mdash;but that’s ugly. URLs for videos should use words, not numbers. Let’s fix that.


</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-10"><div id="calibre_link-1476" class="calibre2"><h2 id="calibre_link-126" class="calibre20">Creating Slugs</h2>
<p id="calibre_link-1477" class="calibre19">



We want our videos to have a unique URL-friendly identifier, called a <span class="calibre4">slug</span>. This approach lets us have a unique identifier that will build URLs that are friendlier to people and search engines. We need to create the slug from the title so we can represent a video titled Programming Elixir as a URL-friendly slug, such as <span class="cf">1-programming-elixir</span>, where <span class="cf">1</span> is the video ID.</p>
<p id="calibre_link-1478" class="calibre19">The first step is to add a slug column to the database:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">ecto.gen.migration</strong>​​<strong class="kw"> </strong>​​<strong class="kw">add_slug_to_videos</strong>​</td></tr></table>
<p id="calibre_link-1479" class="calibre19">We generate a new migration. Remember, your name will differ based on the timestamp attached to the front of the file, but you can find the new file in the <span class="cf">priv/repo/migrations</span> directory. Let’s fill it in like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/watching_videos/listings/rumbl/priv/repo/migrations/20180721193825_add_slug_to_videos.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">watching_videos/listings/rumbl/priv/repo/migrations/20180721193825_add_slug_to_videos.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ change ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  alter table(​<em class="string">:videos</em>​) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    add ​<em class="string">:slug</em>​, ​<em class="string">:string</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1480" class="calibre19">



Our new migration uses the <span class="cf">alter</span> macro, which changes the schema for both <span class="cf">up</span> and <span class="cf">down</span> migrations. With the migration in place, let’s apply it to the database:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">ecto.migrate</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] == Running Rumbl.Repo.Migrations.AddSlugToVideos.change/0 forward</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] alter table videos</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] == Migrated in 0.0s</td></tr></table>
<p id="calibre_link-1481" class="calibre19">Next, we need to add the new field to the video schema in <span class="cf">lib/rumbl/multimedia/video.ex</span>, beneath the other fields:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">field ​<em class="string">:slug</em>​, ​<em class="string">:string</em>​</td></tr></table>
<p id="calibre_link-1482" class="calibre19">The whole premise of a slug is that you can automatically generate a permanent field from other fields, some of which may be updatable. Let’s do this by changing the <span class="cf">changeset</span> function, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/watching_videos/listings/rumbl/lib/rumbl/multimedia/video.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">watching_videos/listings/rumbl/lib/rumbl/multimedia/video.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ changeset(video, attrs) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  video</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; cast(attrs, [​<em class="string">:url</em>​, ​<em class="string">:title</em>​, ​<em class="string">:description</em>​, ​<em class="string">:category_id</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; validate_required([​<em class="string">:url</em>​, ​<em class="string">:title</em>​, ​<em class="string">:description</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; assoc_constraint(​<em class="string">:category</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; slugify_title()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defp</strong>​ slugify_title(changeset) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">case</strong>​ fetch_change(changeset, ​<em class="string">:title</em>​) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, new_title} -&gt; put_change(changeset, ​<em class="string">:slug</em>​, slugify(new_title))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">:error</em>​ -&gt; changeset</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defp</strong>​ slugify(str) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  str</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; String.downcase()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  |&gt; String.replace(​<em class="string">~r/[^\w-]+/</em>​u, ​<em class="string">"</em>​​<em class="string">-"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1483" class="calibre19">We modify the generated changeset, just as we did the changeset for the <span class="cf">password</span>. We build the <span class="cf">slug</span> field within our <span class="cf">changeset</span>. The code couldn’t be simpler. The pipe operator makes it easy for us to tell a story with code.</p>
<p id="calibre_link-1484" class="calibre19">





If a change is made to the title, we build a slug based on the new title with the <span class="cf">slugify</span> function. Otherwise, we simply return the changeset. <span class="cf">slugify</span> downcases the string and replaces nonword characters with a <span class="cf">-</span> character. <span class="cf">cast</span>, <span class="cf">assoc_constraint</span>, <span class="cf">fetch_change</span> and <span class="cf">put_change</span> are all functions defined in <span class="cf">Ecto.Changeset</span>, imported at the top of our video module.</p>
<p id="calibre_link-1485" class="calibre19">









Don’t miss the importance of what we’ve done here. We’re once again able to change how data gets into the system, without touching the controller and without using callbacks or any other indirection. All of the changes to be performed by the database are clearly outlined in the changeset. At this point, you’ve learned all the concepts behind changesets, and the benefits are becoming clearer:</p><ul class="calibre28"><li class="calibre29">
<p id="calibre_link-1486" class="calibre31">Because Ecto separates changesets from the definition of a given record, we can have a separate change policy for each type of change. We could easily add a JSON API that creates videos, including the <span class="cf1">slug</span> field, for example.</p></li><li class="calibre29">
<p id="calibre_link-1487" class="calibre31">Changesets filter and cast the incoming data, making sure sensitive fields like a user <span class="cf1">role</span> cannot be set externally, while conveniently casting them to the type defined in the schema.</p></li><li class="calibre29">
<p id="calibre_link-1488" class="calibre31">Changesets can validate data&mdash;for example, the length or the format of a field&mdash;on the fly, but validations that depend on data integrity are left to the database in the shape of constraints.</p></li><li class="calibre29">
<p id="calibre_link-1489" class="calibre31">Changesets make our code easy to understand and implement because they can compose easily, allowing us to specify each part of a change with a function.</p></li></ul>
<p id="calibre_link-1490" class="calibre19">In short, Ecto cleanly encapsulates the concepts of change, and we benefit tremendously as users. Now that we can generate slugs for the videos, let’s make sure we use them in our links.</p><h3 class="calibre22">Extending Phoenix with Protocols</h3>
<p id="calibre_link-1491" class="calibre19">

To use slugs when linking to the video page, let’s open up the <span class="cf">lib/rumbl_web/templates/video/index.html.eex</span> template and see how links are generated:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment">&lt;%=</em>​ link ​<em class="string">"</em>​​<em class="string">Watch"</em>​, ​<em class="string">to:</em>​ Routes.watch_path(@conn, ​<em class="string">:show</em>​, video),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">                  ​<em class="string">class:</em>​ ​<em class="string">"</em>​​<em class="string">button"</em>​ ​<em class="comment">%&gt;</em>​</td></tr></table>
<p id="calibre_link-1492" class="calibre19">
<span class="cf">RumblWeb.Router</span> generates the <span class="cf">Routes.watch_path</span>. It’s available to our controller code because of the <span class="cf">Routes</span> alias in <span class="cf">lib/rumbl_web.ex</span>. When we pass a struct like <span class="cf">video</span> to <span class="cf">watch_path</span>, Phoenix automatically extracts its ID to use in the returned URL. To use slugs, we could simply change the route call to the following:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Routes.watch_path(@conn, ​<em class="string">:show</em>​, ​<em class="string">"</em>​​<em class="string">#{</em>​video.id​<em class="string">}</em>​​<em class="string">-</em>​​<em class="string">#{</em>​video.slug​<em class="string">}</em>​​<em class="string">"</em>​)</td></tr></table>
<p id="calibre_link-1493" class="calibre19">This approach is easy to plug in, but it has a giant flaw. It’s brittle because it’s not DRY.  Each place we need a link, we need to build the URL with the <span class="cf">id</span> and <span class="cf">slug</span> fields. If we forget to use the same structure in any of the future <span class="cf">watch_path</span> calls, we’ll end up linking to the wrong URL. There’s a better way.</p>
<p id="calibre_link-1494" class="calibre19">
We can customize how Phoenix generates URLs for the videos. Phoenix and Elixir have the perfect solution for this. Phoenix knows to use the <span class="cf">id</span> field in a <span class="cf">Video</span> struct because Phoenix defines a protocol, called <span class="cf">Phoenix.Param</span>. By default, this protocol extracts the <span class="cf">id</span> of the struct, if one exists.</p>
<p id="calibre_link-1495" class="calibre19">

However, since <span class="cf">Phoenix.Param</span> is an Elixir protocol, we can customize it for any data type in the language, including the ones we define ourselves. Let’s do so for the <span class="cf">Video</span> struct. Create a new <span class="cf">lib/rumbl_web/param.ex</span> file with the following content:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/watching_videos/listings/rumbl/lib/rumbl_web/param.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">watching_videos/listings/rumbl/lib/rumbl_web/param.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defimpl</strong>​ Phoenix.Param, ​<em class="string">for:</em>​ Rumbl.Multimedia.Video ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ to_param(%{​<em class="string">slug:</em>​ slug, ​<em class="string">id:</em>​ id}) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">"</em>​​<em class="string">#{</em>​id​<em class="string">}</em>​​<em class="string">-</em>​​<em class="string">#{</em>​slug​<em class="string">}</em>​​<em class="string">"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1496" class="calibre19">




We’re implementing the <span class="cf">Phoenix.Param</span> protocol for the <span class="cf">Rumbl.Multimedia.Video</span> struct. The protocol requires us to implement the <span class="cf">to_param</span> function, which receives the video struct itself. We pattern-match on the video slug and ID and use it to build a string as our slug. Our <span class="cf">param.ex</span> file will serve as a home for other protocol implementations as we continue building our application.</p>
<p id="calibre_link-1497" class="calibre19">The beauty behind Elixir protocols is that we can implement them for any data structure, anywhere, any time. We can place our implementation in the same file as the video definition, or anywhere else  that makes sense. Because we can get Phoenix parameters without changing Phoenix or the <span class="cf">Video</span> module itself, we get a much cleaner polymorphism than we would otherwise.</p>
<p id="calibre_link-1498" class="calibre19">Let’s give this a try in IEx:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ video = %Rumbl.Multimedia.Video{​<em class="string">id:</em>​ 1, ​<em class="string">slug:</em>​ ​<em class="string">"</em>​​<em class="string">hello"</em>​}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%Rumbl.Multimedia.Video{id: 1, slug: "hello", ...}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ alias RumblWeb.Router.Helpers, ​<em class="string">as:</em>​ Routes</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Routes.watch_path(%URI{}, ​<em class="string">:show</em>​, video)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">"/watch/1-hello"</td></tr></table>
<p id="calibre_link-1499" class="calibre19">

We build a video and then call <span class="cf">Routes.watch_path</span>, passing our video as an argument. The new path uses both the <span class="cf">id</span> and <span class="cf">slug</span> fields. Note that we give the <span class="cf">URI</span> struct to <span class="cf">watch_path</span> instead of the usual connection. The URI struct is part of Elixir’s standard library, and all route functions accept it as their first argument. This convenience is particularly useful when building URLs outside of your web request. Think emails, messages, and so on. Let’s play a bit with this idea:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ url = URI.parse(​<em class="string">"</em>​​<em class="string">http://example.com/prefix"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%URI{...}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Routes.watch_path(url, ​<em class="string">:show</em>​, video)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">"/prefix/watch/1-hello"</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Routes.watch_url(url, ​<em class="string">:show</em>​, video)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">"http://example.com/prefix/watch/1-hello"</td></tr></table>
<p id="calibre_link-1500" class="calibre19">

You can also ask your endpoint to return the <span class="cf">struct_url</span>, based on the values you’ve defined in your configuration files:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ url = RumblWeb.Endpoint.struct_url()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">%URI{...}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Routes.watch_url(url, ​<em class="string">:show</em>​, video)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">"http://localhost:4000/watch/1-hello"</td></tr></table>
<p id="calibre_link-1501" class="calibre19">With <span class="cf">Phoenix.Param</span> properly implemented for our videos, we can try it out. Start your server back up with <span class="cf">mix phx.server</span>, then access “My Videos” and click the “Watch” link for any existing video.</p>
<p id="calibre_link-1502" class="calibre19">Well, that was less than ideal. You see a page with an error that looks something like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">value `"13-hello-world"` in `where` cannot be cast to type :id in query:</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">from v in Rumbl.Multimedia.Video,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  where: v.id == ^"13-",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  select: v</td></tr></table>
<p id="calibre_link-1503" class="calibre19">


Primary keys in Ecto have a default type of <span class="cf">:id</span>. For now, we can consider <span class="cf">:id</span> to be an <span class="cf">:integer</span>. When a new request goes to <span class="cf">/watch/13-hello-world</span>, the router matches <span class="cf">13-hello-world</span> as the <span class="cf">id</span> parameter and sends it to the controller. In the controller, we try to make a query by using the <span class="cf">id</span>, and it complains. Let’s look at the source of the problem:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ show(conn, %{​<em class="string">"</em>​​<em class="string">id"</em>​ =&gt; id}) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  video = Multimedia.get_video!(id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  render(conn, ​<em class="string">"</em>​​<em class="string">show.html"</em>​, ​<em class="string">video:</em>​ video)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1504" class="calibre19"><span class="cf">WatchController.show</span> is taking the <span class="cf">id</span> parameter and passing it to our <span class="cf">Multimedia.get_video</span> context function. Let’s continue digging and open up <span class="cf">lib/rumbl/multimedia.ex</span>:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ get_video!(id), ​<strong class="kw">do</strong>​: Repo.get!(Video, id)</td></tr></table>
<p id="calibre_link-1505" class="calibre19">That’s the problem. We’re doing a <span class="cf">Repo.get!</span> by using the <span class="cf">id</span> field, which is now a string instead of an integer. Let’s fix that now.</p>
<p id="calibre_link-1506" class="calibre19">Before doing a database query comparing against the <span class="cf">id</span> column, we need to cast <span class="cf">13-hello-world</span> to an integer.
</p><h3 class="calibre22">Extending Schemas with Ecto Types</h3>
<p id="calibre_link-1507" class="calibre19">






Sometimes, the basic type information in our schemas isn’t enough. In those cases, we’d like to improve our schemas with types that have a knowledge of Ecto. For example, we might want to associate some behavior to our <span class="cf">id</span> fields. A <span class="calibre4">custom type</span> allows us to do that. Let’s implement one and place it in <span class="cf">lib/rumbl/multimedia/permalink.ex</span>. Our new <span class="calibre4">behaviour</span>, meaning an implementation of our interface, looks like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/watching_videos/listings/rumbl/lib/rumbl/multimedia/permalink.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">watching_videos/listings/rumbl/lib/rumbl/multimedia/permalink.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ Rumbl.Multimedia.Permalink ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  @behaviour Ecto.Type</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ type, ​<strong class="kw">do</strong>​: ​<em class="string">:id</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ cast(binary) ​<strong class="kw">when</strong>​ is_binary(binary) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">case</strong>​ Integer.parse(binary) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      {int, _} ​<strong class="kw">when</strong>​ int &gt; 0 -&gt; {​<em class="string">:ok</em>​, int}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      _ -&gt; ​<em class="string">:error</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ cast(integer) ​<strong class="kw">when</strong>​ is_integer(integer) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, integer}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ cast(_) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">:error</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ dump(integer) ​<strong class="kw">when</strong>​ is_integer(integer) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, integer}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ load(integer) ​<strong class="kw">when</strong>​ is_integer(integer) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, integer}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table><table class="simpletable"><thead class="calibre33"><tr class="calibre34"><th colspan="2" class="outerlines"><p class="calibre31">Behaviour or Behavior?</p></th></tr></thead><tbody class="calibre35"><tr class="tr"><td class="calibre36">
               <img id="calibre_link-1508" class="calibre37" src="images/000035.png" alt="images/aside-icons/info.png" width="283" height="300" />
             </td><td class="calibre38">

  <p class="calibre31">
  
    The Elixir and Erlang documentation use the European spelling of “behaviour” so we’ll stick with that one when we refer to the actual Elixir concept. We’ll use the “ior” spelling when we are talking about “behavior,” the word.
  </p>
</td></tr></tbody></table>
<p id="calibre_link-1509" class="calibre19"><span class="cf">Rumbl.Multimedia.Permalink</span> is a custom type defined according to the <span class="cf">Ecto.Type</span> behaviour. It expects us to define four functions:



</p><table class="simpletable1"><tbody class="calibre35"><tr class="tr1"><td class="calibre45"><p class="calibre31"><span class="cf1">type</span></p></td><td class="calibre45"><p class="calibre31">Returns the underlying Ecto type. In this case, we’re building on top of <span class="cf1">:id</span>.</p></td></tr><tr class="tr2"><td class="calibre45"><p class="calibre31"><span class="cf1">cast</span></p></td><td class="calibre45"><p class="calibre31">Called when external data is passed into Ecto. It’s invoked when values in queries are interpolated or also by the <span class="cf1">cast</span> function in changesets.</p></td></tr><tr class="tr1"><td class="calibre45"><p class="calibre31"><span class="cf1">dump</span></p></td><td class="calibre45"><p class="calibre31">Invoked when data is sent to the database.</p></td></tr><tr class="tr3"><td class="calibre45"><p class="calibre31"><span class="cf1">load</span></p></td><td class="calibre45"><p class="calibre31">Invoked when data is loaded from the database.</p></td></tr></tbody></table>
<p id="calibre_link-1510" class="calibre19">





By design, the <span class="cf">cast</span> function often processes end-user input. We should be both lenient and careful when we parse it. For our slug&mdash;that means for binaries&mdash;we call <span class="cf">Integer.parse</span> to extract only the leading integer. On the other hand, <span class="cf">dump</span> and <span class="cf">load</span> handle the struct-to-database conversion. We can expect to work only with integers at this point because <span class="cf">cast</span> does the dirty work of sanitizing our input. Successful casts return integers. <span class="cf">dump</span> and <span class="cf">load</span> return <span class="cf">:ok</span> tuples with integers or <span class="cf">:error</span>.</p>
<p id="calibre_link-1511" class="calibre19">Let’s give our custom type a try with <span class="cf">iex -S mix</span>. Since we changed code in <span class="cf">lib</span>, you need to restart any running session.</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ alias Rumbl.Multimedia.Permalink, ​<em class="string">as:</em>​ P</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ P.cast(​<em class="string">"</em>​​<em class="string">1"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{:ok, 1}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ P.cast(1)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{:ok, 1}</td></tr></table>
<p id="calibre_link-1512" class="calibre19">

Integers and strings work as usual. That’s great. Let’s try something more complex:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ P.cast(​<em class="string">"</em>​​<em class="string">13-hello-world"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{:ok, 13}</td></tr></table>
<p id="calibre_link-1513" class="calibre19">Perfect. An integer followed by a string, such as the ones we build with our protocol, works just as it should. Let’s try something that should break, like a string followed by an integer:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ P.cast(​<em class="string">"</em>​​<em class="string">hello-world-13"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">:error</td></tr></table>
<p id="calibre_link-1514" class="calibre19">And it breaks, just as it should. As long as the string starts with a positive integer, we’re good to go. The last step is to tell Ecto to use our custom type for the <span class="cf">id</span> field in <span class="cf">lib/rumbl/multimedia/video.ex</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/watching_videos/listings/rumbl/lib/rumbl/multimedia/video.change2.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">watching_videos/listings/rumbl/lib/rumbl/multimedia/video.change2.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">@primary_key {​<em class="string">:id</em>​, Rumbl.Multimedia.Permalink, ​<em class="string">autogenerate:</em>​ true}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">schema ​<em class="string">"</em>​​<em class="string">videos"</em>​ ​<strong class="kw">do</strong>​</td></tr></table>
<p id="calibre_link-1515" class="calibre19">




Because Ecto automatically defines the <span class="cf">id</span> field for us, we can customize the primary key with the <span class="cf">@primary_key</span> module attribute. Just give it a tuple with the primary key name (<span class="cf">:id</span>). We tacked on the <span class="cf">autogenerate: true</span> option because our database autogenerates <span class="cf">id</span> values.</p>
<p id="calibre_link-1516" class="calibre19">And that’s that. Access the page once again, and it should load successfully. By implementing a protocol and defining a custom type, we made Phoenix work exactly how we wanted without tightly coupling it to our implementation. Ecto types go way beyond simple casting, though. We’ve already seen the community handle field encryption, data uploading, and more, all neatly wrapped and contained inside an Ecto type.












</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-173"><div id="calibre_link-1517" class="calibre2"><h2 id="calibre_link-127" class="calibre20">Wrapping Up</h2>
<p id="calibre_link-1518" class="calibre19">In this chapter, we accomplished a lot. We built a controller for watching videos and extended our context to provide the necessary domain logic. We then laid some foundation so we can play our videos in YouTube. Finally, we also created friendly URLs. Along the way:</p><ul class="calibre28"><li class="calibre29">
<p id="calibre_link-1519" class="calibre31">You learned to use webpack to support development-time reloading and minimization for production code.</p></li><li class="calibre29">
<p id="calibre_link-1520" class="calibre31">We used generators to create an Ecto migration.</p></li><li class="calibre29">
<p id="calibre_link-1521" class="calibre31">We used changesets to create slugs.</p></li><li class="calibre29">
<p id="calibre_link-1522" class="calibre31">We used protocols to seamlessly build URLs from those new slugs.</p></li></ul>
<p id="calibre_link-1523" class="calibre19">In the next chapter, you’re going to reach the long-awaited channels topic. You’ll learn to use Phoenix to build fully interactive features that show off Elixir’s concurrency and consistency. Turn the page, because the energy only goes up from here!



</p>

<div class="footnotes">
<h4 class="calibre24">Footnotes</h4>
<dl class="calibre25">
<dt class="footnote-number"><a id="calibre_link-256" href="#calibre_link-174" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[26]</a></dt><dd class="calibre26">
<p id="calibre_link-1524" class="calibre27"><a href="http://www.regular-expressions.info/" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">http://www.regular-expressions.info/</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-292" href="#calibre_link-175" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[27]</a></dt><dd class="calibre26">
<p id="calibre_link-1525" class="calibre27"><a href="https://webpack.js.org" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://webpack.js.org</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-293" href="#calibre_link-176" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[28]</a></dt><dd class="calibre26">
<p id="calibre_link-1526" class="calibre27"><a href="https://blog.stackpath.com/glossary/minification/" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://blog.stackpath.com/glossary/minification/</a></p></dd></dl></div>
<div class="copyright">Copyright © 2020, The Pragmatic Bookshelf.</div>




</div>



  </div>


<div class="calibre1" id="calibre_link-226"><div id="calibre_link-1527" class="calibre2"><h1 class="pcalibre6 chapter-title" id="calibre_link-128"><span class="chapter-number">
            Chapter
            10</span><br class="calibre18" /><span class="chapter-name">Using Channels</span></h1>

<p id="calibre_link-1528" class="calibre19">


If you dabbled in Phoenix before buying this book, at this point
you’re probably wondering why we’ve come so far and barely mentioned
channels. The truth is that for the interactive applications we care
about the most, channels are simpler to build so there’s less to talk
about.</p>
<p id="calibre_link-1529" class="calibre19">Think about everything you’ve learned so far. Up until now, a browser
made an isolated request and Phoenix delivered an isolated response.
We had to spend plenty of time on pipelines and code organizational
tools that let you do everything necessary to tie an individual user
to each request and remember the exact state of the conversation. You
know it well. A browser makes a request and the web server returns a
response:</p><div class="praise"><img id="calibre_link-1530" class="calibre46" src="images/000000.png" alt="images/src/channels/request-response.png" width="450" height="392" /></div>
<p id="calibre_link-1531" class="calibre19">
We build applications that way for a good reason. Each request is
stateless, so it’s easy to scale. When the programming language simply
can’t keep many connections around, it makes sense to do a little
extra work so the web server can treat every request as a new one.</p>
<p id="calibre_link-1532" class="calibre19">Sometimes, though, that programming model has too much overhead for
the types of applications we want to build. Programs must be longer,
programmers must work harder to reason about them, and the server has
to work harder to process them.</p>
<p id="calibre_link-1533" class="calibre19">
This chapter will focus on the highly interactive problems that
Phoenix solves so well. These problems don’t lend themselves to a
request/response flow. Think live chats, Google Maps, kayak.com, and
twitter.com. In that world, a single client on a page connects
directly with a process on the server called a channel, like this:</p><div class="praise"><img id="calibre_link-1534" class="calibre47" src="images/000036.png" alt="images/src/channels/bidirectional.png" width="405" height="184" /></div>
<p id="calibre_link-1535" class="calibre19">It <span class="calibre4">looks</span> simpler because for the programmer it <span class="calibre4">is</span> simpler. Since
Elixir can scale to millions of simultaneous processes that manage
millions of concurrent connections, you don’t have to resort to
request/response to make things easy to scale or even manage. A client
connects to a channel and then sends and receives messages. That’s it.</p>
<p id="calibre_link-1536" class="calibre19">It’s now cool again to have applications where the clients and servers
just, you know, talk directly to each other. That’s why this chapter
is much shorter than the request/response paradigm covered in Part I, and
it’s also why Phoenix is such a big deal.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-251"><div id="calibre_link-1537" class="calibre2"><h2 id="calibre_link-129" class="calibre20">The Channel</h2>
<p id="calibre_link-1538" class="calibre19">





A Phoenix channel is a conversation. The channel sends messages,
receives messages, and keeps state. We call the messages <span class="calibre4">events</span>, and
we put the state in a struct called <span class="cf">socket</span>.</p>
<p id="calibre_link-1539" class="calibre19">


A Phoenix conversation is about a <span class="calibre4">topic</span>, and it maps onto
application concepts like a chat room, a local map, a game, or in our
case, the annotations on a video. More than one user might be
interested in the same topic at the same time. Channels give you tools
to organize your code and the communication among users. The concept
that makes channels so powerful in Elixir is that <span class="calibre4">each user’s
conversation on a topic has its own isolated, dedicated process</span>.</p>
<p id="calibre_link-1540" class="calibre19">Here’s the kicker. Whereas request/response interactions are
<span class="calibre4">stateless</span>, conversations in a long-running process can be
<span class="calibre4">stateful</span>. This means that for more-sophisticated user interactions
like interactive pages or multiplayer games, you don’t have to work so
hard to keep track of the conversation by using cookies, databases, or
the like. Each call to a channel simply picks up where the last one
left off.</p>
<p id="calibre_link-1541" class="calibre19">



This approach only works if your foundation guarantees true isolation
and concurrency. True isolation means that one crashing process won’t
impact other subscribed users. True concurrency means lightweight
abstractions that won’t bleed into one another. Your channels will
<span class="calibre4">scale</span> in the dimensions that are most important to you, including
code complexity, performance, and manageability.</p>
<p id="calibre_link-1542" class="calibre19">You may be thinking that channels can’t be this simple, but they are.
Your channels application will have to worry about three things, each
on both the client and the server:</p><ul class="calibre28"><li class="calibre29">Making and breaking connections</li><li class="calibre29">Sending messages</li><li class="calibre29">Receiving messages</li></ul>
<p id="calibre_link-1543" class="calibre19">In this chapter, you’ll learn each of those basic building blocks in
greater detail. We’re primarily going to be building the interactive
portion of our application. We’ll allow users to build annotations in
real time, and <span class="cf">rumbl</span> will play back all video annotations for a
user. We’ll do this in two parts. First, on the client side, we need
to build some client code to make a connection, send messages, and
receive messages. We’ll write our code in ES6, the latest generation of
JavaScript. Then, on the server side, we’ll do the same. We’ll
establish a connection and then write channels code to process each
request in the conversation.</p>
<p id="calibre_link-1544" class="calibre19">When we’re done, we’ll take advantage of some Phoenix infrastructure
called Channel Presence. We’ll write a little bit of code so users of Rumbl
will be able to tell exactly who’s logged in.</p>
<p id="calibre_link-1545" class="calibre19">There’s plenty to do, so let’s get started.
</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-284"><div id="calibre_link-1546" class="calibre2"><h2 id="calibre_link-130" class="calibre20">Phoenix Clients with ES6</h2>
<p id="calibre_link-1547" class="calibre19">





We’re going to start on the client, using ECMAScript
6<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-228" href="#calibre_link-285">[29]</a></sup> JavaScript features. We’ll
build a bare-bones client to simply establish a connection. Over time,
we’ll build up our client to add annotations and play them back.</p>
<p id="calibre_link-1548" class="calibre19">
Remember, each Phoenix conversation is on a topic, so we’ll need to be
able to identify a topic. In our case, our topics will be videos.
We’ll create a <span class="cf">Video</span> object. That client-side construct will connect
to Phoenix directly.</p><div class="xxxsays"><div class="heading"><div class="persons-picture"><img src="images/000048.png" alt="Chris says:" class="calibre40" /></div><div class="label">Chris says:</div><div class="title">Why ES6/ES2015 JavaScript?</div></div><div class="praise">
<p id="calibre_link-1549" class="calibre14">


Language features you’ve wished for years to land in
JavaScript&mdash;string interpolation, a module system, destructuring
assignment, and more&mdash;are now within reach. When you
<span class="calibre4">transpile</span> a language, you’re translating it to a more
common form.  Since it’s possible to transpile ES6 to the widely
available ES5 JavaScript, you can use ES6 today while supporting all
mainstream browsers. This leaves you no reason to not go all-in on
ES6. Plus, planned browser enhancements mean you have the bonus of
waiting a couple years, and suddenly your ES6 code will be supported
natively throughout the web.
</p></div></div>
<p id="calibre_link-1550" class="calibre19">Let’s create a separate file for our <span class="cf">Video</span> object in
<span class="cf">assets/js/video.js</span>. It’s a long file, but it’s not too complicated,
especially when broken into parts:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/assets/js/video.js" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/assets/js/video.js</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">​<strong class="kw">import</strong>​ Player ​<strong class="kw">from</strong>​ ​<em class="string">"./player"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">let</strong>​ Video = {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">  init(socket, element){ ​<strong class="kw">if</strong>​(!element){ ​<strong class="kw">return</strong>​ }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">let</strong>​ playerId = element.getAttribute(​<em class="string">"data-player-id"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">let</strong>​ videoId  = element.getAttribute(​<em class="string">"data-id"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    socket.connect()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    Player.init(element.id, playerId, () =&gt; { </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">      ​<strong class="kw">this</strong>​.onReady(videoId, socket)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    })</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  },</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  onReady(videoId, socket){</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline">    ​<strong class="kw">let</strong>​ msgContainer = document.getElementById(​<em class="string">"msg-container"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">let</strong>​ msgInput     = document.getElementById(​<em class="string">"msg-input"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">let</strong>​ postButton   = document.getElementById(​<em class="string">"msg-submit"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">let</strong>​ vidChannel   = socket.channel(​<em class="string">"videos:"</em>​ + videoId)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<em class="comment">// TODO join the vidChannel</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">20:&nbsp;</span></td><td class="codeline">  }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">export</strong>​ ​<strong class="kw">default</strong>​ Video</td></tr></table>
<p id="calibre_link-1551" class="calibre19">







We first import our <span class="cf">Player</span>, the abstraction that lets us play videos
and extract the exact time for any given frame so we can correctly
place our annotations. Next, we define an <span class="cf">init</span> function to set up
the player and pluck our video ID from the element attributes. We will then
start the socket connection with <span class="cf">socket.connect()</span> and initialize our
player while running a <span class="cf">this.onReady()</span> callback when the player has
loaded. Within <span class="cf">onReady</span>, we define a handful of DOM variables for our
<span class="cf">Video</span> player. We have the container for annotations, the input
control, and the button for creating a new annotation. Pay special
attention to <span class="cf">vidChannel</span>, which we’ll use to connect our ES6 client
to our Phoenix <span class="cf">VideoChannel</span>. For now we just instantiate it, but
we’ll join the conversation with the server in a moment.</p>
<p id="calibre_link-1552" class="calibre19">
Our topics need an identifier. By convention, ours takes the form
<span class="cf">"videos:" + videoId</span>. In our application, this topic will let us
easily send events to others interested in the same topic.</p>
<p id="calibre_link-1553" class="calibre19">Let’s tweak our video player to use this new <span class="cf">Video</span> object.</p>
<p id="calibre_link-1554" class="calibre19">We were previously initializing and importing our video player in
<span class="cf">assets/js/app.js</span>, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">import</strong>​ Player ​<strong class="kw">from</strong>​ ​<em class="string">"./player"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">let</strong>​ video = document.getElementById(​<em class="string">"video"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">if</strong>​(video) {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Player.init(video.id, video.getAttribute(​<em class="string">"data-player-id"</em>​), () =&gt; {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    console.log(​<em class="string">"player ready!"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  })</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">}</td></tr></table>
<p id="calibre_link-1555" class="calibre19">It would be better to tweak that code to compensate for the
initialization we’re doing in <span class="cf">video.js</span>. Let’s tweak it to start only
the <span class="cf">Video</span> object, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/assets/js/app.change1.js" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/assets/js/app.change1.js</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">import</strong>​ socket ​<strong class="kw">from</strong>​ ​<em class="string">"./socket"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">import</strong>​ Video ​<strong class="kw">from</strong>​ ​<em class="string">"./video"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Video.init(socket, document.getElementById(​<em class="string">"video"</em>​))</td></tr></table>
<p id="calibre_link-1556" class="calibre19">
We import the <span class="cf">Video</span> object that we just created from its local
module path. Next, we initialize the video with our connection called
<span class="cf">socket</span> (more on this later) and the DOM element whose ID is <span class="cf">video</span>.
Now load up your last video, and you should see it loaded into a
YouTube player as before&mdash;but if you view your browser’s JavaScript
console, you see that the channel join is failing:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Unable to join &gt; {reason: "unmatched topic"}</td></tr></table>
<p id="calibre_link-1557" class="calibre19">With our video up and running and <span class="cf">vidChannel</span> initialized, our client
is trying to join a video channel that we haven’t implemented yet.
Let’s flip back to the server side for a bit and fix this. It’s time
to create a channel and establish the conversation with our client.


</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-190"><div id="calibre_link-1558" class="calibre2"><h2 id="calibre_link-131" class="calibre20">Preparing Our Server for the Channel</h2>
<p id="calibre_link-1559" class="calibre19">

In the request/response world, each request established a connection,
which we represented in <span class="cf">Plug.Conn</span>. We then used ordinary functions
to transform that connection until it had the response we wanted to
send back to the client. Each plug didn’t use the same <span class="cf">conn</span> per se,
but each transformation was conceptually on the same request. Each
time you had a new request, you’d start from scratch with a new <span class="cf">conn</span>
struct. Said another way, for each request, a new <span class="cf">conn</span> would flow
through all of the pipelines and then die.</p>
<p id="calibre_link-1560" class="calibre19">
In channels, the flow is different. A client establishes a new
connection with a <span class="cf">socket</span>. After the connection is made, that socket
will be transformed through the life of the connection.</p>
<p id="calibre_link-1561" class="calibre19">

At the high level, your <span class="cf">socket</span> is the ongoing conversation between
client and server. It has all of the information necessary to do its
job. When you make a connection, you’re creating your initial
<span class="cf">socket</span>, and that same socket will be transformed with each new
received event, through the whole life of the whole conversation.</p>
<p id="calibre_link-1562" class="calibre19">You need to do a couple of things to make a connection. First, you
decide whether to allow the connection. Next, you create the initial
<span class="cf">socket</span>, including any custom application setup your application
might need.</p>
<p id="calibre_link-1563" class="calibre19">


Let’s hack up a quick connection to see how things work. In our ES6
example, Phoenix created an <span class="cf">assets/js/socket.js</span> with an example
socket connection and channel code. Replace the file contents with
this minimal socket connection:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/assets/js/socket.change1.js" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/assets/js/socket.change1.js</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">import</strong>​ {Socket} ​<strong class="kw">from</strong>​ ​<em class="string">"phoenix"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">let</strong>​ socket = ​<strong class="kw">new</strong>​ Socket(​<em class="string">"/socket"</em>​, {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  params: {token: window.userToken},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  logger: (kind, msg, data) =&gt; { console.log(​<em class="string">`</em>​${kind}​<em class="string">: </em>​${msg}​<em class="string">`</em>​, data) }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">export</strong>​ ​<strong class="kw">default</strong>​ socket</td></tr></table>
<p id="calibre_link-1564" class="calibre19">




That simple connection is as basic as it gets. Phoenix isn’t doing
anything fancy for us here. You can see that the ES6 client imports
the <span class="cf">Socket</span> object. Then <span class="cf">let socket = new Socket("/socket", ...)</span>
causes Phoenix to instantiate a new socket at our endpoint. We pass params and an
optional <span class="cf">logger</span> callback, which includes helpful debugging logging
in the JavaScript console. If you peek in <span class="cf">lib/rumbl_web/endpoint.ex</span>,
you can see where the <span class="cf">"/socket"</span> is declared. This definition is the
<span class="calibre4">socket mount point</span>:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">socket ​<em class="string">"</em>​​<em class="string">/socket"</em>​, RumblWeb.UserSocket,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="string">websocket:</em>​ true,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="string">longpoll:</em>​ false</td></tr></table>
<p id="calibre_link-1565" class="calibre19">


Each <span class="cf">socket</span> macro establishes a <span class="calibre4">socket mount</span> providing all configuration for a single user socket. The <span class="cf">UserSocket</span> module serves as the starting point for all socket connections. As you’ll see later in this chapter, it’s responsible for authenticating, and also for wiring
up default socket information for all channels.</p>
<p id="calibre_link-1566" class="calibre19">


Our socket mount also defines the transport layers that will handle the connection between client and the server. You see the two default transport that Phoenix supports, <span class="cf">longpoll</span> and <span class="cf">websocket</span>. You can even build your own transport for more exotic use cases. Peek inside the <span class="cf">lib/rumbl_web/channels/user_socket.ex</span> to see the <span class="cf">UserSocket</span> in action:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ RumblWeb.UserSocket ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ Phoenix.Socket</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="comment"># channel "room:*", RumblWeb.RoomChannel</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ connect(_params, socket, _connect_info) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, socket}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ id(_socket), ​<strong class="kw">do</strong>​: nil</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1567" class="calibre19"><span class="cf">UserSocket</span> will use a single connection to the server to handle all of your channel processes. Phoenix will handle getting the right message to the right channel.</p>
<p id="calibre_link-1568" class="calibre19">
Regardless of the transport, the end result is the same. You operate
on a shared <span class="cf">socket</span> abstraction, and Phoenix takes care of the rest.
The beauty of this is that you no longer have to worry how the user is
connected. Whether on older browsers over long-polling, native iOS
WebSockets, or a custom transport like CoAP<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-229" href="#calibre_link-191">[30]</a></sup>
for embedded devices, your backend channel code remains precisely the
same. This is the new web. You’ll be able to quickly adapt your
applications as new transport protocols become important to you.</p>
<p id="calibre_link-1569" class="calibre19">


In our <span class="cf">UserSocket</span>, we have two simple functions: <span class="cf">connect</span> and <span class="cf">id</span>.
The <span class="cf">id</span> function lets us identify the socket based on some state
stored in the socket itself, like the user ID. The <span class="cf">connect</span> function
decides whether to make a connection. It receives the connection parameters,
the connection socket, and a map of advanced connection information.
In our case, <span class="cf">id</span> returns <span class="cf">nil</span>, and <span class="cf">connect</span> simply lets everyone in.
We’re effectively allowing all connections as anonymous users by default.</p>
<p id="calibre_link-1570" class="calibre19">We’ll be adding socket authentication with our <span class="cf">RumblWeb.Auth</span> system
in a moment, but for now, let’s leave these defaults. We added
<span class="cf">socket.connect()</span> after we initialized our <span class="cf">Player</span> in <span class="cf">video.js</span> to
establish the connection to the server.  If we open up the JavaScript
console in our browser and refresh one of our video pages, we see the
following logger output:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">transport: connected to</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">ws://localhost:4000/socket/websocket?token=undefined&amp;vsn=2.0.0</td></tr></table>
<p id="calibre_link-1571" class="calibre19">We have a working connection! Let’s create the channel on the Phoenix
side.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-235"><div id="calibre_link-1572" class="calibre2"><h2 id="calibre_link-132" class="calibre20">Creating the Channel</h2>
<p id="calibre_link-1573" class="calibre19">It’s time to write some code to process connections. To review what
you know so far, a channel is a conversation on a topic. Our topic has
an identifier of <span class="cf">videos:video_id</span>, where <span class="cf">video_id</span> is a dynamic ID
matching a record in the database. In our application, we want a user
to get all events for a topic, which to us means a user will get all
annotations for a given video, regardless of who created them.</p>
<p id="calibre_link-1574" class="calibre19">


More generally, at their most basic level, topics are strings that
serve as identifiers. They often take the form of <span class="cf">topic:subtopic</span>,
where <span class="cf">topic</span> is often a resource name and <span class="cf">subtopic</span> is often an ID,
but any string is a valid topic.</p>
<p id="calibre_link-1575" class="calibre19">Since topics are organizing concepts, we’ll include topics where you’d
expect: as parameters to functions and in our URLs to identify
conversations. Just as the client passes a URL with an <span class="cf">:id</span> parameter
to represent a resource for a controller, we’ll provide a topic ID to
scope our channel connections.


</p><h3 class="calibre22">Joining a Channel</h3>
<p id="calibre_link-1576" class="calibre19">



Now that we’ve established a socket connection, our users can join a
channel. In general, when clients join a channel, they must provide a
topic. They’ll be able to join any number of channels and any number
of topics on a channel.</p>
<p id="calibre_link-1577" class="calibre19">
We need a <span class="cf">VideoChannel</span> for our application, so let’s start by
including a <span class="cf">channel</span> definition in our <span class="cf">UserSocket</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/lib/rumbl_web/channels/user_socket.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/lib/rumbl_web/channels/user_socket.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ RumblWeb.UserSocket ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ Phoenix.Socket</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="comment">## Channels</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  channel ​<em class="string">"</em>​​<em class="string">videos:*"</em>​, RumblWeb.VideoChannel</td></tr></table>
<p id="calibre_link-1578" class="calibre19">Transports route events into your <span class="cf">UserSocket</span>, where they’re
dispatched into your channels based on topic patterns that you declare
with the <span class="cf">channel</span> macro. Our <span class="cf">videos:*</span> convention categorizes topics
with a resource name, followed by a resource ID.</p>
<p id="calibre_link-1579" class="calibre19">Let’s move on to the code that will process each incoming event.</p><h3 class="calibre22">Building the Channel Module</h3>
<p id="calibre_link-1580" class="calibre19">






Now, it’s time to create the module that will handle our specific
<span class="cf">VideoChannel</span>. It’ll allow connections through <span class="cf">join</span> and also let
users disconnect and send events. For consistency with OTP naming
conventions, this book sometimes refers to these features as
<span class="calibre4">callbacks</span>. Let’s start with <span class="cf">join</span>. Create a file called
<span class="cf">lib/rumbl_web/channels/video_channel.ex</span>, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/lib/rumbl_web/channels/video_channel.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/lib/rumbl_web/channels/video_channel.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ RumblWeb.VideoChannel ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ RumblWeb, ​<em class="string">:channel</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ join(​<em class="string">"</em>​​<em class="string">videos:"</em>​ &lt;&gt; video_id, _params, socket) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, assign(socket, ​<em class="string">:video_id</em>​, String.to_integer(video_id))}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1581" class="calibre19">Here we see the first of our channel callbacks: <span class="cf">join</span>. Clients can
join topics on a channel. We return <span class="cf">{:ok, socket}</span> to authorize a
<span class="cf">join</span> attempt or <span class="cf">{:error, socket}</span> to deny one.</p>
<p id="calibre_link-1582" class="calibre19">






For now, we let all clients join any video topic. We extract the video
ID using pattern matching: <span class="cf">"videos:" &lt;&gt; video_id</span> will match all topics
starting with <span class="cf">"videos:"</span> and assign the rest of the topic to the <span class="cf">video_id</span>
variable. We then add the video ID to <span class="cf">socket.assigns</span>. Remember, sockets
will hold all of the state for a given conversation. Each socket can hold
its own state in the <span class="cf">socket.assigns</span> field, which typically holds a map.</p>
<p id="calibre_link-1583" class="calibre19">

For channels, <span class="calibre4">the <span class="cf">socket</span> is transformed in a loop rather than a
single pipeline</span>. In fact, the socket state will remain for the
duration of a connection. That means the socket state we add in <span class="cf">join</span>
will be accessible later as events come into and out of the channel.
This small distinction leads to an enormous difference in efficiency
between the channels API and the controllers API.</p>
<p id="calibre_link-1584" class="calibre19">With our channel in place, let’s join it from the client. Open up
<span class="cf">assets/js/video.js</span> and update your listing:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/assets/js/video.change1.js" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/assets/js/video.change1.js</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">onReady(videoId, socket){</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">2:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">let</strong>​ msgContainer = document.getElementById(​<em class="string">"msg-container"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">3:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">let</strong>​ msgInput     = document.getElementById(​<em class="string">"msg-input"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">4:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">let</strong>​ postButton   = document.getElementById(​<em class="string">"msg-submit"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">let</strong>​ vidChannel   = socket.channel(​<em class="string">"videos:"</em>​ + videoId) </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">6:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">7:&nbsp;</span></td><td class="codeline">  vidChannel.join()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">8:&nbsp;</span></td><td class="codeline">    .receive(​<em class="string">"ok"</em>​, resp =&gt; console.log(​<em class="string">"joined the video channel"</em>​, resp) )</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">9:&nbsp;</span></td><td class="codeline">    .receive(​<em class="string">"error"</em>​, reason =&gt; console.log(​<em class="string">"join failed"</em>​, reason) ) </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">}</td></tr></table>
<p id="calibre_link-1585" class="calibre19">On lines 5 through  9, we create a new channel object,
<span class="cf">vidChannel</span>, from our <span class="cf">socket</span> and give it our topic. We build the
topic by joining the <span class="cf">"videos:"</span> string with our video ID, which we
plucked from the <span class="cf">div</span> element in our <span class="cf">WatchView</span>’s <span class="cf">show.html.eex</span>
template.</p>
<p id="calibre_link-1586" class="calibre19">We see our <span class="cf">joined</span> message in the JavaScript web console output:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">transport: connected to ws://localhost:4000/socket/websocket...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">push: videos:1 phx_join (1, 1) &ndash; {}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">receive: ok videos:1 phx_reply (1) &ndash; {response: {}, status: "ok"}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">joined the video channel &ndash; {}</td></tr></table>
<p id="calibre_link-1587" class="calibre19">Likewise, our server output confirms that we’ve established our
conversation:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] JOIN "videos:1" to RumblWeb.VideoChannel</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Transport:  :websocket</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Serializer: Phoenix.Socket.V2.JSONSerializer</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Parameters: %{}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] Replied videos:1 :ok</td></tr></table>
<p id="calibre_link-1588" class="calibre19">And we’re joined!






</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-25"><div id="calibre_link-1589" class="calibre2"><h2 id="calibre_link-133" class="calibre20">Sending and Receiving Events</h2>
<p id="calibre_link-1590" class="calibre19">




Everything we’ve done so far is setting us up to do one thing: process
events. Just as controllers receive requests, channels receive events.
With channels, we receive a message containing an event name, such as
<span class="cf">new_message</span>, and a payload of arbitrary data.</p>
<p id="calibre_link-1591" class="calibre19">





Each channel module has three ways to receive events. You’ll learn
more about these callback functions in detail soon. For now, know that
<span class="cf">handle_in</span> receives direct channel events, <span class="cf">handle_out</span> intercepts
broadcast events, and <span class="cf">handle_info</span> receives OTP messages.</p><h3 class="calibre22">Taking Our Channels for a Trial Run</h3>
<p id="calibre_link-1592" class="calibre19">

To test-drive everything we’ve put together so far, let’s make our
<span class="cf">join</span> function send our channel client a <span class="cf">:ping</span> message every five seconds,
like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/lib/rumbl_web/channels/video_channel.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/lib/rumbl_web/channels/video_channel.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ join(​<em class="string">"</em>​​<em class="string">videos:"</em>​ &lt;&gt; video_id, _params, socket) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="string">:timer</em>​.send_interval(5_000, ​<em class="string">:ping</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {​<em class="string">:ok</em>​, socket}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ handle_info(​<em class="string">:ping</em>​, socket) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  count = socket.assigns[​<em class="string">:count</em>​] || 1</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  push(socket, ​<em class="string">"</em>​​<em class="string">ping"</em>​, %{​<em class="string">count:</em>​ count})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {​<em class="string">:noreply</em>​, assign(socket, ​<em class="string">:count</em>​, count + 1)}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1593" class="calibre19">The <span class="cf">handle_info</span> callback is invoked whenever an Elixir message
reaches the channel. In this case, we match on the periodic <span class="cf">:ping</span>
message and increase a counter every time it arrives.</p>
<p id="calibre_link-1594" class="calibre19">

Our new <span class="cf">handle_info</span> takes our socket, takes the existing count (or a
default of <span class="cf">1</span>), and increases that count by 1. We then return a
tagged tuple. <span class="cf">:noreply</span> means we’re not sending a reply, and the
<span class="cf">assign</span> function transforms our socket by adding the new count.
Conceptually, we’re taking a socket and returning a transformed
socket. This implementation bumps the count in <span class="cf">:assigns</span> by 1, each
time it’s called.</p>
<p id="calibre_link-1595" class="calibre19">We’ve got the server-side implementation. We just need to call it now.
Add the following line to <span class="cf">video.js</span>, immediately below your
<span class="cf">vidChannel</span> declaration:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">vidChannel.on(​<em class="string">"ping"</em>​, ({count}) =&gt; console.log(​<em class="string">"PING"</em>​, count) )</td></tr></table>
<p id="calibre_link-1596" class="calibre19">Now check out your web console, and you see a <span class="cf">ping</span> event being
pushed from the server every five seconds, with an accumulated
counter:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">receive:  videos:1 ping</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">PING 1</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">receive:  videos:1 ping</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">PING 2</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">receive:  videos:1 ping</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">PING 3</td></tr></table>
<p id="calibre_link-1597" class="calibre19">Our channel process is alive and well!</p>
<p id="calibre_link-1598" class="calibre19">


<span class="cf">handle_info</span> is basically a loop. Each time, it returns the socket as
the last tuple element for all callbacks. This way, we can maintain
state.  We simply <span class="cf">push</span> the <span class="cf">ping</span> event, and the JavaScript client picks up
these events with the <span class="cf">channel.on(event, callback)</span> API. These events
can arrive on the client at any time, but later you’ll see how
channels support synchronous messaging for <span class="cf">handle_in</span> responses.</p>
<p id="calibre_link-1599" class="calibre19">

This is the primary difference between channels and controllers.
Controllers process a <span class="calibre4">request</span>. Channels hold a <span class="calibre4">conversation</span>.</p><h3 class="calibre22">Annotating Videos</h3>
<p id="calibre_link-1600" class="calibre19">Our channels are functioning but they’re not doing any real work yet. Let’s use them to build our real-time annotations. Since annotations need to happen in real time to stay in sync with videos, channels is the perfect way to build them. We’ll need to add video annotation to our multimedia context and allow new users to access them as they join the channel. Before we get too far into extending our <span class="cf">Multimedia</span> context, let’s start simple and build out the channel messaging first. Later, we can circle back and complete the annotation features when we’re happy with our client-server channel communication.</p>
<p id="calibre_link-1601" class="calibre19">



Our <span class="cf">WatchView</span>’s <span class="cf">show.html.eex</span> template is already mocked up with
an annotations container and post button that we’ve plucked from the
page to establish our <span class="cf">msgContainer</span> and <span class="cf">postButton</span> variables. Let’s
use these two elements to begin our real-time annotations support.
Open up your <span class="cf">video.js</span> and update the listing below your <span class="cf">vidChannel</span>
declaration with the following code:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/assets/js/video.change3.js" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/assets/js/video.change3.js</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">let</strong>​ vidChannel   = socket.channel(​<em class="string">"videos:"</em>​ + videoId)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  postButton.addEventListener(​<em class="string">"click"</em>​, e =&gt; {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">let</strong>​ payload = {body: msgInput.value, at: Player.getCurrentTime()}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">    vidChannel.push(​<em class="string">"new_annotation"</em>​, payload)        </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">              .receive(​<em class="string">"error"</em>​, e =&gt; console.log(e) ) </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    msgInput.value = ​<em class="string">""</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  })</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">  vidChannel.on(​<em class="string">"new_annotation"</em>​, (resp) =&gt; {         </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">this</strong>​.renderAnnotation(msgContainer, resp)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  })</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  vidChannel.join()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline">    .receive(​<em class="string">"ok"</em>​, resp =&gt; console.log(​<em class="string">"joined the video channel"</em>​, resp) )</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    .receive(​<em class="string">"error"</em>​, reason =&gt; console.log(​<em class="string">"join failed"</em>​, reason) )</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">renderAnnotation(msgContainer, {user, body, at}){</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">20:&nbsp;</span></td><td class="codeline">  ​<em class="comment">// TODO append annotation to msgContainer</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">}</td></tr></table>
<p id="calibre_link-1602" class="calibre19">



Let’s break it down. First, we handle the <span class="cf">click</span> event on the post
button. The <span class="cf">push</span> function on our <span class="cf">vidChannel</span> takes the contents of
our message input and sends it to the server, then clears the input
control.</p>
<p id="calibre_link-1603" class="calibre19">



On lines 5 and 6, you can see the channel’s synchronous
messaging in action. When we <span class="cf">push</span> an event to the server, we can opt
to <span class="cf">receive</span> a response. It’s not a true synchronous operation, but
it’s a big win for code readability. It lets us compose client-side
messaging in line with our Elixir process handling. It also provides
request/response&ndash;style messaging over a socket connection.</p>
<p id="calibre_link-1604" class="calibre19">


Now, we have to handle new events sent by the server. When users post
new annotations, the server will broadcast those new events to the
client, triggering a <span class="cf">new_annotation</span> event. On line 10, we receive those <span class="cf">new_annotation</span> events,
calling a stubbed <span class="cf">renderAnnotation</span> function. Let’s now implement
<span class="cf">renderAnnotation</span> to display our annotations on the page. You will need to update your
listing with the following code:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/assets/js/video.change4.js" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/assets/js/video.change4.js</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">esc(str){ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">let</strong>​ div = document.createElement(​<em class="string">"div"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  div.appendChild(document.createTextNode(str))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">return</strong>​ div.innerHTML</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">renderAnnotation(msgContainer, {user, body, at}){ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">let</strong>​ template = document.createElement(​<em class="string">"div"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">  template.innerHTML = ​<em class="string">`</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<em class="string">  &lt;a href="#" data-seek="</em>​${​<strong class="kw">this</strong>​.esc(at)}​<em class="string">"&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<em class="string">    &lt;b&gt;</em>​${​<strong class="kw">this</strong>​.esc(user.username)}​<em class="string">&lt;/b&gt;: </em>​${​<strong class="kw">this</strong>​.esc(body)}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<em class="string">  &lt;/a&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<em class="string">  `</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline">  msgContainer.appendChild(template)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  msgContainer.scrollTop = msgContainer.scrollHeight</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">}</td></tr></table>
<p id="calibre_link-1605" class="calibre19">







We implement the <span class="cf">renderAnnotation</span> function to append an annotation
to our message container. First, we define an <span class="cf">esc</span> function on line
1 to safely escape user input before
injecting values into the page. This strategy protects our users from
XSS attacks. Next, on line 7, we
use our <span class="cf">esc</span> function to safely build a DOM node with the user’s name
and annotation body and append it to the <span class="cf">msgContainer</span> list. Then, we
finish by scrolling the container to the right point.</p><h3 class="calibre22">Adding Annotations on the Server</h3>
<p id="calibre_link-1606" class="calibre19">
With our client-side event handling in place, let’s wire up the server
side of the conversation. Replace your <span class="cf">VideoChannel</span> with this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/lib/rumbl_web/channels/video_channel.change2.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/lib/rumbl_web/channels/video_channel.change2.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ RumblWeb.VideoChannel ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ RumblWeb, ​<em class="string">:channel</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ join(​<em class="string">"</em>​​<em class="string">videos:"</em>​ &lt;&gt; video_id, _params, socket) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, socket}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ handle_in(​<em class="string">"</em>​​<em class="string">new_annotation"</em>​, params, socket) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    broadcast!(socket, ​<em class="string">"</em>​​<em class="string">new_annotation"</em>​, %{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<em class="string">user:</em>​ %{​<em class="string">username:</em>​ ​<em class="string">"</em>​​<em class="string">anon"</em>​},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<em class="string">body:</em>​ params[​<em class="string">"</em>​​<em class="string">body"</em>​],</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<em class="string">at:</em>​ params[​<em class="string">"</em>​​<em class="string">at"</em>​]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    })</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:reply</em>​, ​<em class="string">:ok</em>​, socket}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1607" class="calibre19">
We ditch our <span class="cf">ping</span> messaging and add the second major kind of
callback, <span class="cf">handle_in</span>. This function will handle all incoming messages
to a channel, pushed directly from the remote client.</p>
<p id="calibre_link-1608" class="calibre19">



Look at the function head. This particular callback handles the
<span class="cf">new_annotation</span> events pushed from the client. Since we aren’t
persisting to the database yet, we simply broadcast <span class="cf">new_annotation</span>
events to all the clients on this topic with <span class="cf">broadcast!</span></p>
<p id="calibre_link-1609" class="calibre19">
The <span class="cf">broadcast!</span> function sends an event to all users on the current
topic. It takes three arguments: the socket, the name of the event,
and a payload, which is an arbitrary map. Within the body of our
callback, we can send as many messages as we’d like.</p>
<p id="calibre_link-1610" class="calibre19">
Behind the scenes, <span class="cf">broadcast!</span> uses Phoenix’s Publish and Subscribe (PubSub)
system to send the message to all processes listening on the given
topic. Phoenix PubSub is distributed out of the box; if there are
multiple machines running Phoenix, they will all receive the message
as long as they are connected via distributed Erlang.</p>
<p id="calibre_link-1611" class="calibre19">

When we’re done with the function, we send back a reply with a status
and the socket. The status is the customary Elixir <span class="cf">:ok</span> or <span class="cf">:error</span>.
We could also have used <span class="cf">:noreply</span> with the socket if we didn’t want
to reply to the client.</p>
<p id="calibre_link-1612" class="calibre19">Let’s try it out. This time, open up multiple browser
windows side by side to see how <span class="cf">broadcast!</span> is relaying messages to
all users who’ve joined our video topic:</p><div class="praise"><img id="calibre_link-1613" class="calibre48" src="images/000030.png" alt="images/src/channels/non-persisted-annotations.png" /></div>
<p id="calibre_link-1614" class="calibre19">It works! We now have a conversation going between client and server,
and you can get a glimpse into how our real-time annotations will be
orchestrated.</p><table class="simpletable"><thead class="calibre33"><tr class="calibre34"><th colspan="2" class="outerlines"><p class="calibre31">This Is a Bad Idea</p></th></tr></thead><tbody class="calibre35"><tr class="tr"><td class="calibre36">
               <img id="calibre_link-1615" class="calibre37" src="images/000012.png" alt="images/aside-icons/warning.png" width="260" height="271" />
             </td><td class="calibre38">

  <p class="calibre31">
  
  
   
  
  
  
    Forwarding a raw message payload without inspection is a big
security risk.
  </p>
</td></tr></tbody></table>
<p id="calibre_link-1616" class="calibre19">Note that we didn’t forward along the raw payload, such as:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">broadcast!(socket, ​<em class="string">"</em>​​<em class="string">new_annotation"</em>​, Map.put(params, ​<em class="string">"</em>​​<em class="string">user"</em>​, %{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="string">username:</em>​ ​<em class="string">"</em>​​<em class="string">anon"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">}))</td></tr></table>
<p id="calibre_link-1617" class="calibre19">
  
  
  
This would have worked, but it would have been extremely dangerous.
Broadcasting events delivers the payload to <span class="calibre4">all</span> clients on this
topic. If we don’t properly structure the payload from the remote
client before forwarding the message along as a broadcast, we’re
effectively allowing a client to broadcast arbitrary payloads across
our channel. If you want your application to be secure, you want to
control the payload as closely as you can.</p>
<p id="calibre_link-1618" class="calibre19">We’ve delivered our annotations to the client, but we’ve yet to
persist them. Before we can do that, we need to have the current user
in the <span class="cf">socket</span> in our channels. We’ve put it off as long as we can.
It’s time to tackle authentication.




</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-264"><div id="calibre_link-1619" class="calibre2"><h2 id="calibre_link-134" class="calibre20">Socket Authentication</h2>
<p id="calibre_link-1620" class="calibre19">









For request/response&ndash;type applications, session-based authentication
makes sense. For channels, <span class="calibre4">token authentication</span> works better because
the connection is a long-duration connection. With token
authentication, we assign a unique token to each user. Tokens allow
for a secure authentication mechanism that doesn’t rely on any
specific transport.</p>
<p id="calibre_link-1621" class="calibre19">





Programmers often ask why they can’t access their session cookies in a
channel. The answer is that this would be insecure over WebSockets
because of cross-domain attacks. Also, cookies would couple channel
code to the WebSocket transport, eliminating future transport layers.
Fortunately, Phoenix has a better way: the <span class="cf">Phoenix.Token</span>.</p>
<p id="calibre_link-1622" class="calibre19">Our <span class="cf">current_user</span> is already authenticated in the application by our
<span class="cf">RumblWeb.Auth</span> plug. All we need to do is generate a token for our
authenticated user and pass that to our socket on the frontend. The
first step is to expose the token to the client side in our
<span class="cf">lib/rumbl_web/templates/layout/app.html.eex</span> layout, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/lib/rumbl_web/templates/layout/app.change1.html.eex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/lib/rumbl_web/templates/layout/app.change1.html.eex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;script&gt;window.userToken = ​<em class="string">"</em>​​<em class="comment">&lt;%=</em>​ assigns[​<em class="string">:user_token</em>​] ​<em class="comment">%&gt;</em>​​<em class="string">"</em>​&lt;/script&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;script type=​<em class="string">"text/javascript"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">          src=​<em class="string">"</em>​​<em class="comment">&lt;%=</em>​ Routes.static_url(@conn, ​<em class="string">"</em>​​<em class="string">/js/app.js"</em>​) ​<em class="comment">%&gt;</em>​​<em class="string">"</em>​&gt;&lt;/script&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;/body&gt;</td></tr></table>
<p id="calibre_link-1623" class="calibre19">Just before our <span class="cf">app.js</span> script, we render a <span class="cf">script</span> tag that
attaches a <span class="cf">userToken</span> variable to the window from our layout
<span class="cf">assigns</span>.</p>
<p id="calibre_link-1624" class="calibre19">

Next, we need to add the <span class="cf">:user_token</span> to <span class="cf">conn.assigns</span> whenever we
have a current user. We already have code to assign the current user
in <span class="cf">RumblWeb.Auth</span>, so let’s handle this there:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/lib/rumbl_web/controllers/auth.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/lib/rumbl_web/controllers/auth.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ call(conn, _opts) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  user_id = get_session(conn, ​<em class="string">:user_id</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">cond</strong>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">    user = conn.assigns[​<em class="string">:current_user</em>​] -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      put_current_user(conn, user) </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    user = user_id &amp;&amp; Rumbl.Accounts.get_user(user_id) -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      put_current_user(conn, user) </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    true -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      assign(conn, ​<em class="string">:current_user</em>​, nil)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ login(conn, user) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  |&gt; put_current_user(user) </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  |&gt; put_session(​<em class="string">:user_id</em>​, user.id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">20:&nbsp;</span></td><td class="codeline">  |&gt; configure_session(​<em class="string">renew:</em>​ true)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">defp</strong>​ put_current_user(conn, user) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  token = Phoenix.Token.sign(conn, ​<em class="string">"</em>​​<em class="string">user socket"</em>​, user.id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">25:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  conn</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  |&gt; assign(​<em class="string">:current_user</em>​, user)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  |&gt; assign(​<em class="string">:user_token</em>​, token)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1625" class="calibre19">We add a private <span class="cf">put_current_user</span> function to place a freshly
generated user token and the <span class="cf">current_user</span> into <span class="cf">conn.assigns</span>, which
we call on lines 6,  9, and 18. Now, any time a user session exists, both
<span class="cf">:current_user</span> and <span class="cf">:user_token</span> will be set, and the <span class="cf">:user_token</span>
will hold the signed-in user ID.</p>
<p id="calibre_link-1626" class="calibre19">The last step is to pass the user token to the <span class="cf">Socket</span> constructor on the client, and then
verify it in our <span class="cf">UserSocket.connect</span> callback. If you open up your
<span class="cf">assets/js/socket.js</span> file, you can see that we prepared for this
by passing up the <span class="cf">window.userToken</span> value as a <span class="cf">token</span> parameter,
like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/assets/js/socket.change1.js" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/assets/js/socket.change1.js</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">let</strong>​ socket = ​<strong class="kw">new</strong>​ Socket(​<em class="string">"/socket"</em>​, {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  params: {token: window.userToken},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  logger: (kind, msg, data) =&gt; { console.log(​<em class="string">`</em>​${kind}​<em class="string">: </em>​${msg}​<em class="string">`</em>​, data) }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">})</td></tr></table>
<p id="calibre_link-1627" class="calibre19">
Any <span class="cf">:params</span> we pass to the socket constructor will be available as
the first argument in <span class="cf">UserSocket.connect</span>. Let’s verify the params on
connect and store our <span class="cf">current_user</span> ID in the socket. Update your <span class="cf">UserSocket</span> with
the following code:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/lib/rumbl_web/channels/user_socket.change2.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/lib/rumbl_web/channels/user_socket.change2.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">@max_age 2 * 7 * 24 * 60 * 60</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ connect(%{​<em class="string">"</em>​​<em class="string">token"</em>​ =&gt; token}, socket, _connect_info) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">case</strong>​ Phoenix.Token.verify(</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    socket,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">"</em>​​<em class="string">user socket"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    token,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">max_age:</em>​ @max_age</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, user_id} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      {​<em class="string">:ok</em>​, assign(socket, ​<em class="string">:user_id</em>​, user_id)}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:error</em>​, _reason} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<em class="string">:error</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ connect(_params, _socket, _connect_info), ​<strong class="kw">do</strong>​: ​<em class="string">:error</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ id(socket), ​<strong class="kw">do</strong>​: ​<em class="string">"</em>​​<em class="string">users_socket:</em>​​<em class="string">#{</em>​socket.assigns.user_id​<em class="string">}</em>​​<em class="string">"</em>​</td></tr></table>
<p id="calibre_link-1628" class="calibre19">

We use <span class="cf">Phoenix.Token.verify</span> to verify the user token provided by the
client. We pass a <span class="cf">max_age</span>, ensuring that tokens
are only valid for a certain period of time; in this case, we set the
value to about two weeks. If the token is valid, we receive the
<span class="cf">user_id</span> and store it in our <span class="cf">socket.assigns</span> while returning <span class="cf">{:ok,
socket}</span> to establish the connection. If the token is invalid, we
return <span class="cf">:error</span>, denying the connection attempt by the client.</p>
<p id="calibre_link-1629" class="calibre19">



Remember, the socket keeps its state for the whole duration of the
connection, not just for a single response. Any <span class="cf">socket.assigns</span> you
place in the socket during <span class="cf">connect</span> will be available in your
channel’s <span class="cf">socket.assigns</span> map.</p>
<p id="calibre_link-1630" class="calibre19">Now, refresh your page. The application should work as before, but now
with user authentication. We have a logged-in user. so we can move on
to persist our annotations.







</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-304"><div id="calibre_link-1631" class="calibre2"><h2 id="calibre_link-135" class="calibre20">Persisting Annotations</h2>
<p id="calibre_link-1632" class="calibre19">


Now that we have in-memory annotations going across all connected clients through an authenticated user, let’s extend our multimedia context to attach those annotations to videos and users in the database. You’ve seen how we manage schemas and relationships with Ecto so the process will be straightforward. In this case, we’re creating annotations on videos. Each new annotation will belong to both a user and a video.</p>
<p id="calibre_link-1633" class="calibre19">


 You can use the <span class="cf">phx.gen.schema</span> generator, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">phx.gen.schema</strong>​​<strong class="kw"> </strong>​​<strong class="kw">Multimedia.Annotation</strong>​​<strong class="kw"> </strong>​​<strong class="kw">annotations</strong>​​<strong class="kw"> </strong>​​<strong class="kw">body:text</strong>​​<strong class="kw"> </strong>​​<strong class="kw">\</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">at:integer</strong>​​<strong class="kw"> </strong>​​<strong class="kw">user_id:references:users</strong>​​<strong class="kw"> </strong>​​<strong class="kw">video_id:references:videos</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating lib/rumbl/multimedia/annotation.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating priv/repo/migrations/20180726203443_create_annotations.exs</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Remember to update your repository by running migrations:</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">    $ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">ecto.migrate</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$</span>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">----</strong>​​<strong class="kw"> </strong>​​<strong class="kw">END</strong>​​<strong class="kw"> </strong>​​<strong class="kw">OF</strong>​​<strong class="kw"> </strong>​​<strong class="kw">OUTPUT</strong>​​<strong class="kw"> </strong>​​<strong class="kw">----</strong>​</td></tr></table>
<p id="calibre_link-1634" class="calibre19">And now you can migrate your database:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">ecto.migrate</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] == Running Rumbl.Repo.Migrations.CreateAnnotations.change/0 forward</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] create table annotations</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] create index annotations_user_id_index</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] create index annotations_video_id_index</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] == Migrated in 0.1s</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$</span>​</td></tr></table>
<p id="calibre_link-1635" class="calibre19">Our migrations are in, with our new table and two new indexes.</p>
<p id="calibre_link-1636" class="calibre19">
Next, we need to wire up our new relationships to our <span class="cf">Accounts.User</span> and <span class="cf">Multimedia.Video</span> schemas. Both users and videos will have annotations, but we need to decide where to surface these schema details within our contexts. Details like these will make or break an API. Allowing access to every possible type of data that may ever be associated with a user would probably lead to a tedious, bloated API and conflate the purpose of our Accounts context. We’ll provide only enough functions to comfortably do the job at hand.</p>
<p id="calibre_link-1637" class="calibre19">
For now, we’ll tentatively expose annotations strictly through the Multimedia context since the <span class="cf">Accounts.User</span> schema should not need to know about <span class="cf">Multimedia.Annotations</span>. If an application needs change in the future, we can revisit this decision. Add the <span class="cf">has_many</span> relationship to the <span class="cf">Multimedia.Video</span> schema blocks in <span class="cf">lib/rumbl/multimedia/video.ex</span>, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">has_many ​<em class="string">:annotations</em>​, Rumbl.Multimedia.Annotation</td></tr></table>
<p id="calibre_link-1638" class="calibre19">
Next, let’s update our generated <span class="cf">Annotation</span> schema in <span class="cf">lib/rumbl/multimedia/annotation.ex</span>. Right now, both <span class="cf">user_id</span> and <span class="cf">video_id</span> are simple schema fields. We’ll want to manage annotation lists through Ecto so let’s upgrade them to be first class  <span class="cf">belongs_to</span> relationships, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/lib/rumbl/multimedia/annotation.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/lib/rumbl/multimedia/annotation.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">schema ​<em class="string">"</em>​​<em class="string">annotations"</em>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  field ​<em class="string">:at</em>​, ​<em class="string">:integer</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  field ​<em class="string">:body</em>​, ​<em class="string">:string</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  belongs_to ​<em class="string">:user</em>​, Rumbl.Accounts.User</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  belongs_to ​<em class="string">:video</em>​, Rumbl.Multimedia.Video</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  timestamps()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1639" class="calibre19">We will want to read and write our video annotations from within our channels. Just as we did within our controllers, we’ll want to access those features from our <span class="cf">Multimedia</span> context rather than the schema. Let’s add those features to our context. Open up <span class="cf">lib/rumbl/multimedia.ex</span> and add functions to list and create annotations, like so:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/lib/rumbl/multimedia.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/lib/rumbl/multimedia.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">alias Rumbl.Multimedia.Annotation</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ annotate_video(%Accounts.User{​<em class="string">id:</em>​ user_id}, video_id, attrs) ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  %Annotation{​<em class="string">video_id:</em>​ video_id, ​<em class="string">user_id:</em>​ user_id}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">  |&gt; Annotation.changeset(attrs)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  |&gt; Repo.insert()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ list_annotations(%Video{} = video) ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">  Repo.all(</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    from a ​<strong class="kw">in</strong>​ Ecto.assoc(video, ​<em class="string">:annotations</em>​),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      ​<em class="string">order_by:</em>​ [​<em class="string">asc:</em>​ a.at, ​<em class="string">asc:</em>​ a.id],</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      ​<em class="string">limit:</em>​ 500,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      ​<em class="string">preload:</em>​ [​<em class="string">:user</em>​]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline">  )</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1640" class="calibre19">

On line 3, we added an <span class="cf">annotate_video</span> function, which accepts a user, video ID, and attributes for the annotation. In that function, we build an annotation struct with the video ID and user ID. We pipe that struct to <span class="cf">changeset</span> to create our changeset, and then pipe the completed record to <span class="cf">Repo.insert</span>. We could have used <span class="cf">Ecto.Changeset.put_assoc</span> to put both user and video associations, but setting the foreign keys directly gives the same end result.</p>
<p id="calibre_link-1641" class="calibre19">


To fetch a list of annotations for a given video, we defined the <span class="cf">list_annotations</span> on line 9. It’s just a simple Ecto query. We put in a high limit to make sure we don’t bring back too many records to handle, and we preloaded the user. Remember, if you want to use data in an association, you need to fetch it explicitly. You’ve seen queries like this before in Chapter 6, <a href="#calibre_link-103" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">​<em class="calibre4">Generators and Relationships</em>​</a>.</p>
<p id="calibre_link-1642" class="calibre19">Now, all that remains is to head back to our <span class="cf">VideoChannel</span> and integrate our callbacks to use the new context features. Open up the video channel and make these modifications:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/lib/rumbl_web/channels/video_channel.change3.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/lib/rumbl_web/channels/video_channel.change3.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">alias Rumbl.{Accounts, Multimedia}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ join(​<em class="string">"</em>​​<em class="string">videos:"</em>​ &lt;&gt; video_id, _params, socket) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  {​<em class="string">:ok</em>​, assign(socket, ​<em class="string">:video_id</em>​, String.to_integer(video_id))}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ handle_in(event, params, socket) ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  user = Accounts.get_user!(socket.assigns.user_id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  handle_in(event, params, user, socket)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ handle_in(​<em class="string">"</em>​​<em class="string">new_annotation"</em>​, params, user, socket) ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">case</strong>​ Multimedia.annotate_video(user, socket.assigns.video_id, params) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, annotation} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline">      broadcast!(socket, ​<em class="string">"</em>​​<em class="string">new_annotation"</em>​, %{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">        ​<em class="string">id:</em>​ annotation.id,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">        ​<em class="string">user:</em>​ RumblWeb.UserView.render(​<em class="string">"</em>​​<em class="string">user.json"</em>​, %{​<em class="string">user:</em>​ user}), </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">        ​<em class="string">body:</em>​ annotation.body,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">        ​<em class="string">at:</em>​ annotation.at</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">20:&nbsp;</span></td><td class="codeline">      })</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      {​<em class="string">:reply</em>​, ​<em class="string">:ok</em>​, socket}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    {​<em class="string">:error</em>​, changeset} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      {​<em class="string">:reply</em>​, {​<em class="string">:error</em>​, %{​<em class="string">errors:</em>​ changeset}}, socket}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">25:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1643" class="calibre19">







First, we ensure that all incoming events have the current user by
defining a new <span class="cf">handle_in/3</span> function on line 7. It catches all incoming events, looks
up the user from the socket assigns, and then calls a <span class="cf">handle_in/4</span>
clause with the socket user as a third argument.</p>
<p id="calibre_link-1644" class="calibre19">Next, we call our <span class="cf">Multimedia.annotate_video</span> function. On success, we broadcast to all subscribers as before. Otherwise, we return a response with the changeset errors. After we broadcast, we acknowledge the success by returning <span class="cf">{:reply, :ok, socket}</span>.</p>
<p id="calibre_link-1645" class="calibre19">


We could have decided not to send a reply with <span class="cf">{:noreply, socket}</span>,
but it’s common practice to acknowledge the result of the pushed
message from the client. This approach allows the client to easily
implement UI features such as loading statuses and error
notifications, even if we’re only replying with an <span class="cf">:ok</span> or <span class="cf">:error</span>
status and no other information.</p>
<p id="calibre_link-1646" class="calibre19">
Since we also want to notify subscribers about the user who posted the
annotation, we render a <span class="cf">user.json</span> template from our <span class="cf">UserView</span> on
line 17. Let’s implement that now:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/lib/rumbl_web/views/user_view.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/lib/rumbl_web/views/user_view.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ RumblWeb.UserView ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ RumblWeb, ​<em class="string">:view</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  alias Rumbl.Accounts</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ first_name(%Accounts.User{​<em class="string">name:</em>​ name}) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    name</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; String.split(​<em class="string">"</em>​​<em class="string"> "</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; Enum.at(0)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ render(​<em class="string">"</em>​​<em class="string">user.json"</em>​, %{​<em class="string">user:</em>​ user}) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    %{​<em class="string">id:</em>​ user.id, ​<em class="string">username:</em>​ user.username}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1647" class="calibre19">Now let’s head back to the app and post a few annotations. Watch your
server logs as the posts are submitted, and you can see your insert
logs:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[debug] INCOMING "new_annotation" on "videos:1" to RumblWeb.VideoChannel</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Parameters: %{"at" =&gt; 0, "body" =&gt; "testing"}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">begin []</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[debug] QUERY OK db=20.3ms</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">INSERT INTO "annotations" ("at","body","user_id","video_id",...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[debug] QUERY OK db=0.6ms</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">commit []</td></tr></table>
<p id="calibre_link-1648" class="calibre19">And we have persisted data!</p>
<p id="calibre_link-1649" class="calibre19">




We have a problem, though. Refresh your page, and the messages
disappear from the UI. They’re still in the database, but we need to
pass the messages to the client when a user joins the channel. We
could do this by pushing an event to the client after each user joins,
but Phoenix provides a 3-tuple join signature to both join the channel
and send a join response at the same time.</p>
<p id="calibre_link-1650" class="calibre19">Let’s update our
<span class="cf">VideoChannel</span>’s <span class="cf">join</span> callback to pass down a list of annotations:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/lib/rumbl_web/channels/video_channel.change4.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/lib/rumbl_web/channels/video_channel.change4.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">alias RumblWeb.AnnotationView</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ join(​<em class="string">"</em>​​<em class="string">videos:"</em>​ &lt;&gt; video_id, _params, socket) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  video_id = String.to_integer(video_id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  video = Multimedia.get_video!(video_id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  annotations =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    video</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; Multimedia.list_annotations()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; Phoenix.View.render_many(AnnotationView, ​<em class="string">"</em>​​<em class="string">annotation.json"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {​<em class="string">:ok</em>​, %{​<em class="string">annotations:</em>​ annotations}, assign(socket, ​<em class="string">:video_id</em>​, video_id)}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1651" class="calibre19">



Here, we rewrite <span class="cf">join</span> to get the video from our Multimedia context. Then, we list the video’s annotations combined with something new. We compose a response by rendering an
<span class="cf">annotation.json</span> view for every annotation in our list. Instead of
building the list by hand, we use <span class="cf">Phoenix.View.render_many</span>. The
<span class="cf">render_many</span> function collects the render results for all elements in
the enumerable passed to it. We use the view to present our data, so
we offload this work to the view layer so the channel layer can focus
on messaging.</p>
<p id="calibre_link-1652" class="calibre19">Create an <span class="cf">AnnotationView</span> in <span class="cf">lib/rumbl_web/views/annotation_view.ex</span> to serve as each individual annotation, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/lib/rumbl_web/views/annotation_view.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/lib/rumbl_web/views/annotation_view.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ RumblWeb.AnnotationView ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ RumblWeb, ​<em class="string">:view</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ render(​<em class="string">"</em>​​<em class="string">annotation.json"</em>​, %{​<em class="string">annotation:</em>​ annotation}) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    %{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<em class="string">id:</em>​ annotation.id,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<em class="string">body:</em>​ annotation.body,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<em class="string">at:</em>​ annotation.at,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<em class="string">user:</em>​ render_one(annotation.user, RumblWeb.UserView, ​<em class="string">"</em>​​<em class="string">user.json"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1653" class="calibre19">
Notice the <span class="cf">render_one</span> call for the annotation’s user. Phoenix’s view
layer neatly embraces functional composition. The <span class="cf">render_one</span>
function provides conveniences such as handling possible <span class="cf">nil</span>
results.</p>
<p id="calibre_link-1654" class="calibre19">Lastly, we return a 3-tuple from <span class="cf">join</span> of the form <span class="cf">{:ok, response,
socket}</span> to pass the response down to the <span class="cf">join</span> event. Let’s pick up
this response on the client to build the list of messages.</p>
<p id="calibre_link-1655" class="calibre19">Update your <span class="cf">vidChannel.join()</span> callbacks to render a list of
annotations received on join:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/assets/js/video.change5.js" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/assets/js/video.change5.js</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">vidChannel.join()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  .receive(​<em class="string">"ok"</em>​, ({annotations}) =&gt; {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    annotations.forEach( ann =&gt; ​<strong class="kw">this</strong>​.renderAnnotation(msgContainer, ann) )</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  })</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  .receive(​<em class="string">"error"</em>​, reason =&gt; console.log(​<em class="string">"join failed"</em>​, reason) )</td></tr></table>
<p id="calibre_link-1656" class="calibre19">


Refresh your browser and see your history of messages appear
immediately!</p><div class="praise"><img id="calibre_link-1657" class="calibre49" src="images/000037.png" alt="images/src/channels/persisted-annotations.png" /></div>
<p id="calibre_link-1658" class="calibre19">


Now that we have our message history on join, we need to schedule the
annotations to appear synced up with the video playback. Update
<span class="cf">video.js</span>, like the following:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/assets/js/video.change6.js" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/assets/js/video.change6.js</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  vidChannel.join()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    .receive(​<em class="string">"ok"</em>​, resp =&gt; {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<strong class="kw">this</strong>​.scheduleMessages(msgContainer, resp.annotations)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    })</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    .receive(​<em class="string">"error"</em>​, reason =&gt; console.log(​<em class="string">"join failed"</em>​, reason) )</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">renderAnnotation(msgContainer, {user, body, at}){</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">let</strong>​ template = document.createElement(​<em class="string">"div"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  template.innerHTML = ​<em class="string">`</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">  &lt;a href="#" data-seek="</em>​${​<strong class="kw">this</strong>​.esc(at)}​<em class="string">"&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">    [</em>​${​<strong class="kw">this</strong>​.formatTime(at)}​<em class="string">]</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">    &lt;b&gt;</em>​${​<strong class="kw">this</strong>​.esc(user.username)}​<em class="string">&lt;/b&gt;: </em>​${​<strong class="kw">this</strong>​.esc(body)}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">  &lt;/a&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">  `</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  msgContainer.appendChild(template)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  msgContainer.scrollTop = msgContainer.scrollHeight</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">scheduleMessages(msgContainer, annotations){</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  clearTimeout(​<strong class="kw">this</strong>​.scheduleTimer)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">this</strong>​.schedulerTimer = setTimeout(() =&gt; {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">let</strong>​ ctime = Player.getCurrentTime()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">let</strong>​ remaining = ​<strong class="kw">this</strong>​.renderAtTime(annotations, ctime, msgContainer)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">this</strong>​.scheduleMessages(msgContainer, remaining)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  }, 1000)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">renderAtTime(annotations, seconds, msgContainer){</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">return</strong>​ annotations.filter( ann =&gt; {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">if</strong>​(ann.at &gt; seconds){</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<strong class="kw">return</strong>​ ​<strong class="kw">true</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    } ​<strong class="kw">else</strong>​ {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<strong class="kw">this</strong>​.renderAnnotation(msgContainer, ann)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<strong class="kw">return</strong>​ ​<strong class="kw">false</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  })</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">formatTime(at){</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">let</strong>​ date = ​<strong class="kw">new</strong>​ Date(​<strong class="kw">null</strong>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  date.setSeconds(at / 1000)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">return</strong>​ date.toISOString().substr(14, 5)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">},</td></tr></table>
<p id="calibre_link-1659" class="calibre19">



There’s a lot of code here, but it’s relatively simple. Instead of
rendering all annotations immediately on join, we schedule them to
render based on the current player time. The <span class="cf">scheduleMessages</span>
function starts an interval timer that fires every second. Now, each
time our timer ticks, we call <span class="cf">renderAtTime</span> to find all annotations
occurring at or before the current player time.</p>
<p id="calibre_link-1660" class="calibre19">
In <span class="cf">renderAtTime</span>, we filter all the messages by time while rendering
those that should appear in the timeline. For those yet to appear, we
return <span class="cf">true</span> to keep a tab on the remaining annotations to filter on
the next call. Otherwise, we render the annotation and return <span class="cf">false</span>
to exclude it from the remaining set.</p>
<p id="calibre_link-1661" class="calibre19">You can see the end result. We have a second-by-second annotation feed
based on the current video playback. Refresh your browser and let’s
give it a shot. Try posting a few new annotations at different points,
and then refresh. Start playing the video, and then watch your
annotations appear synced up with the playback time, as you can see in
<a href="#calibre_link-305" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">the screenshot</a>.</p><div id="calibre_link-305" class="praise"><div class="praise"><img id="calibre_link-1662" class="border8" src="images/000008.png" alt="images/src/channels/annotation-seek.png" width="900" height="522" /></div></div>
<p id="calibre_link-1663" class="calibre19">






We wired up a <span class="cf">data-seek</span> attribute on our <span class="cf">renderAnnotation</span>
template, but we haven’t done anything with it yet. Let’s support
having the annotations clickable so we can jump to the exact time the
annotation was made by clicking it. Add this click handler above your
<span class="cf">vidChannel.join()</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/assets/js/video.change6.js" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/assets/js/video.change6.js</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">msgContainer.addEventListener(​<em class="string">"click"</em>​, e =&gt; {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  e.preventDefault()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">let</strong>​ seconds = e.target.getAttribute(​<em class="string">"data-seek"</em>​) ||</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">                e.target.parentNode.getAttribute(​<em class="string">"data-seek"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">if</strong>​(!seconds){ ​<strong class="kw">return</strong>​ }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Player.seekTo(seconds)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">})</td></tr></table>
<p id="calibre_link-1664" class="calibre19">Now, clicking an annotation will move the player to the time the
annotation was made. Cool!</p>
<p id="calibre_link-1665" class="calibre19">Before we get too excited, we have one more problem to solve. We need
to address a critical issue when dealing with disconnects between the
client and server.



</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-18"><div id="calibre_link-1666" class="calibre2"><h2 id="calibre_link-136" class="calibre20">Handling Disconnects</h2>
<p id="calibre_link-1667" class="calibre19">







Any stateful conversation between a client and server must handle data
that gets out of sync. This problem can happen with unexpected
disconnects, or a broadcast that isn’t received while a client is
away. We need to handle both cases. Let’s find out how.</p>
<p id="calibre_link-1668" class="calibre19">

Our JavaScript client can disconnect and reconnect for a number of
different reasons. Our server might be restarted, a rumbler might
drive under a bridge, or our Internet connection may just be poor. We
simply can’t assume network reliability when designing our real-time
systems. Fire up your server and visit one of your videos. Post a few
annotations and then kill the server in your terminal. The client
immediately begins trying to reestablish a connection using
exponential back-off. Wait a few seconds. Then, you can restart the
server with <span class="cf">mix phx.server</span>. Within a few seconds, you’ll see
something similiar to what is shown in the <a href="#calibre_link-19" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">screenshot</a>.</p><div class="praise"><img id="calibre_link-19" class="border9" src="images/000013.png" alt="images/src/channels/persisted-annotations-dupped.png" /></div>
<p id="calibre_link-1669" class="calibre19">
That’s not good. When the client reconnected, our client rejoined our
<span class="cf">VideoChannel</span> and the server returned all the annotations for this
video, causing our client to append duplicate annotations to the ones
it already had. You might be tempted to have the client detect
duplicate annotations and ignore them, but we want to fetch as little
data as required from the server, so there’s a better way.</p>
<p id="calibre_link-1670" class="calibre19">
We can track a <span class="cf">last_seen_id</span> on the client and bump this value every
time we see a new annotation. Then whenever we rejoin following a
crash or disconnect, we can send our <span class="cf">last_seen_id</span> to the server.
That way, we send only the data we missed. This technique keeps us
from worrying about buffering messages on the server for clients that
might never reconnect. We get back only the data that we need. Let’s
make it happen.</p>
<p id="calibre_link-1671" class="calibre19">Open up your <span class="cf">assets/js/video.js</span> and make the following changes to your <span class="cf">vidChannel</span> instantiation:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/assets/js/video.change7.js" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/assets/js/video.change7.js</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">onReady(videoId, socket){</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">2:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">let</strong>​ msgContainer = document.getElementById(​<em class="string">"msg-container"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">3:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">let</strong>​ msgInput     = document.getElementById(​<em class="string">"msg-input"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">4:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">let</strong>​ postButton   = document.getElementById(​<em class="string">"msg-submit"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">let</strong>​ lastSeenId   = 0</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">6:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">let</strong>​ vidChannel   = socket.channel(​<em class="string">"videos:"</em>​ + videoId, () =&gt; {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">7:&nbsp;</span></td><td class="codeline">    ​<strong class="kw">return</strong>​ {last_seen_id: lastSeenId} </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">8:&nbsp;</span></td><td class="codeline">  })</td></tr></table>
<p id="calibre_link-1672" class="calibre19">

On line 7, we added a new variable declaration to track our client’s <span class="cf">lastSeenId</span>. We also use <span class="calibre4">channel params</span> for the first time. The second argument to <span class="cf">socket.channel</span> adds a params callback as a second argument. The <span class="cf">socket.channel</span> function accepts an optional params object or callback. Phoenix will now send those custom params when a user joins the channel. Our function simply returns our last seen ID.</p>
<p id="calibre_link-1673" class="calibre19">Our client is sending the <span class="cf">last_seen_id</span> parameter, but we still need to keep track of this value. Let’s do that now:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/assets/js/video.change7.js" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/assets/js/video.change7.js</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">vidChannel.on(​<em class="string">"new_annotation"</em>​, (resp) =&gt; {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  lastSeenId = resp.id </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">this</strong>​.renderAnnotation(msgContainer, resp)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">vidChannel.join()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  .receive(​<em class="string">"ok"</em>​, resp =&gt; {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">let</strong>​ ids = resp.annotations.map(ann =&gt; ann.id) </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">if</strong>​(ids.length &gt; 0){ lastSeenId = Math.max(...ids) }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">    ​<strong class="kw">this</strong>​.scheduleMessages(msgContainer, resp.annotations)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  })</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  .receive(​<em class="string">"error"</em>​, reason =&gt; console.log(​<em class="string">"join failed"</em>​, reason) )</td></tr></table>
<p id="calibre_link-1674" class="calibre19">



On line 2, we update <span class="cf">lastSeenId</span>. Our client will pass it up to the channel on subsequent joins. We modify this value whenever we receive a <span class="cf">new_annotation</span> event from the server.</p>
<p id="calibre_link-1675" class="calibre19">Next, we use a similar approach on line 8 within our <span class="cf">ok</span> callback on <span class="cf">join</span>.
We receive the list of annotations in the response as before, but this
time we grab the max annotation ID from the list and store it as the
<span class="cf">lastSeenId</span>. Now, whenever we call
<span class="cf">vidChannel.join()</span>&mdash;such as after reconnects&mdash;our parameter function will fire, providing the
<span class="cf">last_seen_id</span>. Let’s handle this new parameter on the server side
within our <span class="cf">VideoChannel</span>. To list annotations since a given ID, we need to expose this feature from our Multimedia context. Open up <span class="cf">lib/rumbl/multimedia.ex</span> and make the following change to your <span class="cf">list_annotations</span> function:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/lib/rumbl/multimedia.change2.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/lib/rumbl/multimedia.change2.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ list_annotations(%Video{} = video, since_id \\ 0) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">2:&nbsp;</span></td><td class="codeline">  Repo.all(</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">3:&nbsp;</span></td><td class="codeline">    from a ​<strong class="kw">in</strong>​ Ecto.assoc(video, ​<em class="string">:annotations</em>​),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">4:&nbsp;</span></td><td class="codeline">      ​<em class="string">where:</em>​ a.id &gt; ^since_id, </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">      ​<em class="string">order_by:</em>​ [​<em class="string">asc:</em>​ a.at, ​<em class="string">asc:</em>​ a.id],</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">6:&nbsp;</span></td><td class="codeline">      ​<em class="string">limit:</em>​ 500,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">7:&nbsp;</span></td><td class="codeline">      ​<em class="string">preload:</em>​ [​<em class="string">:user</em>​]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">8:&nbsp;</span></td><td class="codeline">  )</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">9:&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1676" class="calibre19">
We added an optional <span class="cf">since_id</span> argument which defaults to zero. Then we added a <span class="cf">where</span> clause in our query on line 4 to use this new value. With our context changes in place, we need to update our channel to look for <span class="cf">last_seen_id</span>. Open <span class="cf">lib/rumbl_web/channels/video_channel.ex</span> and update the <span class="cf">join</span> function:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/lib/rumbl_web/channels/video_channel.change5.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/lib/rumbl_web/channels/video_channel.change5.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ join(​<em class="string">"</em>​​<em class="string">videos:"</em>​ &lt;&gt; video_id, params, socket) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  last_seen_id = params[​<em class="string">"</em>​​<em class="string">last_seen_id"</em>​] || 0 </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  video_id = String.to_integer(video_id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  video = Multimedia.get_video!(video_id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  annotations =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    video</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    |&gt; Multimedia.list_annotations(last_seen_id) </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    |&gt; Phoenix.View.render_many(AnnotationView, ​<em class="string">"</em>​​<em class="string">annotation.json"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  {​<em class="string">:ok</em>​, %{​<em class="string">annotations:</em>​ annotations}, assign(socket, ​<em class="string">:video_id</em>​, video_id)}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1677" class="calibre19">
On line 2, we use the <span class="cf">params</span>
as the second argument to <span class="cf">join/3</span>. We check for an existing
<span class="cf">last_seen_id</span> value. To cover a fresh connection, we provide a
default value of <span class="cf">0</span> since the user has yet to see an annotation.</p>
<p id="calibre_link-1678" class="calibre19">Next, we modify our call to <span class="cf">Multimedia.list_annotations</span> by passing our <span class="cf">last_seen_id</span> on line 8.</p>
<p id="calibre_link-1679" class="calibre19">That’s it! If we try to re-create our duplicate entries, we’ll see the
client and server remain properly in sync across disconnects and
reconnects using the <span class="cf">last_seen_id</span> approach in the channel params.
Our approach is simple and direct.</p>
<p id="calibre_link-1680" class="calibre19">Now our workers can do work on Rumbl and we know that work will leave our data in a reliable state. Next, we’ll build a feature to make our application feel a little more social. Let’s make a list of who’s online.





</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-177"><div id="calibre_link-1681" class="calibre2"><h2 id="calibre_link-137" class="calibre20">Tracking Presence on a Channel</h2>
<p id="calibre_link-1682" class="calibre19">




Let’s track which users are watching a video. This problem may seem easy on the surface, but it’s a notoriously difficult computer science problem when multiple servers are involved. The users may be stored in different places, and we’ll need to access them. We’ll also need to clean up the data when users disconnect. If the connections between servers fail, we’ll need to make some decisions about how to calculate and present exactly who is present.</p>
<p id="calibre_link-1683" class="calibre19">Luckily, we won’t have to solve any of these problems because we can rely on Channel Presence to solve them for us. When we’re done, we’ll have no single point of failure and no single source of truth, an excellent attribute for a distributed solution. Since the entire solution is based on the standard Elixir library, you won’t have to add dependencies. Since it’s built on OTP, it is self-healing.</p><h3 class="calibre22">Generating Presence Files</h3>
<p id="calibre_link-1684" class="calibre19">
We’ll write a shockingly small amount of code to do all of this work. To get started, use the <span class="cf">mix phx.gen.presence</span> task to generate a presence module, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">phx.gen.presence</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating lib/rumbl_web/channels/presence.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...</span>​</td></tr></table>
<p id="calibre_link-1685" class="calibre19">The generated <span class="cf">lib/rumbl_web/channels/presence.ex</span> file sets up the module for presence, defining the functions we require for tracking presence on a channel. Next we need to add this module to our supervisor tree in <span class="cf">lib/rumbl/application.ex</span>, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">children = [</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  RumblWeb.Presence</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">]</td></tr></table>
<p id="calibre_link-1686" class="calibre19">

You’ve seen this code before. <span class="cf">Presence</span> is an OTP application so we need to add it to our supervision tree. That’s all of the setup work we need to do.</p><h3 class="calibre22">Tracking Presence in Channels</h3>
<p id="calibre_link-1687" class="calibre19">Let’s see how easy it is to track which users are online in our <span class="cf">VideoChannel</span>. Open up your
<span class="cf">lib/rumbl_web/channels/video_channel.ex</span> file and make the following changes:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/lib/rumbl_web/channels/video_channel.change6.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/lib/rumbl_web/channels/video_channel.change6.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ join(​<em class="string">"</em>​​<em class="string">videos:"</em>​ &lt;&gt; video_id, params, socket) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  send(self(), ​<em class="string">:after_join</em>​) </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  last_seen_id = params[​<em class="string">"</em>​​<em class="string">last_seen_id"</em>​] || 0</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  video_id = String.to_integer(video_id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">  video = Multimedia.get_video!(video_id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  annotations =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    video</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    |&gt; Multimedia.list_annotations(last_seen_id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">    |&gt; Phoenix.View.render_many(AnnotationView, ​<em class="string">"</em>​​<em class="string">annotation.json"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  {​<em class="string">:ok</em>​, %{​<em class="string">annotations:</em>​ annotations}, assign(socket, ​<em class="string">:video_id</em>​, video_id)}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ handle_info(​<em class="string">:after_join</em>​, socket) ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  push(socket, ​<em class="string">"</em>​​<em class="string">presence_state"</em>​, RumblWeb.Presence.list(socket))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  {​<em class="string">:ok</em>​, _} = RumblWeb.Presence.track(</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    socket,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    socket.assigns.user_id,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">20:&nbsp;</span></td><td class="codeline">    %{​<em class="string">device:</em>​ ​<em class="string">"</em>​​<em class="string">browser"</em>​})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  {​<em class="string">:noreply</em>​, socket}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1688" class="calibre19">

This code makes an important distinction between the <span class="calibre4">user</span> and a <span class="calibre4">session</span>. A user is a unique entity within the presence. A user can have multiple sessions, such as a single user with open browser tabs or multiple devices.</p>
<p id="calibre_link-1689" class="calibre19">

On line 2, we send ourself a user-defined message called <span class="cf">:after_join</span>. We’ll process that message in a <span class="cf">handle_info</span> callback that will be invoked after <span class="cf">join</span> successfully returns.</p>
<p id="calibre_link-1690" class="calibre19">



On line 15, we call a single presence function that does the lion’s share of the work, <span class="cf">RumblWeb.Presence.track</span>. This function accepts our <span class="cf">socket</span>, a key to track, and a map of metadata. The key is a <span class="calibre4">unique user identity</span>. We’ll pass <span class="cf">user_id</span> because it’s unique per Rumbl user. The metadata is any arbitrary data we want to associate with a session. We want to restrict this data to the essentials. Presence will maintain this data for the life of the user. Here, we hardcode a <span class="cf">device</span> as <span class="cf">"browser"</span> since we only support web clients today, but later a native mobile app speaking to our phoenix channel could be written, and we could show an icon next to our user list indicating the kind of device each user connected with.</p>
<p id="calibre_link-1691" class="calibre19">

To finish, we simply return our unchanged socket. When we track presence, we’re asking Phoenix to  track broadcast messages to our socket’s topic about users coming and going. These messages will automatically make it down the client like any other channel broadcast. In just a few lines of code, we’ve done all we need to do in our channel, so we can move on to our client.</p><h3 class="calibre22">Adding Presence to Templates</h3>
<p id="calibre_link-1692" class="calibre19">

The JavaScript Presence API takes care of all the housekeeping of synchronizing user info as users come and go. It also synchronizes data on reconnect. Before we display users on our web page, we need a place to show them. Open up your <span class="cf">lib/rumbl_web/templates/watch/show.html.eex</span> and add a new div container to the bottom of the file:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/lib/rumbl_web/templates/watch/show.html.eex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/lib/rumbl_web/templates/watch/show.html.eex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;hr/&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;div class=​<em class="string">"row"</em>​&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;div class=​<em class="string">"column"</em>​&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    &lt;h3&gt;Users&lt;/h3&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    &lt;ul id=​<em class="string">"user-list"</em>​&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    &lt;/ul&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;/div&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;/div&gt;</td></tr></table>
<p id="calibre_link-1693" class="calibre19">There’s no magic here. It’s just an empty <span class="cf">li</span> with an <span class="cf">id</span> of <span class="cf">user-list</span>. We’ll lean on JavaScript to populate it.</p><h3 class="calibre22">Using Channel Presence in JavaScript</h3>
<p id="calibre_link-1694" class="calibre19">Next, add this line to the top of <span class="cf">assets/js/video.js</span>:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">import</strong>​ {Presence} ​<strong class="kw">from</strong>​ ​<em class="string">"phoenix"</em>​</td></tr></table>
<p id="calibre_link-1695" class="calibre19">
We’re importing the library we’ll need to handle Channel Presence. With our HTML and import in place, make the following additions to your <span class="cf">onReady</span> function in the same file:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/assets/js/video.change8.js" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/assets/js/video.change8.js</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">onReady(videoId, socket){</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">let</strong>​ msgContainer = document.getElementById(​<em class="string">"msg-container"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">let</strong>​ msgInput     = document.getElementById(​<em class="string">"msg-input"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">let</strong>​ postButton   = document.getElementById(​<em class="string">"msg-submit"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">let</strong>​ userList     = document.getElementById(​<em class="string">"user-list"</em>​) </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">let</strong>​ lastSeenId   = 0</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">let</strong>​ vidChannel   = socket.channel(​<em class="string">"videos:"</em>​ + videoId, () =&gt; {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">return</strong>​ {last_seen_id: lastSeenId}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  })</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">let</strong>​ presence = ​<strong class="kw">new</strong>​ Presence(vidChannel)  </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  presence.onSync(() =&gt; { </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    userList.innerHTML = presence.list((id, {metas: [first, ...rest]}) =&gt; {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline">      ​<strong class="kw">let</strong>​ count = rest.length + 1</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      ​<strong class="kw">return</strong>​ ​<em class="string">`&lt;li&gt;</em>​${id}​<em class="string">: (</em>​${count}​<em class="string">)&lt;/li&gt;`</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    }).join(​<em class="string">""</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  })</td></tr></table>
<p id="calibre_link-1696" class="calibre19">

On line 5, we create a new <span class="cf">userList</span> reference to our HTML container. Next, we instantiate a new <span class="cf">Presence</span> object on line 11, passing in our <span class="cf">vidChannel</span>. Then, on line 13, we call the <span class="cf">onSync</span> callback to render our users as list items when users join or leave the application.</p>
<p id="calibre_link-1697" class="calibre19">


Here, we make use of the <span class="cf">presence.list</span> function that takes care of grouping any given user’s multiple presences into a single object. Remember,&nbsp;a single user in the system can be present on any number of browser tabs and devices. That means each <span class="cf">user_id</span> might have multiple pieces of session metadata. Your list function’s job is to determine which information to display about each user, given a session metadata list.</p>
<p id="calibre_link-1698" class="calibre19">In our callback, we simply render each user’s ID, and how many tabs or devices they are connected from. We get the count by referencing the size of their presence metadata list. Later, as Phoenix improves, we’ll show a browser icon for browser tabs and a mobile icon for mobile devices.  Save the file so we can try it out. <span class="cf">rumbl</span> now has a list of users:</p><div class="praise"><img id="calibre_link-1699" class="border10" src="images/000006.png" alt="images/src/channels/basic-user-list.png" /></div>
<p id="calibre_link-1700" class="calibre19">Though the output is a bit primitive, it works. We can see the users with ID 3 and 4 are online with a single tab open. Open and close additional tabs and check user’s session counts. They update instantly!
</p><h3 class="calibre22">Decorating Entries with Application Data</h3>
<p id="calibre_link-1701" class="calibre19">
Showing the user ID isn’t very friendly, but we can do better. Since our goal is to display a list of users online, we’ll need to add a username. While we could place the user’s name in the metadata for the client, this approach is frought with future misery. We’d be placing stale user data in our cluster and Channel Presence would diligently replicate that stale information across our cluster! There’s a better way.</p>
<p id="calibre_link-1702" class="calibre19">
<span class="cf">Phoenix.Presence</span> provides a <span class="cf">fetch</span> callback to solve this problem. As users join and leave the application across your cluster, Phoenix batches these events together to optimize performance and network chatter. Our <span class="cf">fetch</span> callback will fetch the data for <span class="calibre4">a batch of presences</span>, not just a single presence. Let’s build a context function to fetch the usernames for a list of ids in <span class="cf">lib/rumbl/accounts.ex</span>, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/lib/rumbl/accounts.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/lib/rumbl/accounts.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">import</strong>​ Ecto.Query</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ list_users_with_ids(ids) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Repo.all(from(u ​<strong class="kw">in</strong>​ User, ​<em class="string">where:</em>​ u.id ​<strong class="kw">in</strong>​ ^ids))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1703" class="calibre19">

In <span class="cf">list_users_with_ids</span>, we use Ecto to fetch users in the list of the IDs we provide and return users.</p>
<p id="calibre_link-1704" class="calibre19">Now, we need to decorate our presence information in <span class="cf">lib/rumbl_web/channels/presence.ex</span>, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/lib/rumbl_web/channels/presence.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/lib/rumbl_web/channels/presence.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ fetch(_topic, entries) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  users =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    entries</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; Map.keys()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; Rumbl.Accounts.list_users_with_ids()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    |&gt; Enum.into(%{}, ​<strong class="kw">fn</strong>​ user -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      {to_string(user.id), %{​<em class="string">username:</em>​ user.username}}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  for {key, %{​<em class="string">metas:</em>​ metas}} &lt;- entries, ​<em class="string">into:</em>​ %{} ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {key, %{​<em class="string">metas:</em>​ metas, ​<em class="string">user:</em>​ users[key]}}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1705" class="calibre19">


We implement the optional <span class="cf">fetch</span> callback in our presence module. We take the presence entries which is a map of <span class="cf">user_id</span> - <span class="cf">session_metadata</span> pairs. We pipe those keys into our new context function and then pipe those users through an anonymous function to build our metadata map with the usernames for each <span class="cf">user_id</span>.</p>
<p id="calibre_link-1706" class="calibre19">When we’re done building that <span class="cf">users</span> map, in a <span class="cf">for</span> comprehension we decorate our original presence <span class="cf">entries</span> with usernames. We could decorate the entry map with any data you please. Our only obligation is to carry over the original <span class="cf">:metas</span> information as it has the data necessary for tracking presence data over a client.</p>
<p id="calibre_link-1707" class="calibre19">All that remains is to wire the new information into the client. Head back over to <span class="cf">assets/js/video.js</span> and make the following change to the <span class="cf">presence.onSync</span> callback:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/channels/listings/rumbl/assets/js/video.change9.js" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">channels/listings/rumbl/assets/js/video.change9.js</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">presence.onSync(() =&gt; {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  userList.innerHTML = presence.list((id,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {user: user, metas: [first, ...rest]}) =&gt; {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<strong class="kw">let</strong>​ count = rest.length + 1</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<strong class="kw">return</strong>​ ​<em class="string">`&lt;li&gt;</em>​${user.username}​<em class="string">: (</em>​${count}​<em class="string">)&lt;/li&gt;`</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    }).join(​<em class="string">""</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">})</td></tr></table>
<p id="calibre_link-1708" class="calibre19">
We modified our <span class="cf">presence.onSync</span> callback to destruct the new <span class="cf">user</span> key from our presence information. Then, we modified our HTML string snippet to use the <span class="cf">user.username</span> instead of our ID. Let’s try it out!</p><div class="praise"><img id="calibre_link-1709" class="border11" src="images/000047.png" alt="images/src/channels/user-list-fetched.png" /></div>
<p id="calibre_link-1710" class="calibre19">And it works! Our presence data now has friendly usernames. In a remarkably few lines of code, we’ve implemented a distributed Channel Presence implementation that will allow our server to reliably track presence across a distributed cluster. We’ve done a lot of work in this chapter. It’s time to review.




</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-227"><div id="calibre_link-1711" class="calibre2"><h2 id="calibre_link-138" class="calibre20">Wrapping Up</h2>
<p id="calibre_link-1712" class="calibre19">In this chapter, you learned to build simple client/server APIs with
Phoenix channels. Though the problem had many layers, it was easy to
understand the flow because clients connected to servers, and both
sides maintained the connection until the conversation was over. Along
the way:</p><ul class="calibre28"><li class="calibre29">
<p id="calibre_link-1713" class="calibre31">You learned to connect to a server-side channel through an ES6
client.</p></li><li class="calibre29">
<p id="calibre_link-1714" class="calibre31">We built a server-side channel with both long-polling and WebSocket
support.</p></li><li class="calibre29">
<p id="calibre_link-1715" class="calibre31">We built a simple API to let users join a channel.</p></li><li class="calibre29">
<p id="calibre_link-1716" class="calibre31">We processed inbound messages from OTP with <span class="cf1">handle_info</span> and
channels with <span class="cf1">handle_in</span>.</p></li><li class="calibre29">
<p id="calibre_link-1717" class="calibre31">We sent broadcast messages with <span class="cf1">broadcast!</span>.</p></li><li class="calibre29">
<p id="calibre_link-1718" class="calibre31">We authenticated users with <span class="cf1">Phoenix.Token</span>.</p></li><li class="calibre29">
<p id="calibre_link-1719" class="calibre31">We persisted annotations with Ecto, and exposed those new features
through our Multimedia context.</p></li><li class="calibre29">
<p id="calibre_link-1720" class="calibre31">We used Channel Presence to track the list of users on a video channel.</p></li></ul>
<p id="calibre_link-1721" class="calibre19">Though channels are by far the most exciting feature of Phoenix, it
was far easier to build this code than it was to build the
request/response counterparts for our users. In the next chapter, we’ll focus on code organization using umbrellas. Along the way, we’ll use a visualization tool called Observer and address how to manage configuration with subprojects. Stay tuned!
</p>

<div class="footnotes">
<h4 class="calibre24">Footnotes</h4>
<dl class="calibre25">
<dt class="footnote-number"><a id="calibre_link-285" href="#calibre_link-228" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[29]</a></dt><dd class="calibre26">
<p id="calibre_link-1722" class="calibre27"><a href="https://babeljs.io/docs/learn-es2015/" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://babeljs.io/docs/learn-es2015/</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-191" href="#calibre_link-229" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[30]</a></dt><dd class="calibre26">
<p id="calibre_link-1723" class="calibre27"><a href="http://coap.technology/" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">http://coap.technology/</a></p></dd></dl></div>
<div class="copyright">Copyright © 2020, The Pragmatic Bookshelf.</div>




</div>



  </div>


<div class="calibre1" id="calibre_link-252"><div id="calibre_link-1724" class="calibre2"><h1 class="pcalibre6 chapter-title" id="calibre_link-139"><span class="chapter-number">
            Chapter
            11</span><br class="calibre18" /><span class="chapter-name">Observer and Umbrellas</span></h1>

<p id="calibre_link-1725" class="calibre19">
As we add sophistication to our <span class="cf">rumbl</span> application, you should begin to notice that the web pieces of the system aren’t like some of the other parts of the application. Both the channels and the MVC components support user interfaces and communicate directly with the business backend. It would be nice to be able to deal with the web and backend pieces of our system independently.</p>
<p id="calibre_link-1726" class="calibre19">



Most successful projects reach a point where it makes sense to break the main piece into smaller units. In this chapter, we are going to take you through the messy but necessary details of such a refactoring exercise. We’ll extract the web-centered and backend pieces of our application into their own projects called child applications. When we’re done, we’ll be able to test, develop and deploy each child app independently. Even so, our Rumbl project has features like user authentication, multimedia management, and persistence so we want conveniences for configuring and building them only once. We need some notion of a project that is a loose confederation of parts. In Elixir, that notion is called the <span class="calibre4">umbrella project</span>. Each application under an umbrella is called a <span class="calibre4">child application</span>.</p>
<p id="calibre_link-1727" class="calibre19">It would have been easy to build our application from scratch as an umbrella. It’s much harder to refactor existing applications into child apps under an umbrella, but we know many of our readers have the need to break down their growing monoliths. We’ll show you the refactoring process, but we’ll also show you how to start a project from scratch should you be so inclined.</p>
<p id="calibre_link-1728" class="calibre19">
Before we get started, let’s build a deeper intuition of precisely what “application” means in the context of an Elixir project. We will use a tool called Observer that ships with Erlang to offer a visualization of exactly what’s happening.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-286"><div id="calibre_link-1729" class="calibre2"><h2 id="calibre_link-140" class="calibre20">Introspecting Applications with Observer</h2>
<p id="calibre_link-1730" class="calibre19">

Every time we start our Rumbl application, we have multiple applications running side by side. Each of our dependencies is in fact its own application. Phoenix and Elixir itself are applications too! An Application in Elixir is a runtime concern with these responsibilities:</p><ul class="calibre28"><li class="calibre29">
<p id="calibre_link-1731" class="calibre31">Applications package our code. Every time we compile our <span class="cf1">rumbl</span> project, Mix prints “Generated rumbl app”. Open the file <span class="cf1">_build/dev/lib/rumbl/ebin/rumbl.app</span>. It mostly contains metadata about the application, such as its modules, processes, a description and more.</p></li><li class="calibre29">
<p id="calibre_link-1732" class="calibre31">Supervisors can start and stop applications as a unit. An application may have a supervision tree, which defines exactly which services to start when the application starts, and which services to shutdown when the application shuts down.




</p></li><li class="calibre29">
<p id="calibre_link-1733" class="calibre31">Applications provide unified configuration. Each application has its own environment, which is a key-value store to host application configuration.

</p></li></ul>
<p id="calibre_link-1734" class="calibre19">All of those responsibilities may feel a bit abstract. Let’s open up the fantastic Observer, a tool shipping with Erlang, to see how Applications look in practice. To take it for spin, start a new <span class="cf">iex -S mix</span> session and run this command:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ ​<em class="string">:observer</em>​.start()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">:ok</td></tr></table>
<p id="calibre_link-1735" class="calibre19">That command opens up an graphical user interface that looks like the <a href="#calibre_link-287" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">screenshot</a>.</p><div id="calibre_link-287" class="praise"><div class="praise"><img id="calibre_link-1736" class="border12" src="images/000040.png" alt="images/src/umbrella/observer-home.png" /></div></div>
<p id="calibre_link-1737" class="calibre19">


Observer is a great tool for understanding all running processes for your application. When you open it up, the initial tab gives you general information about Erlang and also statistics about your system and your application. The tabs let you access charts to visualize different aspects of your system, check out memory allocation, look at running processes, and the like.</p><table class="simpletable"><thead class="calibre33"><tr class="calibre34"><th colspan="2" class="outerlines"><p class="calibre31">You Might Not Have Observer Installed</p></th></tr></thead><tbody class="calibre35"><tr class="tr"><td class="calibre36">
               <img id="calibre_link-1738" class="calibre37" src="images/000039.png" alt="images/aside-icons/important.png" width="274" height="310" />
             </td><td class="calibre38">

<p class="calibre31">


Some package managers like to break the Erlang standard library into multiple packages. If <span class="cf1">:observer.start</span> doesn’t work, you might be missing the <span class="cf1">erlang-observer</span> (or similar) package.
</p>
</td></tr></tbody></table>
<p id="calibre_link-1739" class="calibre19">




Consider the Processes tab. You can see a list of all running processes in your system, providing a tremendous amount of visibility into the system. Remember that in Elixir, almost all state exists in your processes. With Observer, we can see the state of our entire system and who’s responsible for each piece. The process tab also includes the Message Queue (MsgQ) for each process. If a process has a very large message queue, it is likely that it is a bottleneck in your system. Therefore, ordering the processes by the Message Queue size can be a great way to spot bottlenecks, and that’s exactly what the Phoenix team did when optimizing their channels implementation to support more than 2 million connections on a single node.<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-206" href="#calibre_link-288">[31]</a></sup></p>
<p id="calibre_link-1740" class="calibre19">You won’t explore all tabs now, but let’s look at one more in particular: Applications. There, you can see all of the applications that run on your system as well as each application’s supervision tree. Click the Applications tab and explore some of the applications on the left-side panel. When you are ready, click the <span class="cf">Rumbl</span> entry. You can see something like the <a href="#calibre_link-289" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">figure</a>.</p><div id="calibre_link-289" class="praise"><div class="praise"><img id="calibre_link-1741" class="calibre50" src="images/000034.png" alt="images/src/umbrella/observer-rumbl.png" /></div></div>
<p id="calibre_link-1742" class="calibre19">



That’s the <span class="cf">rumbl</span> supervision tree, more or less. Because we started <span class="cf">iex -S mix</span> and not <span class="cf">iex -S mix phx.server</span>, the server is missing from the tree. Still, there is a lot for us to explore. We can see the database connection pool, the PubSub system, and more. Inspecting our supervision trees is a great way to analyze how complex our systems are. If a supervision tree is growing too big or too wide, you can use Observer as a tool to help break the system apart.</p><table class="simpletable"><thead class="calibre33"><tr class="calibre34"><th colspan="2" class="outerlines"><p class="calibre31">You May Have a Different Supervision Tree</p></th></tr></thead><tbody class="calibre35"><tr class="tr"><td class="calibre36">
               <img id="calibre_link-1743" class="calibre37" src="images/000035.png" alt="images/aside-icons/info.png" width="283" height="300" />
             </td><td class="calibre38">

<p class="calibre31">


By the time we finished this book, the Phoenix team was already working on new features and enhancements to provide a more granular supervision tree. So if you are running on a Phoenix version later than Phoenix v1.4, you may see a slightly different tree than the one we showed here. We will talk about what’s coming in Chapter 14, <a href="#calibre_link-157" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">​<em class="calibre4">What’s Next?</em>​</a>. Regardless of the shape of the tree, all of the points made in this discussion still apply.
</p>
</td></tr></tbody></table>
<p id="calibre_link-1744" class="calibre19">



Observer also allows us to trigger failures. You can right-click a process in the tree, such as <span class="cf">Rumbl.Repo</span> and send it a kill signal, which will cause it to terminate. You’ll find a crash report in the terminal. However, since our services are supervised, the supervisor will notice the failure and start a new instance of the same service in its place.</p>
<p id="calibre_link-1745" class="calibre19">With a more solid understanding of what constitutes each application, let’s consider whether we might break our existing application into two smaller ones. Let’s be clear here: the main benefit is better boundaries. If all of the code belongs to a single application, then it gets harder to visualize how all of the modules in the same application depend on each other as the application grows.</p>
<p id="calibre_link-1746" class="calibre19">



For instance, while we expect our <span class="cf">RumblWeb</span> modules to call into our backend, we have an implicit understanding that it would be highly unexpected for <span class="cf">Rumbl</span> to call into <span class="cf">RumblWeb</span>. After all, one of the intents behind Phoenix contexts is to allow us to write our business rules without strongly coupling them to our web frontend, be it HTML, JSON, or channels. However, those rules are implicit in our <span class="cf">Rumbl</span> app today. By moving to an umbrella with two separate applications underneath, we can keep the web and the backend as two distinct applications which can only use each other if they have explicit dependencies between them.  For example, the web appplication will have to explicitly declare that it depends on the backend. For some teams, this may be a small benefit, but for others that enjoy strong boundaries, it makes a drastic difference.</p>
<p id="calibre_link-1747" class="calibre19">


You may have tried doing something similar to this in your previous work. You had a large application, you broke it apart into different Git repositories, and versioned them separately. Initially you were proud of the boundaries you were able to define but after working for a couple months under this new schema, you noticed you got less productive. A lot of time was spent navigating and reviewing code between the different repositories. While each project had their own version, their features were often developed together, and that required you and your team to constantly match and upgrade many packages whenever a new version of any given package was out. Umbrella projects provide an alternative to this. Instead of breaking applications into multiple distinct source-code repositories, which would add too much overhead to our development workflow, the applications in an umbrella are managed and versioned together, under the same repository.</p>
<p id="calibre_link-1748" class="calibre19">Let’s work on separating <span class="cf">rumbl</span> from <span class="cf">rumbl_web</span> now. We’re going to extract all of the web functionality to its own application. When we’re done, we’ll effectively have two isolated applications, <span class="cf">:rumbl</span> and <span class="cf">:rumbl_web</span>, in the same umbrella project. That approach will let us deploy, build, test, and package Rumbl as a whole.


</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-6"><div id="calibre_link-1749" class="calibre2"><h2 id="calibre_link-141" class="calibre20">Using Umbrellas</h2>
<p id="calibre_link-1750" class="calibre19">



In this section, we’re going to split our application into <span class="cf">rumbl_web</span>, containing the web components, and <span class="cf">rumbl</span>, containing all backend logic in our contexts. Each umbrella project has a parent directory that defines:</p><ul class="calibre28"><li class="calibre29">The shared configuration of the project</li><li class="calibre29">The dependencies for that project</li><li class="calibre29">The <span class="cf1">apps</span> directory with child applications</li></ul>
<p id="calibre_link-1751" class="calibre19">Let’s pick an approach that addresses each of these points. We need to choose between using generators and adjusting our existing app.</p><h3 class="calibre22">Choosing an Approach</h3>
<p id="calibre_link-1752" class="calibre19">
The main goal for umbrella applications is to give us the freedom to work with distinct pieces of the application independently, while still allowing convenient common overarching tasks. Now that we’ve identified the logical pieces to separate, let’s take a peek into the different approaches we might take.</p>
<p id="calibre_link-1753" class="calibre19">We could decide to roll all of this common structure and configuration by hand. We’d need to create an <span class="cf">apps</span> directory. Then we’d put the code for each child project into it’s own directory under <span class="cf">apps</span>. In each one, we’d create the common configuration and the individual configuration for each child app. Then we’d adjust the paths and application names where necessary within the child apps.</p>
<p id="calibre_link-1754" class="calibre19">It’s a process that works, but it’s also one that’s error prone. When possible, it’s best to <span class="calibre4">let Phoenix generators automate as much configuration as possible</span>. To prevent potential configuration errors, we’re not going to take this approach.</p>
<p id="calibre_link-1755" class="calibre19">

Now that we’ve ruled out refactoring by hand, we have two contenders to choose from. We could use <span class="cf">mix new</span> with an <span class="cf">--umbrella</span> flag, or <span class="cf">mix phx.new</span> with an <span class="cf">--umbrella</span> flag. We’ll choose the Phoenix generator since it will automate some of the web-based paths and configuration we need.</p><h3 class="calibre22">Creating a Skeleton</h3>
<p id="calibre_link-1756" class="calibre19">
Let’s create an umbrella project alongside the same directory of our existing <span class="cf">rumbl</span> application. Be sure to run the command outside of the existing <span class="cf">rumbl</span> application, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">[/rumbl]$ </span>​​<strong class="kw">cd</strong>​​<strong class="kw"> </strong>​​<strong class="kw">..</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">[~]$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">phx.new</strong>​​<strong class="kw"> </strong>​​<strong class="kw">rumbl</strong>​​<strong class="kw"> </strong>​​<strong class="kw">--umbrella</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating rumbl_umbrella/config/config.exs</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating rumbl_umbrella/config/dev.exs</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating rumbl_umbrella/config/test.exs</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating rumbl_umbrella/config/prod.exs</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating rumbl_umbrella/config/prod.secret.exs</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating rumbl_umbrella/mix.exs</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating rumbl_umbrella/apps/rumbl_web/lib/rumbl_web.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating rumbl_umbrella/apps/rumbl_web/lib/rumbl_web/application.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...</span>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating rumbl_umbrella/apps/rumbl_web/mix.exs</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating rumbl_umbrella/apps/rumbl_web/README.md</td></tr></table><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating rumbl_umbrella/apps/rumbl_web/.gitignore</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating rumbl_umbrella/apps/rumbl_web/test/test_helper.exs</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating rumbl_umbrella/apps/rumbl_web/test/support/channel_case.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating rumbl_umbrella/apps/rumbl_web/test/support/conn_case.ex</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...</span>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Fetch and install dependencies? [Yn] n</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...</span>​</td></tr></table>
<p id="calibre_link-1757" class="calibre19">Make sure to answer <span class="cf">n</span> to “Fetch and install dependencies?”. This project will not be a new application. Instead, we plan to use it as a skeleton for our existing application. We will need to copy our Elixir code and JavaScript assets from <span class="cf">rumbl</span> into this new project.</p>
<p id="calibre_link-1758" class="calibre19">You can see from the console output that Phoenix generated the <span class="cf">rumbl_application</span> with a top-level configuration and mix file. In addition, you can see the new <span class="cf">apps</span> directory that has two child applications,&nbsp;<span class="cf">rumbl</span> and <span class="cf">rumbl_web</span>. The generated <span class="cf">rumbl</span> application is a stock Elixir application with Ecto, and the <span class="cf">rumbl_web</span> application is a standard Phoenix project. Now you will see the method to our madness. Both projects are configured properly for an umbrella so we can copy over our code from the <span class="cf">rumbl</span> application we’ve been building and touch up some configuration code.</p><h3 class="calibre22">Understanding Umbrella Configuration</h3>
<p id="calibre_link-1759" class="calibre19">

It’s a great time to look at the various pieces of configuration in the old <span class="cf">rumbl</span> directory and our new project side by side as we go through this process. Before we copy our applications, let’s get the lay of the land, starting  with the generated mix file for <span class="cf">rumbl_web</span>. Let’s look at the <span class="cf">project</span> and <span class="cf">deps</span> functions in the new <span class="cf">rumbl_umbrella/apps/rumbl_web/mix.exs</span>:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ project ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  [</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">app:</em>​ ​<em class="string">:rumbl_web</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">version:</em>​ ​<em class="string">"</em>​​<em class="string">0.1.0"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">build_path:</em>​ ​<em class="string">"</em>​​<em class="string">../../_build"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">config_path:</em>​ ​<em class="string">"</em>​​<em class="string">../../config/config.exs"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">deps_path:</em>​ ​<em class="string">"</em>​​<em class="string">../../deps"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">lockfile:</em>​ ​<em class="string">"</em>​​<em class="string">../../mix.lock"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">elixir:</em>​ ​<em class="string">"</em>​​<em class="string">~&gt; 1.5"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">elixirc_paths:</em>​ elixirc_paths(Mix.env()),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">compilers:</em>​ [​<em class="string">:phoenix</em>​, ​<em class="string">:gettext</em>​] ++ Mix.compilers(),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">start_permanent:</em>​ Mix.env() == ​<em class="string">:prod</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">aliases:</em>​ aliases(),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">deps:</em>​ deps()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defp</strong>​ deps ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  [</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:phoenix</em>​, ​<em class="string">"</em>​​<em class="string">~&gt; 1.4.6"</em>​},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:rumbl</em>​, ​<em class="string">in_umbrella:</em>​ true},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1760" class="calibre19">Notice the <span class="cf">in_umbrella</span> flag in the dependency tuple for <span class="cf">:rumbl</span>. Now we can use the <span class="cf">:rumbl</span> application as a dependency of <span class="cf">:rumbl_web</span> and Elixir will automatically start it <span class="calibre4">before</span> starting the <span class="cf">:rumbl_web</span> server.</p>
<p id="calibre_link-1761" class="calibre19">




You can see the configurations for <span class="cf">:build_path</span>, <span class="cf">:config_path</span>, <span class="cf">:deps_path</span>, and <span class="cf">:lockfile</span>.  They point back to the umbrella application’s directory. That’s <span class="calibre4">all</span> it takes to make something an umbrella child. At the end of the day, Elixir simply configures the project to use the configuration, dependencies, and build paths from the parent application.</p>
<p id="calibre_link-1762" class="calibre19">


This configuration also tells us something very important about umbrella projects: <span class="calibre4">all children applications share the same configuration and the same dependencies</span>. Therefore, you can’t have two different applications in the same umbrella that depend on two different Phoenix versions. They all have to be the same. Similarly, if you have 10 applications that use Phoenix and there is a new Phoenix version, you can’t update the Phoenix version for each app individually, you will have to update all 10 at the same time. So, while umbrella projects do provide some isolation between children, all children still run on the same VM instance, sharing configuration and dependencies.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-55"><div id="calibre_link-1763" class="calibre2"><h2 id="calibre_link-142" class="calibre20">Extracting Rumbl and RumblWeb</h2>
<p id="calibre_link-1764" class="calibre19">With our tentative skeleton in place, we can start to put some meat on the bones. We have the code we need and it’s already organized as we want; we just need to move it from one application to the other.</p>
<p id="calibre_link-1765" class="calibre19">
Let’s copy the critical pieces of <span class="cf">rumbl</span> to the right child application of <span class="cf">rumbl_umbrella/apps</span>. We want to take advantage of the correct configuration that the <span class="cf">phx.new --umbrella</span> command generated. After we’ve extracted our app and web, and verified everything works, we’ll be in a good spot to build our information system in a separate apps directory later.</p><table class="simpletable"><thead class="calibre33"><tr class="calibre34"><th colspan="2" class="outerlines"><p class="calibre31">You’re Moving Code Without the Help of Corresponding Listings</p></th></tr></thead><tbody class="calibre35"><tr class="tr"><td class="calibre36">
               <img id="calibre_link-1766" class="calibre37" src="images/000039.png" alt="images/aside-icons/important.png" width="274" height="310" />
             </td><td class="calibre38">

<p class="calibre31">
  If you’re following along but mostly paying attention to the code listings, it’ll be easy for you to miss these next few changes, because the listings for the code you’ll be moving aren’t shown. Make sure you follow the directions in the following paragraph and numbered sequence.
</p>
</td></tr></tbody></table><h3 class="calibre22">Copying the <span class="cf">rumbl</span> Source Tree</h3>
<p id="calibre_link-1767" class="calibre19">


The first step is to move the source code in <span class="cf">lib</span> from the old app to the new. Copy the lib files from <span class="cf">rumbl/lib/rumbl/</span> to <span class="cf">rumbl_umbrella/apps/rumbl/lib</span>, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">cp</strong>​​<strong class="kw"> </strong>​​<strong class="kw">-R</strong>​​<strong class="kw"> </strong>​​<strong class="kw">rumbl/lib/rumbl</strong>​​<strong class="kw"> </strong>​​<strong class="kw">rumbl_umbrella/apps/rumbl/lib</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">cp</strong>​​<strong class="kw"> </strong>​​<strong class="kw">rumbl/lib/rumbl.ex</strong>​​<strong class="kw"> </strong>​​<strong class="kw">rumbl_umbrella/apps/rumbl/lib</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">cp</strong>​​<strong class="kw"> </strong>​​<strong class="kw">-R</strong>​​<strong class="kw"> </strong>​​<strong class="kw">rumbl/test/rumbl</strong>​​<strong class="kw"> </strong>​​<strong class="kw">rumbl_umbrella/apps/rumbl/test</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">cp</strong>​​<strong class="kw"> </strong>​​<strong class="kw">-R</strong>​​<strong class="kw"> </strong>​​<strong class="kw">rumbl/priv/repo</strong>​​<strong class="kw"> </strong>​​<strong class="kw">rumbl_umbrella/apps/rumbl/priv</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">cp</strong>​​<strong class="kw"> </strong>​​<strong class="kw">rumbl/test/support/data_case.ex</strong>​​<strong class="kw"> </strong>​​<strong class="kw">rumbl_umbrella/apps/rumbl/test/support</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">cp</strong>​​<strong class="kw"> </strong>​​<strong class="kw">rumbl/test/support/test_helpers.ex</strong>​​<strong class="kw"> </strong>​​<strong class="kw">\</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">     </strong>​​<strong class="kw">rumbl_umbrella/apps/rumbl/test/support</strong>​</td></tr></table>
<p id="calibre_link-1768" class="calibre19">




These commands just copy our code from the old structure to the new. We copy the <span class="cf">lib</span> files, then the <span class="cf">rumbl.ex</span> file, the tests, the repo, and specific test support files from one structure to the other. Keep in mind we’re using the Unix <span class="cf">cp</span> command and <span class="cf">/</span> directory navigation. If you’re using Windows, you will want to use <span class="cf">xcopy</span> for directories, <span class="cf">copy</span> for files, and <span class="cf">\</span> to separate directories. Make sure you copy folders recursively!</p>
<p id="calibre_link-1769" class="calibre19">
Next, we need to establish our dependencies. Let’s add <span class="cf">:pbkdf2_elixir</span> for authentication to the <span class="cf">rumbl_umbrella/apps/rumbl/mix.exs</span> <span class="cf">deps</span> function, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defp</strong>​ deps ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  [</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:ecto_sql</em>​, ​<em class="string">"</em>​​<em class="string">~&gt; 3.1"</em>​},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:postgrex</em>​, ​<em class="string">"</em>​​<em class="string">&gt;= 0.0.0"</em>​},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:pbkdf2_elixir</em>​, ​<em class="string">"</em>​​<em class="string">~&gt; 1.0"</em>​}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1770" class="calibre19">The new <span class="cf">rumbl</span> child app does not have a web component so it doesn’t need an endpoint. We need to remove the Endpoint supervisor from the rumbl application’s supervision tree. Update the <span class="cf">children</span> list in <span class="cf">rumbl_umbrella/apps/rumbl/lib/rumbl/application.ex</span>, keeping only the repository, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">children = [</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Rumbl.Repo,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">]</td></tr></table>
<p id="calibre_link-1771" class="calibre19">
Then remove the <span class="cf">config_change</span> function, as the endpoint is no longer a part of this application.
That should do it for the application cleanup.</p>
<p id="calibre_link-1772" class="calibre19">Let’s move on to the web apps.</p><h3 class="calibre22">Copying the Web Source Files</h3>
<p id="calibre_link-1773" class="calibre19">The web source tree in <span class="cf">lib</span> includes our templates, views, controllers, and channels. We also need to move the top-level <span class="cf">rumbl_web.ex</span> and tests over as well. Let’s do that now. Copy the files in <span class="cf">rumbl/lib/rumbl_web</span> to the new <span class="cf">apps/rumbl_web</span> directory:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">cp</strong>​​<strong class="kw"> </strong>​​<strong class="kw">-R</strong>​​<strong class="kw"> </strong>​​<strong class="kw">rumbl/lib/rumbl_web</strong>​​<strong class="kw"> </strong>​​<strong class="kw">rumbl_umbrella/apps/rumbl_web/lib</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">cp</strong>​​<strong class="kw"> </strong>​​<strong class="kw">rumbl/lib/rumbl_web.ex</strong>​​<strong class="kw"> </strong>​​<strong class="kw">rumbl_umbrella/apps/rumbl_web/lib</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">cp</strong>​​<strong class="kw"> </strong>​​<strong class="kw">-R</strong>​​<strong class="kw"> </strong>​​<strong class="kw">rumbl/test/rumbl_web</strong>​​<strong class="kw"> </strong>​​<strong class="kw">rumbl_umbrella/apps/rumbl_web/test</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">cp</strong>​​<strong class="kw"> </strong>​​<strong class="kw">rumbl/test/support/conn_case.ex</strong>​​<strong class="kw"> </strong>​​<strong class="kw">\</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">     </strong>​​<strong class="kw">rumbl_umbrella/apps/rumbl_web/test/support</strong>​</td></tr></table>
<p id="calibre_link-1774" class="calibre19">
Next, we need to update the <span class="cf">use</span> macro in <span class="cf">endpoint.ex</span> to point to the right <span class="cf">otp_app</span>. Change the second line in <span class="cf">rumbl_umbrella/apps/rumbl_web/lib/rumbl_web/endpoint.ex</span> from <span class="cf">:rumbl</span> to <span class="cf">:rumbl_web</span>, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">use</strong>​ Phoenix.Endpoint, ​<em class="string">otp_app:</em>​ ​<em class="string">:rumbl_web</em>​</td></tr></table>
<p id="calibre_link-1775" class="calibre19">Make a similar change in <span class="cf">Plug.Static</span>’s <span class="cf">:from</span> option from <span class="cf">:rumbl</span> to <span class="cf">:rumbl_web</span>:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">plug Plug.Static,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="string">at:</em>​ ​<em class="string">"</em>​​<em class="string">/"</em>​, ​<em class="string">from:</em>​ ​<em class="string">:rumbl_web</em>​, ​<em class="string">gzip:</em>​ false,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="string">only:</em>​ ​<strong class="kw">~</strong>​w(css fonts images js favicon.ico robots.txt)</td></tr></table>
<p id="calibre_link-1776" class="calibre19">That does it for <span class="cf">endpoint.ex</span>. We need to make similar changes in 
<span class="cf">apps/rumbl_web/lib/rumbl_web/channels/presence.ex</span>. Let’s provide the 
OTP app and the <span class="cf">PubSub</span> name. Make them look like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">use</strong>​ Phoenix.Presence,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="string">otp_app:</em>​ ​<em class="string">:rumbl_web</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="string">pubsub_server:</em>​ RumblWeb.PubSub</td></tr></table>
<p id="calibre_link-1777" class="calibre19">Finally, we need to list <span class="cf">Presence</span> as a child in <span class="cf">apps/rumbl_web/lib/rumbl_web/application.ex</span>, like this: </p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">children = [</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  RumblWeb.Endpoint,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  RumblWeb.Presence</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">]</td></tr></table>
<p id="calibre_link-1778" class="calibre19">We can move on to static assets.</p><h3 class="calibre22">Moving Assets</h3>
<p id="calibre_link-1779" class="calibre19">




We’ve moved our Elixir code, so it is time to work on the web assets. Copy your JavaScript and CSS assets from the <span class="cf">rumbl</span> project to the umbrella <span class="cf">rumbl_web</span> project, like so:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">cp</strong>​​<strong class="kw"> </strong>​​<strong class="kw">-R</strong>​​<strong class="kw"> </strong>​​<strong class="kw">rumbl/assets/js</strong>​​<strong class="kw"> </strong>​​<strong class="kw">rumbl_umbrella/apps/rumbl_web/assets/</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">cp</strong>​​<strong class="kw"> </strong>​​<strong class="kw">-R</strong>​​<strong class="kw"> </strong>​​<strong class="kw">rumbl/assets/css</strong>​​<strong class="kw"> </strong>​​<strong class="kw">rumbl_umbrella/apps/rumbl_web/assets/</strong>​</td></tr></table>
<p id="calibre_link-1780" class="calibre19">

With all of the assets in a single folder, we can update the dependencies paths in the <span class="cf">apps/rumbl_web/assets/package.json</span> to point to our new path structure, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">"dependencies": {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  "phoenix": "file:../../../deps/phoenix",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  "phoenix_html": "file:../../../deps/phoenix_html"</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">},</td></tr></table>
<p id="calibre_link-1781" class="calibre19">Now we’re ready to give it all a try.</p><h3 class="calibre22">Running Tests</h3>
<p id="calibre_link-1782" class="calibre19">

Let’s see if it all works. Fetch dependencies from the root of <span class="cf">rumbl_umbrella</span>, like so:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">(change to rumbl_umbrella)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">deps.get</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...</span>​</td></tr></table>
<p id="calibre_link-1783" class="calibre19">Now we can finally run the following <span class="cf">npm install</span> command inside the <span class="cf">rumbl_umbrella/apps/rumb_web/assets</span> directory, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">cd</strong>​​<strong class="kw"> </strong>​​<strong class="kw">apps/rumbl_web/assets</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">npm</strong>​​<strong class="kw"> </strong>​​<strong class="kw">install</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">cd</strong>​​<strong class="kw"> </strong>​​<strong class="kw">../../..</strong>​</td></tr></table>
<p id="calibre_link-1784" class="calibre19">Now we can run tests, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">==&gt; rumbl</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">.................</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Finished in 6.2 seconds</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">17 tests, 0 failures</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Randomized with seed 1527</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">==&gt; rumbl_web</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">...................</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Finished in 4.2 seconds</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">19 tests, 0 failures</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Randomized with seed 1527</td></tr></table>
<p id="calibre_link-1785" class="calibre19">Excellent! All of our tests pass.</p>
<p id="calibre_link-1786" class="calibre19">


We still have a little bit of touching up to do. You may notice our tests are too slow. If you recall, we added configuration to <span class="cf">config/test.exs</span> so we could reduce the hash rounds of the Comeonin library, to make password hashing faster within tests. We have extracted the applications, but we did not copy that configuration over. Remember, configuration in umbrella projects are shared across all children, so all configuration exists at the top level. Open up <span class="cf">rumbl_umbrella/config/test.exs</span> and configure <span class="cf">:pbkdf2_elixir</span> once again:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">config ​<em class="string">:pbkdf2_elixir</em>​, ​<em class="string">:rounds</em>​, 1</td></tr></table>
<p id="calibre_link-1787" class="calibre19">If you have done any other configuration while working on your application, make sure to mirror it in the relevant <span class="cf">config</span> files.</p>
<p id="calibre_link-1788" class="calibre19">

Now when we run tests, the password hashes will happen much more quickly. Let’s try them out:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">==&gt; rumbl</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">.................</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Finished in 0.2 seconds</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">17 tests, 0 failures</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Randomized with seed 823165</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">==&gt; rumbl_web</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">...................</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Finished in 0.2 seconds</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">19 tests, 0 failures</td></tr></table>
<p id="calibre_link-1789" class="calibre19">Ah, that’s much better. We are back to the speedy run times for each application, so we’re done! We’ve successfully extracted our business logic and web layers from <span class="cf">rumbl</span>, so we can fire up our server:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">$ mix phx.server</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[info] Running RumblWeb.Endpoint with cowboy 2.6.1 at http://localhost:4000</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">webpack is watching the files…</td></tr></table>
<p id="calibre_link-1790" class="calibre19">Here, we fired up <span class="cf">rumbl_umbrella</span>, but we can work with the pieces in isolation. You can also fire up any of your child apps individually!</p>
<p id="calibre_link-1791" class="calibre19">Notice we can successfully work with the application as a whole umbrella, just as we did before. Now, we can also develop features in isolation by switching to one of the applications inside <span class="cf">rumbl_umbrella/apps</span>.</p>
<p id="calibre_link-1792" class="calibre19">Whew. Let’s review what we did. We physically split our application into two parts by copying files over to our <span class="cf">rumbl_umbrella</span> project, under the <span class="cf">apps</span> directory. We now have isolated our business logic from the web concerns of our application.</p>
<p id="calibre_link-1793" class="calibre19">Take note of the big win here. When you develop code for the project, you can now focus on each application individually. If you pay attention to clean, logical interfaces, as your project grows, you can continue to extract child services to their own projects. If by the end of the book, you believe umbrella projects give you a better workflow and boundaries, you can start your next Phoenix project with umbrellas from the beginning by calling <span class="cf">mix phx.new</span> with the <span class="cf">--umbrella</span> flag.

</p>
<p id="calibre_link-1794" class="calibre19">The next candidate for an umbrella child app will be the information system. We’ll build that one from scratch so you’ll see both the refactoring workflow and creating a child application from scratch in the next chapter.


</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-205"><div id="calibre_link-1795" class="calibre2"><h2 id="calibre_link-143" class="calibre20">Wrapping Up</h2>
<p id="calibre_link-1796" class="calibre19">In this chapter, we took some time to break our growing project into bite-sized pieces. We used umbrellas, an Elixir construct that allows us to develop and test projects in isolation but integrate them into a whole. Along the way:</p><ul class="calibre28"><li class="calibre29">We used Observer to understand the importance behind applications.</li><li class="calibre29">We extracted <span class="cf1">rumbl</span> and <span class="cf1">rumbl_web</span> into their own child umbrella project.</li><li class="calibre29">We learned to identify configuration changes, including dependencies, supervision trees, and application configuration.</li></ul>
<p id="calibre_link-1797" class="calibre19">Next, we’ll see how to build an independent, self-healing piece of infrastructure with OTP.  When we’re done, you’ll be able to develop and test the pieces in isolation.</p>

<div class="footnotes">
<h4 class="calibre24">Footnotes</h4>
<dl class="calibre25">
<dt class="footnote-number"><a id="calibre_link-288" href="#calibre_link-206" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[31]</a></dt><dd class="calibre26">
<p id="calibre_link-1798" class="calibre27"><a href="https://phoenixframework.org/blog/the-road-to-2-million-websocket-connections" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://phoenixframework.org/blog/the-road-to-2-million-websocket-connections</a></p></dd></dl></div>
<div class="copyright">Copyright © 2020, The Pragmatic Bookshelf.</div>




</div>



  </div>


<div class="calibre1" id="calibre_link-242"><div id="calibre_link-1799" class="calibre2"><h1 class="pcalibre6 chapter-title" id="calibre_link-144"><span class="chapter-number">
            Chapter
            12</span><br class="calibre18" /><span class="chapter-name">OTP</span></h1>

<p id="calibre_link-1800" class="calibre19">You’ve now had your first Phoenix Channels experience and should be developing a good intuition for the strength of Phoenix for highly interactive applications. You’ve also lightly sampled OTP concepts including applications and supervision trees. You have everything you need to create beautiful code and then run it reliably at breakneck speeds.</p>
<p id="calibre_link-1801" class="calibre19">

Phoenix isn’t just about user interfaces, though. You also have the experience and elegance of Erlang’s OTP framework. In general, OTP is a way to think about fault-tolerance, concurrency, and distribution. It uses a few patterns that allow you to use concurrency to build state without language features that rely on mutability. OTP also has rich abstractions for supervision and monitoring. In this chapter, we’ll use OTP to build an information system.</p>
<p id="calibre_link-1802" class="calibre19">Rather than read a wave of dry prose that tells you what OTP does, you’ll start with the basics by building a simple service. We’ll build a counter that runs in a separate process. Then, we’ll supervise it, restarting on failure. You’ll see how you can hold state in an immutable world.</p>
<p id="calibre_link-1803" class="calibre19">On its own, that knowledge will help you understand Phoenix, which is itself an OTP application. We’ll use these principles to build an information service under our umbrella project, which we will develop, manage, and test in isolation.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-274"><div id="calibre_link-1804" class="calibre2"><h2 id="calibre_link-145" class="calibre20">Managing State with Processes</h2>
<p id="calibre_link-1805" class="calibre19">





Functional programs are stateless, but we still need to be able to manage state. In Elixir, we use concurrent processes and recursion to handle this task. That may sound counterintuitive, but let’s take a look at how it works with a simple program.</p>
<p id="calibre_link-1806" class="calibre19">To start with, let’s create a child application. From the <span class="cf">rumbl_umbrella</span> root directory, change to <span class="cf">apps</span> and create a new mix project, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">➔</strong>​​<strong class="kw"> </strong>​​<strong class="kw">cd</strong>​​<strong class="kw"> </strong>​​<strong class="kw">apps</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">➔</strong>​​<strong class="kw"> </strong>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">new</strong>​​<strong class="kw"> </strong>​​<strong class="kw">info_sys</strong>​​<strong class="kw"> </strong>​​<strong class="kw">--sup</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">* creating README.md</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...</span>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">➔</strong>​​<strong class="kw"> </strong>​​<strong class="kw">cd</strong>​​<strong class="kw"> </strong>​​<strong class="kw">info_sys</strong>​</td></tr></table>
<p id="calibre_link-1807" class="calibre19">We create a brand new mix project under the <span class="cf">apps</span> directory. Later it will evolve into our full service, but for now let’s create a <span class="cf">Counter</span> server that counts up or down. Create a <span class="cf">apps/info_sys/lib/info_sys/counter.ex</span> file and key this in:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys/counter.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys/counter.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ InfoSys.Counter ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ inc(pid), ​<strong class="kw">do</strong>​: send(pid, ​<em class="string">:inc</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ dec(pid), ​<strong class="kw">do</strong>​: send(pid, ​<em class="string">:dec</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ val(pid, timeout \\ 5000) ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ref = make_ref()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    send(pid, {​<em class="string">:val</em>​, self(), ref})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">    ​<strong class="kw">receive</strong>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      {^ref, val} -&gt; val</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">after</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      timeout -&gt; ​<strong class="kw">exit</strong>​(​<em class="string">:timeout</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ start_link(initial_val) ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, spawn_link(​<strong class="kw">fn</strong>​ -&gt; listen(initial_val) ​<strong class="kw">end</strong>​)}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">20:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">defp</strong>​ listen(val) ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">receive</strong>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      ​<em class="string">:inc</em>​ -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">        listen(val + 1)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">25:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      ​<em class="string">:dec</em>​ -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">        listen(val - 1)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      {​<em class="string">:val</em>​, sender, ref} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">30:&nbsp;</span></td><td class="codeline">        send(sender, {ref, val})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">        listen(val)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1808" class="calibre19">

Our module implements a <span class="cf">Counter</span> server as well as functions for interacting with it as a client. The <span class="calibre4">client</span> serves as the API and exists only to send messages to the process that does the work. It’s the <span class="calibre4">interface</span> for our counter. The <span class="calibre4">server</span> is a process that recursively loops, processing a message and sending updated state to itself. Our server is the <span class="calibre4">implementation</span>.</p><h3 class="calibre22">Building the Counter API</h3>
<p id="calibre_link-1809" class="calibre19">


Our API sends messages to increment (<span class="cf">:inc</span>) and decrement (<span class="cf">:dec</span>) the counter, and another message called <span class="cf">:val</span> to get the counter’s value. Let’s look at each one of these in turn.</p>
<p id="calibre_link-1810" class="calibre19">

<span class="cf">:inc</span> and <span class="cf">:dec</span> take only the process ID for the server process&mdash;called <span class="cf">pid</span> for process ID&mdash;and a single atom command.  These skinny functions exist only to send :<span class="cf">inc</span> and <span class="cf">:dec</span> messages to our server process. These are asynchronous, meaning we send a message without awaiting any reply.</p>
<p id="calibre_link-1811" class="calibre19">


The <span class="cf">val</span> function on line 6 is a bit different. It must send a request for the value of the counter and await the response. Since we need to associate a response with this particular request, we create a unique reference with <span class="cf">make_ref()</span>. This unique reference is just a value that’s guaranteed to be globally unique. Then, we send a message to our counter with the <span class="cf">send</span> function. Our message payload is a 3-tuple with an atom designating the command we want to do, <span class="cf">:val</span>, followed by our process ID called <span class="cf">pid</span> and the globally unique reference.</p>
<p id="calibre_link-1812" class="calibre19">



Then, we await a response, matching on the reference. The <span class="cf">^</span> operator means that rather than rebinding the value of <span class="cf">ref</span>, we match only tuples having that exact <span class="cf">ref</span>. That way, we can make sure to match only responses related to our explicit request. If there’s no match in a given period, we exit the current process with the <span class="cf">:timeout</span> reason code.</p>
<p id="calibre_link-1813" class="calibre19">We start by defining the client API to interact with our counter. First, we create <span class="cf">inc</span> and <span class="cf">dec</span> functions to increment and decrement our counter. These functions fire off an async message to the counter process without waiting for a response. Our <span class="cf">val</span> function sends a message to the counter but then blocks the caller process while waiting for a response.</p>
<p id="calibre_link-1814" class="calibre19">Let’s take a look at our server.</p>
<p id="calibre_link-1815" class="calibre19">



As you’ll see later, OTP requires a <span class="cf">start_link</span> function. Ours, on line 17, accepts the initial state of our counter. Its only job is to spawn a process and return <span class="cf">{:ok, pid}</span>, where <span class="cf">pid</span> identifies the spawned process. The spawned process calls the private function named <span class="cf">listen</span>, which listens for messages and processes them.</p>
<p id="calibre_link-1816" class="calibre19">

Let’s look at that <span class="cf">listen</span> function on line 21, the engine for our counter. You don’t see any global variables that hold state, but our listener has a trick up its sleeve. We can exploit recursion to manage state. For each call to <span class="cf">listen</span>, the tiny function blocks to wait for a message. Then, we process the trivial <span class="cf">:inc</span>, <span class="cf">:dec</span>, and <span class="cf">:val</span> messages. The last thing any <span class="cf">receive</span> clause does is call <span class="cf">listen</span> again with the updated state.</p>
<p id="calibre_link-1817" class="calibre19">


Said another way, the state of the server is wrapped up in the execution of the recursive function. We can use Elixir’s message passing to listen in on the process to find the value of the state at any time. When the last thing you do in a function is to call the function itself, the function is <span class="calibre4">tail recursive</span>, meaning it optimizes to a loop instead of a function call. That means this loop can run indefinitely! In many languages, burning a thread for such a trivial task can be expensive, but in Elixir processes are incredibly cheap, so this strategy is a great way to manage state.</p><h3 class="calibre22">Taking Our Counter for a Spin</h3>
<p id="calibre_link-1818" class="calibre19">This code is pretty simple, so you already know what’ll happen. Still, let’s try it out in IEx with <span class="cf">iex -S mix</span>:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ alias InfoSys.Counter</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">InfoSys.Counter</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ {​<em class="string">:ok</em>​, counter} = Counter.start_link(0)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{:ok, #PID&lt;0.253.0&gt;}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Counter.inc(counter)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">:inc</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Counter.inc(counter)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">:inc</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Counter.val(counter)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">2</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Counter.dec(counter)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">:dec</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Counter.val(counter)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">1</td></tr></table>
<p id="calibre_link-1819" class="calibre19">It works perfectly, just as you expected. Think about the techniques used:</p><ul class="calibre28"><li class="calibre29">We used concurrency and recursion to maintain state.</li><li class="calibre29">We separated the interface from the implementation.</li><li class="calibre29">We used different abstractions for asynchronous and synchronous communication with our server.</li></ul>
<p id="calibre_link-1820" class="calibre19">As you might imagine, this approach is common and important enough for us to package it for reuse. In fact, this approach has been around a while in the form of the Erlang OTP library. Let’s take a look.

</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-322"><div id="calibre_link-1821" class="calibre2"><h2 id="calibre_link-146" class="calibre20">Building GenServers for OTP</h2>
<p id="calibre_link-1822" class="calibre19">




Though our counter is an oversimplification, the basic approach has been used for over thirty years to manage both concurrent state and behavior for most important Erlang applications. The library encapsulating that approach is called OTP, and the abstraction is called a <span class="calibre4">generic server</span>, or <span class="cf">GenServer</span>. Let’s modify our counter to use OTP to create our counter, instead.</p>
<p id="calibre_link-1823" class="calibre19">

We don’t need to change too much. Instead of creating specific functions to handle <span class="cf">inc</span>, <span class="cf">dec</span>, and <span class="cf">val</span>, we use specific OTP abstractions instead. Update your <span class="cf">counter.ex</span> file with these contents:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys/counter.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys/counter.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ InfoSys.Counter ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ GenServer</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ inc(pid), ​<strong class="kw">do</strong>​: GenServer.cast(pid, ​<em class="string">:inc</em>​) </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ dec(pid), ​<strong class="kw">do</strong>​: GenServer.cast(pid, ​<em class="string">:dec</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ val(pid) ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    GenServer.call(pid, ​<em class="string">:val</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ start_link(initial_val) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    GenServer.start_link(__MODULE__, initial_val) </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ init(initial_val) ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, initial_val}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">20:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ handle_cast(​<em class="string">:inc</em>​, val) ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    {​<em class="string">:noreply</em>​, val + 1}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ handle_cast(​<em class="string">:dec</em>​, val) ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">25:&nbsp;</span></td><td class="codeline">    {​<em class="string">:noreply</em>​, val - 1}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ handle_call(​<em class="string">:val</em>​, _from, val) ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    {​<em class="string">:reply</em>​, val, val}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">30:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1824" class="calibre19">




We’ve changed the terminology some, but not the implementation. When we want to send asynchronous messages such as our <span class="cf">inc</span> and <span class="cf">dec</span> messages, we use <span class="cf">GenServer.cast</span>, as you can see on line 4. Notice that these functions don’t send a return reply. When we want to send synchronous messages that return the state of the server, we use <span class="cf">GenServer.call</span> as we do on line 8. Notice the <span class="cf">_from</span> in the function head. You can use an argument leading with an underscore, just as you’d use a <span class="cf">_</span> as wildcard match. With this feature, we can explicitly describe the argument while ignoring the contents.</p>
<p id="calibre_link-1825" class="calibre19">







On the server side, the implementation is much the same: we use a <span class="cf">handle_cast</span> line for <span class="cf">:inc</span> and one for <span class="cf">:dec</span>, each returning a <span class="cf">noreply</span> alongside the new state, and we also use <span class="cf">handle_call</span> to handle <span class="cf">:val</span>, and specify the return value. We explicitly tell OTP when to send a reply and when not to send one. We also have to tweak the <span class="cf">start_link</span> to start a <span class="cf">GenServer</span>, giving it the current module name and the counter. This function spawns a new process and invokes the <span class="cf">InfoSys.Counter.init</span> function inside this new process to set up its initial state.</p>
<p id="calibre_link-1826" class="calibre19">Let’s take that much for a spin:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ alias InfoSys.Counter</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">InfoSys.Counter</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ {​<em class="string">:ok</em>​, counter} = Counter.start_link(10)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{:ok, #PID&lt;0.96.0&gt;}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Counter.dec(counter)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">:ok</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Counter.dec(counter)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">:ok</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Counter.val(counter)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">8</td></tr></table>
<p id="calibre_link-1827" class="calibre19">
Our first counter was split into client and server code. This segregation remains when we write our <span class="cf">GenServer</span>. <span class="cf">init</span>, <span class="cf">handle_call</span>, and <span class="cf">handle_cast</span> run in the server. All other functions are part of the client.</p>
<p id="calibre_link-1828" class="calibre19">


Our OTP counter server works exactly as before, but we’ve gained much by moving it to a <span class="cf">GenServer</span>. On the surface, we no longer need to worry about setting up references for synchronous messages. Those are taken care of for us by <span class="cf">GenServer.call</span>. Second, the <span class="cf">GenServer</span> module is now in control of the <span class="cf">receive</span> loop, allowing it to provide great features like code upgrading and handling of system messages, which will be useful when we introspect our system with Observer later on. A <span class="cf">GenServer</span> is one of many OTP behaviours. We’ll continue exploring them as we build our information system.</p><h3 class="calibre22">Adding Failover</h3>
<p id="calibre_link-1829" class="calibre19">





The benefits of OTP go beyond simply managing concurrent state and behavior. It also handles the linking and supervision of processes. Now let’s explore how process supervision works. We’ll supervise our new counter.</p>
<p id="calibre_link-1830" class="calibre19">
Though our counter is a trivial service, we’ll play with supervision strategies. Our supervisor needs to be able to restart each service the right way, according to the policies that are best for the application. For example, if a database dies, you might want to automatically kill and restart the associated connection pool. <span class="calibre4">This policy decision should not impact code that uses the database.</span>  If we replace a simple supervisor process with a supervisor tree, we can build much more robust fault-tolerance and recovery software.</p>
<p id="calibre_link-1831" class="calibre19">
In Phoenix, you didn’t see too much code attempting to deal with the fallout for every possible exception. Instead, we trust the error reporting to log the errors so that we can fix what’s broken, and in the meantime, we can automatically restart services in the last good state. The beauty of OTP is that it captures these clean abstractions in a coherent library, allowing us to declare the supervision properties that most interest us without bogging down the meaning of each individual application. With a supervision tree having a configurable policy, you can build <span class="calibre4">robust self-healing software</span> without building <span class="calibre4">complex self-healing software</span>.</p>
<p id="calibre_link-1832" class="calibre19">


We’ll manage the configuration of the supervision policies in a single location. Since we’re under an umbrella, we’ll use the <span class="cf">application.ex</span> file for our <span class="cf">info_sys</span>. Let’s add our <span class="cf">Counter</span> server to our application’s supervision tree. In <span class="cf">lib/info_sys/application.ex</span>, add your new server as a child of your supervisor, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys/application.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys/application.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">children = [</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {InfoSys.Counter, 5}, ​<em class="comment"># new counter worker</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">]</td></tr></table>
<p id="calibre_link-1833" class="calibre19">
To specify the children an Elixir application will start, we define a <span class="calibre4">child spec</span>. In this case, we add our new counter to the existing list of children that our application already defined. You’ll specify a single element containing a two-tuple having the module you want to start and the value that will be received on <span class="cf">start_link</span> by the GenServer. Alternatively, passing in only a module name uses a default value of <span class="cf">[]</span>.</p>
<p id="calibre_link-1834" class="calibre19">For our <span class="cf">Counter</span>, we pass a tuple, which takes the module, and the argument for the child’s <span class="cf">start_link/1</span>. In our case, we pass the initial state, as the number <span class="cf">5</span>.</p>
<p id="calibre_link-1835" class="calibre19">




In <span class="cf">opts</span>, you can see the policy that our application will use if something goes wrong. OTP calls this policy the <span class="calibre4">supervision strategy</span>. In this case, we’re using the <span class="cf">:one_for_one</span> strategy. This strategy means that if the child dies, only that child will be restarted. If all resources depended on some common service, we could have specified <span class="cf">:one_for_all</span> to kill and restart all child process if any child dies. We’ll explore those strategies later on.</p>
<p id="calibre_link-1836" class="calibre19">
Now if we fire up our application with <span class="cf">iex -S mix</span>, we don’t see anything particular, since our counter is running but we aren’t interacting with it.</p>
<p id="calibre_link-1837" class="calibre19">Let’s add a periodic tick to our counter to see it work in action in our supervision tree.</p>
<p id="calibre_link-1838" class="calibre19">
Modify your <span class="cf">Counter</span>’s <span class="cf">init</span> function and add a new <span class="cf">handle_info</span> callback, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys/counter.change2.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys/counter.change2.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ init(initial_val) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Process.send_after(self(), ​<em class="string">:tick</em>​, 1000)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {​<em class="string">:ok</em>​, initial_val}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ handle_info(​<em class="string">:tick</em>​, val) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  IO.puts(​<em class="string">"</em>​​<em class="string">tick </em>​​<em class="string">#{</em>​val​<em class="string">}</em>​​<em class="string">"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Process.send_after(self(), ​<em class="string">:tick</em>​, 1000)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {​<em class="string">:noreply</em>​, val - 1}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1839" class="calibre19">We tweak <span class="cf">init</span> in the counter process to send itself a <span class="cf">:tick</span> message every 1,000 milliseconds, and then we add a function to process those ticks, simulating a countdown. As with channels, out-of-band messages are handled inside the <span class="cf">handle_info</span> callback, which sets up a new tick and decrements the state.</p>
<p id="calibre_link-1840" class="calibre19">Now you can fire our application back up with <span class="cf">iex -S mix</span> and see our counter worker in action:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ tick 5</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">tick 4</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">tick 3</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">tick 2</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">tick 1</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">^C</td></tr></table>
<p id="calibre_link-1841" class="calibre19">
This isn’t terribly exciting, but it gets interesting when we deal with our workers crashing.</p>
<p id="calibre_link-1842" class="calibre19">Let’s crash our counter if it ticks below a certain value:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys/counter.change3.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys/counter.change3.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ handle_info(​<em class="string">:tick</em>​, val) ​<strong class="kw">when</strong>​ val &lt;= 0, ​<strong class="kw">do</strong>​: ​<strong class="kw">raise</strong>​ ​<em class="string">"</em>​​<em class="string">boom!"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ handle_info(​<em class="string">:tick</em>​, val) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  IO.puts(​<em class="string">"</em>​​<em class="string">tick </em>​​<em class="string">#{</em>​val​<em class="string">}</em>​​<em class="string">"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Process.send_after(self(), ​<em class="string">:tick</em>​, 1000)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {​<em class="string">:noreply</em>​, val - 1}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1843" class="calibre19">We add a <span class="cf">:tick</span> clause for cases when the value is less than zero, and we raise an error that crashes our process. Let’s fire up <span class="cf">iex -S mix</span> again and see what happens:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ tick 5</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">tick 4</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">tick 3</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">tick 2</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">tick 1</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[error] GenServer #PID&lt;0.119.0&gt; terminating</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">**</strong>​ (RuntimeError) boom!</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    (info_sys) lib/info_sys/counter.ex:22: InfoSys.Counter.handle_info/2</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    (stdlib) gen_server.erl:616: :gen_server.try_dispatch/4</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    (stdlib) gen_server.erl:686: :gen_server.handle_msg/6</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    (stdlib) proc_lib.erl:247: :proc_lib.init_p_do_apply/3</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Last message: :tick</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">State: 0</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">tick 5</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">tick 4</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">tick 3</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">tick 2</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">tick 1</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">^C</td></tr></table>
<p id="calibre_link-1844" class="calibre19">
As expected, our server crashed&mdash;but then it restarted! That’s the magic of supervision. When our counter crashed, it was restarted with its initial state of <span class="cf">5</span>. In short, our program crashed, the supervisor identified the crash, and then it restarted the process in a known good state. We don’t have to add any extra code to fully supervise every process. We need only configure a policy to tell OTP how to handle each crash.</p>
<p id="calibre_link-1845" class="calibre19">The basic building blocks of isolated application processes and a supervision structure to manage them have been the cornerstone of Erlang reliability&mdash;whether you’re running a trivial counter, a server with a million processes, or a worldwide distributed application with tens of millions of processes. The principles are the same, and they’ve been proven to work.</p>
<p id="calibre_link-1846" class="calibre19">To apply these principles, you need to know how to tell Elixir what supervision behavior you expect. Here are the basics.

</p><h3 class="calibre22">Restart Strategies</h3>
<p id="calibre_link-1847" class="calibre19">





The first decision you need to make is to tell OTP what should happen if your process crashes. Think of these details as a software policy for dealing with failure. If we decide to use anything beyond the module to start and the initial value for the OTP server, we’ll need a way to specify those options. That’s called a <span class="calibre4">child spec</span> which configures the policy for an OTP restart.</p>
<p id="calibre_link-1848" class="calibre19">You have a couple of options for defining those options. First, you can do it within the <span class="cf">children</span> definition in application.ex. To do so, you can use the <span class="cf">Supervisor.child_spec</span> function. For example, if we wanted to explicitly specify a <span class="cf">:permanent</span> restart strategy, you’d do so like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">children = [</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Supervisor.child_spec({InfoSys.Counter, 5}, ​<em class="string">restart:</em>​ ​<em class="string">:permanent</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">]</td></tr></table>
<p id="calibre_link-1849" class="calibre19">That’s fine for a single child spec, but having to specify the supervision values every time we list our server would be repetitive and error prone. Fortunately, Elixir allows us to also define those values directly in the <span class="cf">Counter</span> module, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ InfoSys.Counter ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ GenServer, ​<em class="string">restart:</em>​ ​<em class="string">:permanent</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1850" class="calibre19">

Behind the scenes, this code works because <span class="cf">use GenServer</span> defines a <span class="cf">child_spec(arg)</span> function, which returns the child specification. Most of the time this high-level <span class="cf">using</span> option is enough. When you need more, you can always define your own <span class="cf">child_spec(arg)</span> function, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ InfoSys.Counter ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ child_spec(arg) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    %{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<em class="string">id:</em>​ __MODULE__,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<em class="string">start:</em>​ { __MODULE__, ​<em class="string">:start_link</em>​, [arg]},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<em class="string">restart:</em>​ ​<em class="string">:temporary</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<em class="string">shutdown:</em>​ 5000,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<em class="string">type:</em>​ ​<em class="string">:worker</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">     }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1851" class="calibre19">


The keys listed here are the module, the function, and arguments to call for starting and restarting the server, the restart configuration, a shutdown value in milliseconds, and the type of child. We’ll go into some of these options in more detail throughout the chapter. See the Elixir documentation for <span class="cf">child_spec</span><sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-266" href="#calibre_link-323">[32]</a></sup> for a complete list of options and more details. For now, let’s focus on the <span class="cf">restart</span> option configuration. Child specifications support the following restart values:



</p><dl class="calibre42"><dt class="force-newline"><span class="cf1">:permanent</span></dt><dd class="calibre43">
<p id="calibre_link-1852" class="calibre19">The child is always restarted (default).</p></dd><dt class="force-newline"><span class="cf1">:temporary</span></dt><dd class="calibre43">
<p id="calibre_link-1853" class="calibre19">The child is never restarted.</p></dd><dt class="force-newline"><span class="cf1">:transient</span></dt><dd class="calibre43">
<p id="calibre_link-1854" class="calibre19">The child is restarted only if it terminates abnormally, with an exit reason other than <span class="cf">:normal</span>, <span class="cf">:shutdown</span>, or <span class="cf">{:shutdown, term}</span>.</p></dd></dl>
<p id="calibre_link-1855" class="calibre19"><span class="cf">:permanent</span> is the default restart strategy and the trailing options are fully optional, so to specify a <span class="cf">:permanent</span> counter with an initial value of <span class="cf">5</span>, we can use <span class="cf">worker(InfoSys.Counter, [5])</span>.</p>
<p id="calibre_link-1856" class="calibre19">Let’s say we have a situation in which <span class="calibre4">mostly dead</span> isn’t good enough. When a counter dies, we want it to really <span class="calibre4">die</span>. Perhaps restarting the server would cause harm. Let’s try changing our restart strategy to <span class="cf">:temporary</span> and observe the crash:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">children = [</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Supervisor.child_spec({InfoSys.Counter, 5}, ​<em class="string">restart:</em>​ ​<em class="string">:temporary</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">]</td></tr></table>
<p id="calibre_link-1857" class="calibre19">Now let’s fire our project back up with <span class="cf">iex -S mix</span>:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ tick 5</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">tick 4</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">tick 3</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">tick 2</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">tick 1</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[error] GenServer #PID&lt;0.306.0&gt; terminating</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[error] GenServer #PID&lt;0.119.0&gt; terminating</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">**</strong>​ (RuntimeError) boom!</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    (info_sys) lib/info_sys/counter.ex:22: InfoSys.Counter.handle_info/2</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    (stdlib) gen_server.erl:616: :gen_server.try_dispatch/4</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    (stdlib) gen_server.erl:686: :gen_server.handle_msg/6</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    (stdlib) proc_lib.erl:247: :proc_lib.init_p_do_apply/3</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Last message: :tick</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">State: 0</td></tr></table>
<p id="calibre_link-1858" class="calibre19">As you’d expect, when our counter dies it stays dead. The <span class="cf">:temporary</span> strategy is useful when a restart is unlikely to resolve the problem, or when restarting doesn’t make sense based on the flow of the application.</p>
<p id="calibre_link-1859" class="calibre19">



Sometimes, you may want OTP to retry an operation a few times before failing. You can do exactly that with a pair of child spec options called <span class="cf">max_restarts</span> and <span class="cf">max_seconds</span>. OTP will only restart an application <span class="cf">max_restarts</span> times in <span class="cf">max_seconds</span> before failing and reporting the error up the supervision tree. By default, Elixir will allow <span class="cf">3</span> restarts in <span class="cf">5</span> seconds, but you can configure these values to whatever you want. In general, you’ll use the restart strategies your specific application requires.







</p><h3 class="calibre22">Supervision Strategies</h3>
<p id="calibre_link-1860" class="calibre19">
Just as child workers have different restart strategies, supervisors have configurable supervision strategies. The most basic and the default for new Phoenix applications is <span class="cf">:one_for_one</span>. When a <span class="cf">:one_for_one</span> supervisor detects a crash, it restarts a worker of the same type without any other consideration. Most of the time, <span class="cf">:one_for_one</span> is enough but sometimes, processes depend on one another. When such a process dies, more than one process must restart. That’s why Elixir supports more than one restart strategy.</p>
<p id="calibre_link-1861" class="calibre19">Let’s look at the ones that are available:



</p><dl class="calibre42"><dt class="force-newline"><span class="cf1">:one_for_one</span></dt><dd class="calibre43">
<p id="calibre_link-1862" class="calibre19">If a child terminates, a supervisor restarts only that process.</p></dd><dt class="force-newline"><span class="cf1">:one_for_all</span></dt><dd class="calibre43">
<p id="calibre_link-1863" class="calibre19">If a child terminates, a supervisor terminates all children and then restarts all children.</p></dd><dt class="force-newline"><span class="cf1">:rest_for_one</span></dt><dd class="calibre43">
<p id="calibre_link-1864" class="calibre19">If a child terminates, a supervisor terminates all child processes defined after the one that dies. Then the supervisor restarts all terminated processes.</p></dd></dl>
<p id="calibre_link-1865" class="calibre19">These strategies are all relatively straightforward. To get a taste of them, let’s start multiple counters and see how the termination of one of them affects the others. Back in <span class="cf">lib/info_sys/application.ex</span>, change the <span class="cf">start</span> function to this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">children = [</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {InfoSys.Counter, 15},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {InfoSys.Counter, 5},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {InfoSys.Counter, 10},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">]</td></tr></table><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">opts = [​<em class="string">strategy:</em>​ ​<em class="string">:one_for_all</em>​, ​<em class="string">name:</em>​ InfoSys.Supervisor] ​<em class="comment"># new strategy</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Supervisor.start_link(children, opts)</td></tr></table>
<p id="calibre_link-1866" class="calibre19">Now when you boot your application via <span class="cf">$ iex -S mix</span>, you will notice it won’t even start, with this reason:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">** (Mix) Could not start application info_sys:</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  InfoSys.Application.start(:normal, []) returned an error: bad child spec,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  more than one child specification has the id: InfoSys.Counter.</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">If using maps as child specifications, make sure the :id keys are unique.</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">If using a module or {module, arg} as child, use Supervisor.child_spec/2</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">to change the :id, for example:</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    children = [</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      Supervisor.child_spec({MyWorker, arg}, id: :my_worker_1),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      Supervisor.child_spec({MyWorker, arg}, id: :my_worker_2)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ]</td></tr></table>
<p id="calibre_link-1867" class="calibre19">The error message shows us exactly what we need to do. We are starting multiple counters but they all have the same ID. We need to pass distinct IDs in each <span class="cf">child_spec</span> call, so let’s do that:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">children = [</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Supervisor.child_spec({InfoSys.Counter, 15}, ​<em class="string">id:</em>​ ​<em class="string">:long</em>​),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Supervisor.child_spec({InfoSys.Counter, 5}, ​<em class="string">id:</em>​ ​<em class="string">:short</em>​),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Supervisor.child_spec({InfoSys.Counter, 10}, ​<em class="string">id:</em>​ ​<em class="string">:medium</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">]</td></tr></table>
<p id="calibre_link-1868" class="calibre19">Restart the application with <span class="cf">$ iex -S mix</span> once more and you should see all servers counting down at the same time. As soon as the “short” counter reaches 0, it terminates, and then we can see all counters restarting from scratch. Feel free to play with the other supervision strategies and see how the system will behave.</p>
<p id="calibre_link-1869" class="calibre19">Once the counter experiments are over, change our <span class="cf">lib/rumbl/application.ex</span> back to the original supervision tree and restart strategy:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys/application.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys/application.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ start(_type, _args) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  children = [</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  opts = [​<em class="string">strategy:</em>​ ​<em class="string">:one_for_one</em>​, ​<em class="string">name:</em>​ InfoSys.Supervisor]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Supervisor.start_link(children, opts)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1870" class="calibre19">The <span class="cf">GenServer</span> is the foundation of many different abstractions throughout Elixir and Phoenix. Knowing these small details will make you a much better programmer. Let’s see a couple more examples.






</p><h3 class="calibre22">Using Agents</h3>
<p id="calibre_link-1871" class="calibre19">








It turns out that a still simpler abstraction has many of the benefits of a <span class="cf">GenServer</span>. It’s called an <span class="calibre4">agent</span>. With an agent, you have only five main functions: <span class="cf">start_link</span> initializes the agent, <span class="cf">stop</span> stops the agent, <span class="cf">update</span> changes the state of the agent, <span class="cf">get</span> retrieves the agent’s current value, and <span class="cf">get_and_update</span> performs the last two operations simultaneously. Here’s what our counter would look like with an agent:

</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ ​<strong class="kw">import</strong>​ Agent</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">nil</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ {​<em class="string">:ok</em>​, agent} = start_link(​<strong class="kw">fn</strong>​ -&gt; 5 ​<strong class="kw">end</strong>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{:ok, #PID&lt;0.57.0&gt;}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ update(agent, &amp;(&amp;1 + 1))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">:ok</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ get(agent, &amp;(&amp;1))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">6</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ stop(agent)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">:ok</td></tr></table>
<p id="calibre_link-1872" class="calibre19">
To initialize an agent, you pass a function returning the state you want. To update the agent, you pass a function taking the current state and returning the new state. That’s all there is to it. Behind the scenes, this agent is an OTP <span class="cf">GenServer</span>, and plenty of options are available to customize it as needed. One such option is called <span class="cf">:name</span>.</p><h3 class="calibre22">Registering Processes</h3>
<p id="calibre_link-1873" class="calibre19">







With OTP, we can register a process by name  with the <span class="cf">:name</span> option in <span class="cf">start_link</span>. After we register a process by name, we can send messages to it using the registered name instead of the pid.</p>
<p id="calibre_link-1874" class="calibre19">Let’s rewrite the previous example using a named agent:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ ​<strong class="kw">import</strong>​ Agent</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">nil</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ {​<em class="string">:ok</em>​, agent} = start_link(​<strong class="kw">fn</strong>​ -&gt; 5 ​<strong class="kw">end</strong>​, ​<em class="string">name:</em>​ MyAgent)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{:ok, #PID&lt;0.57.0&gt;}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ update(MyAgent, &amp;(&amp;1 + 1))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">:ok</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ get(MyAgent, &amp;(&amp;1))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">6</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ stop(MyAgent)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">:ok</td></tr></table>
<p id="calibre_link-1875" class="calibre19">If a process already exists with the registered name, we can’t start the agent:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ ​<strong class="kw">import</strong>​ Agent</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">nil</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ {​<em class="string">:ok</em>​, agent} = start_link(​<strong class="kw">fn</strong>​ -&gt; 5 ​<strong class="kw">end</strong>​, ​<em class="string">name:</em>​ MyAgent)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{:ok, #PID&lt;0.57.0&gt;}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ {​<em class="string">:ok</em>​, agent} = start_link ​<strong class="kw">fn</strong>​ -&gt; 5 ​<strong class="kw">end</strong>​, ​<em class="string">name:</em>​ MyAgent</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">**</strong>​ (MatchError) no match of right hand side value:</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {:error, {:already_started, #PID&lt;0.57.0&gt;}}</td></tr></table>
<p id="calibre_link-1876" class="calibre19">Agents are one of the many constructs built on top of OTP. You’ve already seen another, the <span class="cf">Phoenix.Channel</span>. Let’s take a look.</p><h3 class="calibre22">OTP and Channels</h3>
<p id="calibre_link-1877" class="calibre19">



If we were building a supervisor for a couple of application components, the simple default <span class="cf">:one_for_one</span> strategy might be enough. The goal for Phoenix Channels is bigger, though. To us, supervisors aren’t just tiny isolated services. Channels are core infrastructure. We intentionally build all of our infrastructure with a tree of supervisors, where each node of the tree knows how to restart any major service if it fails.</p>
<p id="calibre_link-1878" class="calibre19">
When you coded your channels in the previous chapter, you might not have known it, but you were building an OTP application. Each new channel was a process built to serve a single user in the context of a single conversation on a topic. Though Phoenix is new, we’re standing on the shoulders of giants. Erlang’s OTP has been around as long as Erlang has been popular&mdash;we know that it works. Much of the world’s text-messaging traffic runs on OTP infrastructure. WhatsApp runs on Erlang to process more than tens of billions messages every day. You can count on this infrastructure always being up and available because it’s built on a reliable foundation.



</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-26"><div id="calibre_link-1879" class="calibre2"><h2 id="calibre_link-147" class="calibre20">Designing an Information System with OTP</h2>
<p id="calibre_link-1880" class="calibre19">




With these high-level basics demystified, let’s use another OTP abstraction to enhance our application. Let’s take our video annotations to another level with some OTP-backed information services. We’re going to use some common web APIs to enhance our application.</p>
<p id="calibre_link-1881" class="calibre19">For any request, we’re going to ask our information system for highly relevant facts that we can inject. We’ll be providing enhanced question/answer&ndash;style annotations as the video is playing. This’ll give our live viewers and replayed visits alike an enhanced experience about the video that’s showing.</p>
<p id="calibre_link-1882" class="calibre19">

The goal for our application is to have multiple information systems. We might pull from an API like WolframAlpha while at the same time referencing a local database. WolframAlpha is a service that allows users to ask natural-language questions and get rich responses. We’d like our design to start multiple information system queries in parallel and accumulate the results. Then, we can take the best matching responses.</p><h3 class="calibre22">Planning our Supervision Strategy</h3>
<p id="calibre_link-1883" class="calibre19">






Think about our information system requirements. We want to fetch the most relevant information for a user in real time, across different backends. Since we’re fetching results in parallel, a failure likely means the network or one of our third-party services failed. That’s out of our control. It doesn’t make sense for us to retry the computation because this operation is time sensitive&mdash;a video is playing. Instead, we want to spawn processes in parallel and let them do their work, and we’ll take as many results as we can get within some limited block of time. Say we spawn requests from Google, WolframAlpha, and Bing. If one of those three information system backends crashes, it’s not a problem, or at least not a problem we can solve. Let’s think about how we might code those services.</p>
<p id="calibre_link-1884" class="calibre19">
If you find yourself in the position of spinning off some concurrent process without the need to supervise that process, you can usually use a <span class="calibre4">task</span> without having to specify any supervision at all. For the sake of performance, you’ll often start several tasks to do high-latency jobs and then wait for them to finish, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">task1 = Task.async(​<strong class="kw">fn</strong>​ -&gt; access_some_api() ​<strong class="kw">end</strong>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">task2 = Task.async(​<strong class="kw">fn</strong>​ -&gt; access_another_api() ​<strong class="kw">end</strong>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Task.await(task1)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Task.await(task2)</td></tr></table>
<p id="calibre_link-1885" class="calibre19">Here’s what’s happening. The parent process is starting two asynchronous tasks, which are linked processes. If either of them fails, they are linked so our parent will also fail. This model is generally fine because of the linking. When a child or parent dies, cleanup will happen exactly as it should.</p>
<p id="calibre_link-1886" class="calibre19">But think about our InfoSys requirements. We <span class="calibre4">don’t want to link those processes</span> because we can’t address a failure in, say, Bing, but we still want the parent to continue. That means we can’t use <span class="cf">T</span><span class="cf">ask.async</span> and <span class="cf">T</span><span class="cf">ask.await</span>. You might think it makes perfect sense to start a one-off fire-and-forget process for each service.</p>
<p id="calibre_link-1887" class="calibre19">
That would be a mistake. We always want to start processes inside supervision trees for cleanup and discoverability. Each process we start should obey its explicit start and shutdown rules, so we’ll clean up effectively and be able to view those supervised processes through tools like Observer. Therefore, we’ll start our tasks through <span class="cf">T</span><span class="cf">ask.Supervisor.async_nolink</span> instead of the typical <span class="cf">T</span><span class="cf">ask.async</span>.</p>
<p id="calibre_link-1888" class="calibre19">Upon deeper inspection, we will also need another process in the supervisor tree. Most external systems are rate-limited, or at the very least, resource constrained so we must limit our requests wherever possible. We will implement the cache system in a module yet to be created called <span class="cf">InfoSys.Cache</span>.
</p>
<p id="calibre_link-1889" class="calibre19">Both the <span class="cf">InfoSys.Cache</span> and <span class="cf">T</span><span class="cf">ask.Supervisor</span> will be part of our InfoSys supervision tree, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys/application.change2.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys/application.change2.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ InfoSys.Application ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  @moduledoc false</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ Application</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ start(_type, _args) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    children = [</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      InfoSys.Cache,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      {Task.Supervisor, ​<em class="string">name:</em>​ InfoSys.TaskSupervisor},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    opts = [​<em class="string">strategy:</em>​ ​<em class="string">:one_for_one</em>​, ​<em class="string">name:</em>​ InfoSys.Supervisor]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    Supervisor.start_link(children, opts)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1890" class="calibre19">With that accomplished, we’re ready to code our service. Since we don’t have to worry about managing error conditions, we’re free to focus on the main task of the information system, and we can let the error cases crash. The real work gets simpler.</p><h3 class="calibre22">Building a Cache Server Without Bottlenecks</h3>
<p id="calibre_link-1891" class="calibre19">


Now that we’ve sketched a supervision tree that allows us to start tasks dynamically under their own supervisor, we’ll need to create our information retrievers. First, we need to consider one final detail. We need to decide how our main interface will work with our Information System. We’d like to be able to choose from several different backends&mdash;say one for Google, one for WolframAlpha, and so on&mdash;as shown in the <a href="#calibre_link-27" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">figure</a>.</p><div id="calibre_link-27" class="praise"><div class="praise"><img id="calibre_link-1892" class="border2" src="images/000046.png" alt="images/src/otp/infosys.png" width="630" height="497" /></div></div>
<p id="calibre_link-1893" class="calibre19">
That seems right. When a user makes a query, our information system will start up as many different task queries as we have backends. Then, we’ll collect the results from each and choose the best one to send to the user, caching the results of each request for better performance. We have an open question, though. We may have multiple requests coming at the same time. If all requests depend on a single process for caching, said process will become a bottleneck and hurt the user experience.</p>
<p id="calibre_link-1894" class="calibre19">


The answer is surprisingly simple. We will use a shared service to write things to memory. It turns out that Erlang already has such a service called <span class="cf">:ets</span>, which stands for Erlang Term Storage (ETS). ETS is an in-memory storage solution included with OTP that allows you to store and retrieve any valid Erlang or Elixir data, and it’s super fast. That’s perfect for our caching service. Using ETS with our cache will let us use a single cache server to handle the cache expiration, while allowing concurrent reads and writes from every possible client to happen directly in ETS. However, since the cache is in-memory, it is not shared between different Phoenix nodes so every time the node starts &mdash; during deployments, for example &mdash; the cache starts empty.</p>
<p id="calibre_link-1895" class="calibre19">Create a new file in <span class="cf">lib/info_sys/cache.ex</span> and key this in:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys/cache.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys/cache.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ InfoSys.Cache ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ GenServer</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ put(name \\ __MODULE__, key, value) ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">    true = ​<em class="string">:ets</em>​.insert(tab_name(name), {key, value})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<em class="string">:ok</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ fetch(name \\ __MODULE__, key) ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, ​<em class="string">:ets</em>​.lookup_element(tab_name(name), key, 2)}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">rescue</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ArgumentError -&gt; ​<em class="string">:error</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ start_link(opts) ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    opts = Keyword.put_new(opts, ​<em class="string">:name</em>​, __MODULE__)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    GenServer.start_link(__MODULE__, opts, ​<em class="string">name:</em>​ opts[​<em class="string">:name</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">20:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ init(opts) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    new_table(opts[​<em class="string">:name</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, %{}}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">25:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">defp</strong>​ new_table(name) ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    name</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    |&gt; tab_name()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    |&gt; ​<em class="string">:ets</em>​.new([</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">       ​<em class="string">:set</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">30:&nbsp;</span></td><td class="codeline">       ​<em class="string">:named_table</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">       ​<em class="string">:public</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">       ​<em class="string">read_concurrency:</em>​ true,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">       ​<em class="string">write_concurrency:</em>​ true])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">35:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">defp</strong>​ tab_name(name), ​<strong class="kw">do</strong>​: ​<em class="string">:"</em>​​<em class="string">#{</em>​name​<em class="string">}</em>​​<em class="string">_cache"</em>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1896" class="calibre19">



Our server isn’t doing any stateful work yet, but for now we can focus on the interface and ETS usage. We start by defining <span class="cf">start_link</span> on line 15, where we ensure a <span class="cf">:name</span> option is present, which is used to name the GenServer. Skipping <span class="cf">put</span> and <span class="cf">fetch</span> for a second, we default the server name to that of our module, which will allow us to use a generic single cache for now, but start other independent caches as needed. This approach will also come in handy later when it comes to testing OTP services. Both functions make use of a private <span class="cf">tab_name</span> function, which we defined on line 36. This function simply returns an atom of the table name to use for our ETS table.</p>
<p id="calibre_link-1897" class="calibre19">






Now, let’s get back to our client cache interface. Any cache needs a read and write. Ours are <span class="cf">fetch</span> and <span class="cf">put</span> on lines 4 and 9. In our <span class="cf">put</span> function, we call <span class="cf">:ets.insert</span>, converting our GenServer’s name to a table name, and passing a key and value pair to store in the table as a tuple. We match on the <span class="cf">true</span> result to ensure it was successful, then return <span class="cf">:ok</span> to the caller. Our <span class="cf">fetch</span> function wraps the somewhat clumsy API of ETS. We used <span class="cf">:ets.lookup_element</span> to fetch a value out of our table for a given key, passing the one-based index of the value&mdash;<span class="cf">2</span> in our case. ETS unfortunately throws an <span class="cf">ArgumentError</span> if we try to look up a key which does not exist, so we use <span class="cf">rescue</span> to translate the result into an <span class="cf">:error</span> value.

</p>
<p id="calibre_link-1898" class="calibre19">
Next, we begin the stateful work of our server by defining the <span class="cf">init</span> function. We create and name our ETS table with <span class="cf">new_table</span> and return <span class="cf">{:ok, %{}}</span>, where the empty map is the server state. ETS tables are owned by a single process, and the table’s existence lives and dies with that of its owner. This is great because we don’t have to worry about state values or cleanup when a process stops, either naturally or via a crash.</p>
<p id="calibre_link-1899" class="calibre19">


Let’s break down <span class="cf">new_table</span> on line 25. We call <span class="cf">:ets.new</span>, passing our table name, as well as a list of options. The options are important. <span class="cf">:set</span> is a type of ETS table that acts as a key-value store. The <span class="cf">:named_table</span> option allow us to locate this table by its name. Critically, <span class="cf">:public</span> lets processes other than the owner read and write values. Finally, we enable read and write concurrency to maximize the performance of our cache for concurrent workloads.</p>
<p id="calibre_link-1900" class="calibre19">Our Cache isn’t quite complete, but let’s take what we have so far for a spin in iex:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ alias InfoSys.Cache</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Cache.put(​<em class="string">"</em>​​<em class="string">one plus one?"</em>​, ​<em class="string">"</em>​​<em class="string">two"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">:ok</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Cache.fetch(​<em class="string">"</em>​​<em class="string">one plus one?"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{:ok, "two"}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Cache.fetch(​<em class="string">"</em>​​<em class="string">not here"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">:error</td></tr></table>
<p id="calibre_link-1901" class="calibre19">

We have nothing too fancy yet, but it all works just fine, almost. We have a problem, though. Our cache doesn’t yet expire old values. If we don’t remove old values from our cache, our memory footprint will just continue to grow. In our case, we only require a short-lived cache for remotely fetched data, so let’s change that.</p>
<p id="calibre_link-1902" class="calibre19">

Here’s our strategy for sweeping the cache. We’ll change the shape of the state data for our supervisor. We’ll have a map with these keys. <span class="cf">:interval</span> will define the amount of time between sweeps, <span class="cf">:timer</span> will hold the <span class="cf">pid</span> for a timer, and <span class="cf">table</span> will hold our <span class="cf">ETS</span> table. We will start a timer process after our interval to schedule a sweep. Then the sweep will purge all of the values in our cache. It’s not a sophisticated sweep strategy, but it should be enough for our purposes to take some load off of the server for oft-used information requests. Crack open <span class="cf">cache.ex</span>, add the <span class="cf">schedule_clear</span> function and call it from the <span class="cf">handle_info</span>, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys/cache.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys/cache.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">@clear_interval ​<em class="string">:timer</em>​.seconds(60)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ init(opts) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  state = %{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">    ​<em class="string">interval:</em>​ opts[​<em class="string">:clear_interval</em>​] || @clear_interval,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<em class="string">timer:</em>​ nil,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<em class="string">table:</em>​ new_table(opts[​<em class="string">:name</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">  {​<em class="string">:ok</em>​, schedule_clear(state)}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ handle_info(​<em class="string">:clear</em>​, state) ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<em class="string">:ets</em>​.delete_all_objects(state.table)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline">  {​<em class="string">:noreply</em>​, schedule_clear(state)}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">defp</strong>​ schedule_clear(state) ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  %{state | ​<em class="string">timer:</em>​ Process.send_after(self(), ​<em class="string">:clear</em>​, state.interval)}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">20:&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1903" class="calibre19">


We rewrote our <span class="cf">init</span> function to build a map of state containing our <span class="cf">:table</span>, along with new values for a <span class="cf">:timer</span>, as well as millisecond <span class="cf">:interval</span> for clearing the cache, which we’ve defaulted to sixty seconds. Before returning from init, we call to a new private <span class="cf">schedule_clear</span> function on line 18, which simply uses <span class="cf">Process.send_after</span> to send our process a message in the future, after <span class="cf">state.interval</span> milliseconds have passed. We then pick up the <span class="cf">:clear</span> messages inside a <span class="cf">handle_info</span> callback, defined on line 13. This callback has two jobs. First, it purges the cache of all values by calling <span class="cf">:ets.delete_all_objects</span>. Second, it reschedules the next purge with <span class="cf">schedule_clear</span>.</p>
<p id="calibre_link-1904" class="calibre19">Our cache expiration is a very basic sweep for now, but it will be perfect for our use case. We can always update our cache sweeper if it proves to be necessary, and our API will not need to change, only the supervisor implementation. Let’s try it out in iex:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ alias InfoSys.Cache</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">InfoSys.Cache</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Cache.put(​<em class="string">"</em>​​<em class="string">one plus one?"</em>​, ​<em class="string">"</em>​​<em class="string">two"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">:ok</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Cache.fetch(​<em class="string">"</em>​​<em class="string">one plus one?"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{:ok, "two"}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Process.sleep(60_000)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">:ok</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Cache.fetch(​<em class="string">"</em>​​<em class="string">one plus one?"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">:error</td></tr></table>
<p id="calibre_link-1905" class="calibre19">We can see our cache expiration in action by inserting a cached query, waiting for a minute, and fetching again. Our next query shows a cache miss, indicating our cache has been pruned. It works!






</p><h3 class="calibre22">Using Tasks to Fetch Data</h3>
<p id="calibre_link-1906" class="calibre19">

With our cache in place and our Task supervisor up and running, we can build our generic information system. We want an interface that knows about available backends. We’ll spawn tasks to concurrently query each available backend service, fetch the response from each and cache the result. Then we can pick the best result from all possible candidates. It sounds complicated, but our layering will make building each service surprisingly simple. We’ll lean on Elixir and OTP to handle the details.</p>
<p id="calibre_link-1907" class="calibre19">Let’s create our interface in <span class="cf">apps/info_sys/lib/info_sys.ex</span>, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ InfoSys ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  @backends [InfoSys.Wolfram]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">defmodule</strong>​ Result ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    defstruct ​<em class="string">score:</em>​ 0, ​<em class="string">text:</em>​ nil, ​<em class="string">backend:</em>​ nil</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ compute(query, opts \\ []) ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">    opts = Keyword.put_new(opts, ​<em class="string">:limit</em>​, 10)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    backends = opts[​<em class="string">:backends</em>​] || @backends</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    backends</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    |&gt; Enum.map(&amp;async_query(&amp;1, query, opts))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">defp</strong>​ async_query(backend, query, opts) ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    Task.Supervisor.async_nolink(InfoSys.TaskSupervisor,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      backend, ​<em class="string">:compute</em>​, [query, opts], ​<em class="string">shutdown:</em>​ ​<em class="string">:brutal_kill</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">20:&nbsp;</span></td><td class="codeline">    )</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1908" class="calibre19">
Of the three hypothetical backends, we’re going to focus on WolframAlpha. Building each of the others should be the same. Let’s break it down. Our <span class="cf">InfoSys</span> is a generic module to spawn computations for queries. These backends are their own processes, but <span class="cf">InfoSys</span> isn’t. We put all of the results into a single list, wait for each response from each spawned task, and finally pick the best one to return to the user.</p>
<p id="calibre_link-1909" class="calibre19">


At the top of our module, we use a module attribute called <span class="cf">@backends</span> to build a list of all the backends we support, which is initially only <span class="cf">InfoSys.Wolfram</span>. We’ll leave this API open so we can add other backends over time.</p>
<p id="calibre_link-1910" class="calibre19">
Next, we define a <span class="cf">Result</span> struct to hold each search result. Our struct has <span class="cf">:score</span> for storing relevance, <span class="cf">:text</span> to describe the result, and the <span class="cf">:backend</span> to use for the computation. With the preliminary supporting ceremony out of the way, we move on to define a simple basic API.  We’ll use <span class="cf">compute</span> as the main entry point for our service and <span class="cf">async_query</span> to actually spawn off a task to do the actual work.</p>
<p id="calibre_link-1911" class="calibre19">
On line 9, we define <span class="cf">compute</span>. That function maps over all backends, calling a <span class="cf">async_query</span> function for each one. We start with only one of them, but the implementation for multiple backends is exactly the same. This is the basic API function. The magic all happens in <span class="cf">async_query</span>.</p>
<p id="calibre_link-1912" class="calibre19">
On line 17, you can see our Task Supervisor in action. There’s a lot going on, so let’s break it down. We are invoking a task, so we need to provide the module, function and arguments for our new task. We call <span class="cf">T</span><span class="cf">ask.Supervisor.async_nolink</span> to spawn off the new task. That function spawns off a task in a new process, calling the function we specify, complete with our query and limit attributes. We use <span class="cf">async_nolink</span> to spawn the task isolated from our caller, allowing our clients to query backends and not be worried about a crash or unexpected error. This strategy makes sense for our application because we have real end-users waiting on results. If a result doesn’t come back from one of our services, we’ll just discard the result and the supervisor will kill it. The function returns the Task struct, which we’ll await later on. When you consider how much this code is doing, this listing is remarkably compact.</p>
<p id="calibre_link-1913" class="calibre19">Now it’s time to build the actual Wolfram backend.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-192"><div id="calibre_link-1914" class="calibre2"><h2 id="calibre_link-148" class="calibre20">Building the Wolfram Info System</h2>
<p id="calibre_link-1915" class="calibre19">
Now that we have our generic <span class="cf">InfoSys</span> module in place, we can work on specific backends. We’ll start with only one, our <span class="cf">Wolfram</span> backend. This module will call WolframAlpha to retrieve relevant information about our users’ annotations.</p>
<p id="calibre_link-1916" class="calibre19">
Our first step is to define our backend interface. Since all our backends will have the same contract, this is a perfect use case for a backend <span class="calibre4">behaviour</span>. A behaviour is a contract, a common API across modules. We have seen OTP behaviours, such as GenServer and Supervisor, as well as behaviours from libraries like <span class="cf">Plug</span>. Remember, each plug implements two functions, <span class="cf">init/1</span> and <span class="cf">call/2</span>. Our behaviour will be a tiny contract between the information system and each backend, consisting of just two callbacks, <span class="cf">name</span> and <span class="cf">compute</span>. Create a file in <span class="cf">lib/info_sys/backend.ex</span>, and key this in:

</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys/backend.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys/backend.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ InfoSys.Backend ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  @callback name() :: String.t()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  @callback compute(query :: String.t(), opts :: Keyword.t()) ::</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    [%InfoSys.Result{}]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1917" class="calibre19">


We define two functions. We don’t actually declare a function. Instead, we use <span class="calibre4">typespecs</span>, which specify not just the name of our functions but also the types of arguments and return values. In our case, the <span class="cf">name</span> function takes no arguments but returns a <span class="cf">String</span> type, so you can see the <span class="cf">String.t</span> in the typespec. The <span class="cf">compute</span> function takes a <span class="cf">String.t</span> query, a <span class="cf">Keyword.t</span> list of options, and returns a list of <span class="cf">%InfoSys.Result{}</span> structs.</p>
<p id="calibre_link-1918" class="calibre19">


With our behaviour in place, we can write our first backend. To do so, we’ll need to establish our dependencies. Wolfram Alpha returns XML responses, and we’ll use an XML parser to avoid processing those by hand. Let’s add <span class="cf">:sweet_xml</span> to our <span class="cf">deps</span> list in <span class="cf">mix.exs</span>. We want to add the dependencies to <span class="cf">info_sys</span> since umbrellas manage dependencies at the child applications:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/otp/listings/rumbl_umbrella/apps/info_sys/mix.change1.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">otp/listings/rumbl_umbrella/apps/info_sys/mix.change1.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{​<em class="string">:sweet_xml</em>​, ​<em class="string">"</em>​​<em class="string">~&gt; 0.6.5"</em>​},</td></tr></table>
<p id="calibre_link-1919" class="calibre19">
Next, run <span class="cf">$ mix deps.get</span> to grab the dependency from Hex. With our XML library in place, we’re ready to sign up as a WolframAlpha API developer and retrieve our application ID. Visit the WolframAlpha developer portal,<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-267" href="#calibre_link-193">[33]</a></sup>  sign up for a new account, and follow the instructions to get your <span class="cf">AppID</span>.</p>
<p id="calibre_link-1920" class="calibre19">






Now that you have a developer API key, you could place it directly in <span class="cf">config/dev.exs</span>, but there’s a better way. You shouldn’t check in private credentials under version control. In fact, Phoenix points you in the right direction with the generated <span class="cf">config/prod.secret.exs</span> file. That file references environment variables that are securely set on the production server, meaning you can establish sensitive configuration in your local development environment without checking secret values into version control. That way you can include sensitive credentials properly. Let’s add our API key lookup to our development and prod environments. Since tests will not hit the Wolfram API directly, we don’t need to set a key for that environment. Add the following entry to your <span class="cf">config/dev.exs</span> and <span class="cf">config/prod.secret.exs</span> like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">wolfram_app_id =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  System.get_env(​<em class="string">"</em>​​<em class="string">WOLFRAM_APP_ID"</em>​) ||</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">raise</strong>​ ​<em class="string">"""</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">    environment variable WOLFRAM_APP_ID is missing.</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">    """</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">config ​<em class="string">:info_sys</em>​, ​<em class="string">:wolfram</em>​, ​<em class="string">app_id:</em>​ wolfram_app_id</td></tr></table>
<p id="calibre_link-1921" class="calibre19">With setup out of the way, we can now implement our <span class="cf">Wolfram</span> backend in <span class="cf">lib/info_sys/wolfram.ex</span>, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys/wolfram.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys/wolfram.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ InfoSys.Wolfram ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">import</strong>​ SweetXml</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  alias InfoSys.Result</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">  @behaviour InfoSys.Backend </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  @base ​<em class="string">"</em>​​<em class="string">http://api.wolframalpha.com/v2/query"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  @impl true</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ name, ​<strong class="kw">do</strong>​: ​<em class="string">"</em>​​<em class="string">wolfram"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  @impl true</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ compute(query_str, _opts) ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    query_str</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline">    |&gt; fetch_xml()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    |&gt; xpath(​<strong class="kw">~</strong>​x​<em class="string">"</em>​​<em class="string">/queryresult/pod[contains(@title, 'Result') or</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<em class="string">                                 contains(@title, 'Definitions')]</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<em class="string">                            /subpod/plaintext/text()"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    |&gt; build_results()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">20:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">defp</strong>​ build_results(nil), ​<strong class="kw">do</strong>​: [] </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">defp</strong>​ build_results(answer) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">25:&nbsp;</span></td><td class="codeline">    [%Result{​<em class="string">backend:</em>​ __MODULE__, ​<em class="string">score:</em>​ 95, ​<em class="string">text:</em>​ to_string(answer)}]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">defp</strong>​ fetch_xml(query) ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, {_, _, body}} = ​<em class="string">:httpc</em>​.request(String.to_charlist(url(query)))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">30:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    body</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">defp</strong>​ url(input) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">35:&nbsp;</span></td><td class="codeline">    ​<em class="string">"</em>​​<em class="string">#{</em>​@base​<em class="string">}</em>​​<em class="string">?"</em>​ &lt;&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    URI.encode_query(​<em class="string">appid:</em>​ id(), ​<em class="string">input:</em>​ input, ​<em class="string">format:</em>​ ​<em class="string">"</em>​​<em class="string">plaintext"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">defp</strong>​ id, ​<strong class="kw">do</strong>​: Application.fetch_env!(​<em class="string">:info_sys</em>​, ​<em class="string">:wolfram</em>​)[​<em class="string">:app_id</em>​]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">40:&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1922" class="calibre19">


To start our module, we import the functions we’ll need and set up a single alias. <span class="cf">SweetXml</span> will help us parse the XML we receive, and <span class="cf">Result</span> has the struct for the results we’ll use.</p>
<p id="calibre_link-1923" class="calibre19">

Next, we establish our module as a implementation of the <span class="cf">InfoSys.Backend</span> behaviour on line 5. In <span class="cf">compute</span> on line 13, we build a pipe to take our query, fetch the XML we’ll need, extract the results using the <span class="cf">xpath</span> function from <span class="cf">SweetXml</span>, and then build the results. We  specify our <span class="cf">compute</span> function as an implementation of a behaviour with the <span class="cf">@impl true</span> notation. That module attribute is not required but it makes our intentions clear. Users of our module can immediately tell which functions implement our behaviour and which ones don’t. Next, we’ll look at the functions that do each one of these tasks.</p>
<p id="calibre_link-1924" class="calibre19">


In <span class="cf">fetch_xml</span> on line 28, we contact WolframAlpha with the query string that interests us. We use <span class="cf">:httpc</span>, which ships within Erlang’s standard library, to do the straight HTTP request, matching against <span class="cf">:ok</span> and the <span class="cf">body</span> that we return to the calling client. We use private functions to extract our API key from our application configuration and build the full URL of our API request.</p>
<p id="calibre_link-1925" class="calibre19">
In <span class="cf">build_results</span> on line 22, we build a list of result structs. <span class="cf">build_results</span> has two different forms, depending on whether we get results back or not. We match on the first argument in our function head. On <span class="cf">nil</span>, we need only return an empty list. Otherwise, we build a list of <span class="cf">result</span> structs with our expected results and score, and return them to the caller.</p>
<p id="calibre_link-1926" class="calibre19">Let’s try it out with <span class="cf">iex -S mix</span>. First, start a query. We’ve designed our backend to return results to the calling process, which we’ve wrapped in Tasks inside our <span class="cf">InfoSys.compute</span>. We don’t yet await the task completion inside <span class="cf">compute</span>, but we can issue <span class="cf">compute</span> requests and await the tasks inside iex. Remember, each backend will return a spawned Task, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ InfoSys.compute(​<em class="string">"</em>​​<em class="string">what is elixir?"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  %Task{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    owner: #PID&lt;0.320.0&gt;,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    pid: #PID&lt;0.340.0&gt;,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ref: #Reference&lt;0.4138658672.566755329.204828&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">]</td></tr></table>
<p id="calibre_link-1927" class="calibre19">



That query fires off a single <span class="cf">Wolfram</span> backend query and then the task sends results to the calling process. We can call <span class="cf">T</span><span class="cf">ask.await</span> on our <span class="cf">task</span>, but the result should be waiting for us in our current process when the task completes.</p>
<p id="calibre_link-1928" class="calibre19">Let’s use the <span class="cf">flush</span> helper from <span class="cf">IEx</span> to see any messages we’ve received:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex(13)&gt;</span>​ InfoSys.compute(​<em class="string">"</em>​​<em class="string">what is elixir"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex(14)&gt;</span>​ flush()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  %InfoSys.Result{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    backend: InfoSys.Wolfram,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    score: 95,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    text: "1 | noun | a sweet flavored liquid (usually containing a small ..."</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">...</td></tr></table><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex(15)&gt;</span>​ InfoSys.compute(​<em class="string">"</em>​​<em class="string">what is firebird?"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex(16)&gt;</span>​ flush()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  %InfoSys.Result{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    backend: InfoSys.Wolfram,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    score: 95,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    text: "1 | noun | the male is bright red with black wings and tail\n2..."</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">...</td></tr></table>
<p id="calibre_link-1929" class="calibre19">Brilliant. Our <span class="cf">Wolfram</span> service is working exactly as we expect.  Once the task is complete, we receive the results in our mailbox. We can wait for each task to complete with <span class="cf">T</span><span class="cf">ask.await</span>. Your results may not be the same, but for every result you see in the list, you get our hardcoded score of 95 percent. Remember, <span class="cf">flush()</span> can just return <span class="cf">:ok</span> if the message isn’t yet in your inbox. If that happens to you, wait a few seconds and try again.
</p><h3 class="calibre22">Monitoring Processes</h3>
<p id="calibre_link-1930" class="calibre19">


If you watched closely, you may have also noticed the <span class="cf">{:DOWN, ...}</span> message we received, in addition to the task results. Internally, the Task library sets up a monitor from the caller process to the Task. If we wanted to, we could use <span class="cf">Process.monitor</span> to detect backend crashes while we’re waiting on results. Once a monitor is set, we’ll get a message when the monitored process dies. For example, you can see this concept at work in IEx:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ pid = spawn(​<strong class="kw">fn</strong>​ -&gt; ​<em class="string">:ok</em>​ ​<strong class="kw">end</strong>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ Process.monitor(pid)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">#Reference&lt;0.0.2.2850&gt;</td></tr></table>
<p id="calibre_link-1931" class="calibre19">We spawn a pid with a trivial function. We set up a monitor with Process.monitor. We get a reference back to identify this monitor. Meanwhile, the pid process dies immediately because it has no work to do. Let’s use flush to check out our IEx mailbox, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ flush()</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{:DOWN, #Reference&lt;0.0.2.2850&gt;, :process, #PID&lt;0.405.0&gt;, :normal} :ok</td></tr></table>
<p id="calibre_link-1932" class="calibre19">Nice! We receive a regular Elixir message as a <span class="cf">{:DOWN, ...}</span> tuple, informing us that our process died. We won’t be monitoring our backends directly with <span class="cf">Process.monitor</span> because the Task module calls it for us, but it’s nice to know how the monitoring primitives work as they power much of the high-level OTP tools you are used to using, such as supervisors and monitors.</p>
<p id="calibre_link-1933" class="calibre19">

To make our backends more friendly to our clients, we need to make a few modifications. We’ll need to detect when a backend crashes so we don’t wait for results that might never arrive. In addition, we need to order the results we get from all the backends by our relevance score so it will be easier to pick the best one. Finally, we need to specify a reasonable timeout so the information systems that take too long won’t hold up other results. Let’s get started.</p><h3 class="calibre22">Working with Task Tools</h3>
<p id="calibre_link-1934" class="calibre19">



Elixir’s <span class="cf">T</span><span class="cf">ask</span> module has a perfect feature for our requirements: task <span class="calibre4">yielding</span>. While <span class="cf">T</span><span class="cf">ask.await</span> would crash the caller should a given task time out, <span class="cf">T</span><span class="cf">ask.yield</span> blocks the caller, returning the result, an error, or <span class="cf">nil</span>, depending on whether a reply is received. We also need the ability to wait on <span class="calibre4">all tasks</span>, taking no more than a given time for total execution. Fortunately, Elixir provides <span class="cf">T</span><span class="cf">ask.yield_many</span>, which gives us exactly that.</p>
<p id="calibre_link-1935" class="calibre19">Let’s apply this feature to our <span class="cf">InfoSys</span> client. We’ll automatically collect results and ignore responses from crashed or tardy backends, making our services predictable and safe. Extend your <span class="cf">apps/info_sys/lib/info_sys.ex</span>, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ compute(query, opts \\ []) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  timeout = opts[​<em class="string">:timeout</em>​] || 10_000 </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  opts = Keyword.put_new(opts, ​<em class="string">:limit</em>​, 10)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  backends = opts[​<em class="string">:backends</em>​] || @backends</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  backends</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  |&gt; Enum.map(&amp;async_query(&amp;1, query, opts))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  |&gt; Task.yield_many(timeout) </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  |&gt; Enum.map(​<strong class="kw">fn</strong>​ {task, res} -&gt; res || Task.shutdown(task, ​<em class="string">:brutal_kill</em>​) ​<strong class="kw">end</strong>​) </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">  |&gt; Enum.flat_map(​<strong class="kw">fn</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, results} -&gt; results</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    _ -&gt; []</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  |&gt; Enum.sort(&amp;(&amp;1.score &gt;= &amp;2.score))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline">  |&gt; Enum.take(opts[​<em class="string">:limit</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1936" class="calibre19">The <span class="cf">compute</span> function now automatically waits for results. When we receive results, we sort them by score and report the top ones. The pipeline is interesting. We start with our backends, and map over them with the queries we fire to our backends. Starting on line 8, we take all spawned backend tasks and call <span class="cf">T</span><span class="cf">ask.yield_many</span> with our timeout.</p>
<p id="calibre_link-1937" class="calibre19">Now, things get interesting. Let’s study the pipeline starting on line 9 through the end of the function. It’s an extremely dense chunk of code, but it’s all important.</p>
<p id="calibre_link-1938" class="calibre19">

First we need to walk through each of the task results. We map over each result, which comes in the form of a task-result tuple. In the function head, we match both to <span class="cf">task</span> and <span class="cf">res</span> for later use. For each one, we execute the expression <span class="cf">res || T</span><span class="cf">ask.shutdown(task, :brutal_kill)</span>. That little snippet is the lynchpin of this block of code.</p>
<p id="calibre_link-1939" class="calibre19">




If we get a result back in <span class="cf">res</span> we simply return it, and the other half of the <span class="cf">||</span> operator never fires. If we get a <span class="cf">nil</span> back, we’ll process the right side. We shut down the task  with a <span class="cf">:brutal_kill</span> option, meaning it’s an immediate shutdown, without waiting for completion. Note that this snippet also protects us from a race condition. Theoretically, a task could complete between when we ask for the <span class="cf">yield_many</span> and when we actually process the results. In this case, we still want to make sure to kill the task.</p>
<p id="calibre_link-1940" class="calibre19">
The result of this map is tuples with either <span class="cf">{:ok, result}</span> or <span class="cf">{:error, reason}</span>, and we’re ready to process those results. We grab successful results, ignore <span class="cf">:error</span> results by returning a <span class="cf">[]</span>. We sort by score, and then use <span class="cf">Enum.take</span> to return up to the limit our client specifies.</p>
<p id="calibre_link-1941" class="calibre19">And that’s a wrap. Whew.</p>
<p id="calibre_link-1942" class="calibre19">Now that our code is yielding to our tasks, we’re left with only results that complete successfully within the specified timeout. That’s the beauty of tasks. They allow us a tidy way to handle resources that could otherwise leak.</p>
<p id="calibre_link-1943" class="calibre19">Let’s give it a try:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">iex&gt; InfoSys.compute(​<em class="string">"</em>​​<em class="string">what is the meaning of life?"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  %InfoSys.Result{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">backend:</em>​ ​<em class="string">"</em>​​<em class="string">wolfram"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">score:</em>​ 95,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">text:</em>​ ​<em class="string">"</em>​​<em class="string">42\n(according to the book The Hitchhiker's Guide..."</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">]</td></tr></table>
<p id="calibre_link-1944" class="calibre19">Our information system now handles failures exactly as we desire. We were able to add complexity such as isolated failures and timeouts to the combined information system service without changing the policies for individual backends. Because each backend is simply synchronous code running inside a new task process, we can leverage everything in OTP to make our system resilient without changing the business code.</p><h3 class="calibre22">Caching Results</h3>
<p id="calibre_link-1945" class="calibre19">




With our asynchronous backend in place, we’re ready to integrate our Cache server. Open up <span class="cf">apps/info_sys/lib/info_sys.ex</span> and add the <span class="cf">compute</span> function just below the <span class="cf">defstruct</span>, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys.change2.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys.change2.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">alias InfoSys.Cache</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ compute(query, opts \\ []) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  timeout = opts[​<em class="string">:timeout</em>​] || 10_000</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">  opts = Keyword.put_new(opts, ​<em class="string">:limit</em>​, 10)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  backends = opts[​<em class="string">:backends</em>​] || @backends</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  {uncached_backends, cached_results} =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    fetch_cached_results(backends, query, opts) </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  uncached_backends</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  |&gt; Enum.map(&amp;async_query(&amp;1, query, opts))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  |&gt; Task.yield_many(timeout)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  |&gt; Enum.map(​<strong class="kw">fn</strong>​ {task, res} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline">      res || Task.shutdown(task, ​<em class="string">:brutal_kill</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  |&gt; Enum.flat_map(​<strong class="kw">fn</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, results} -&gt; results</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    _ -&gt; []</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">20:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  |&gt; write_results_to_cache(query, opts) </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  |&gt; Kernel.++(cached_results) </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  |&gt; Enum.sort(&amp;(&amp;1.score &gt;= &amp;2.score))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  |&gt; Enum.take(opts[​<em class="string">:limit</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">25:&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1946" class="calibre19">We modified our <span class="cf">compute</span> function to read from the cache for each backend given a query, join those values to the fetched results, and write new values to the cache. First, we added a lookup to return results from uncached backend queries, and merged those with existing cached results, on line 9. Then we piped the filtered backends to our original pipeline, performing our async task work as before. Next, we added a new pipe operation, where we write the new results to the cache, then append the cached results before sorting by score, on lines 21 and 22.</p>
<p id="calibre_link-1947" class="calibre19">To support our new pipe operations, we wrote two private functions. Let’s add the first of them now, below our new <span class="cf">compute</span> function:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys.change2.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys.change2.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">​<strong class="kw">defp</strong>​ fetch_cached_results(backends, query, opts) ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  {uncached_backends, results} =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    Enum.reduce(</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      backends,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">      {[], []},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      ​<strong class="kw">fn</strong>​ backend, {uncached_backends, acc_results} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">        ​<strong class="kw">case</strong>​ Cache.fetch({backend.name(), query, opts[​<em class="string">:limit</em>​]}) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">          {​<em class="string">:ok</em>​, results} -&gt; {uncached_backends, [results | acc_results]}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">          ​<em class="string">:error</em>​ -&gt; {[backend | uncached_backends], acc_results}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">        ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      ​<strong class="kw">end</strong>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  {uncached_backends, List.flatten(results)}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1948" class="calibre19">On line 1, we defined a <span class="cf">fetch_cached_results</span> function to take all backends and accumulate the cached results for the given query, as well as the backends which contain no cached information. This way we can return both the cached result set, as well as the remaining backends that need fresh queries. Now, we can write the results, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys.change2.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys.change2.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">​<strong class="kw">defp</strong>​ write_results_to_cache(results, query, opts) ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">2:&nbsp;</span></td><td class="codeline">  Enum.map(results, ​<strong class="kw">fn</strong>​ %Result{​<em class="string">backend:</em>​ backend} = result -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">3:&nbsp;</span></td><td class="codeline">    ​<em class="string">:ok</em>​ = Cache.put({backend.name(), query, opts[​<em class="string">:limit</em>​]}, result)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">4:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">    result</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">6:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">7:&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1949" class="calibre19">
On line 1, we defined a <span class="cf">write_results_to_cache</span> function which uses <span class="cf">Cache.put</span> to write our uncached results to our cache using the backend, query, and relevant options as our cache key. These previous three listings hold a moderately large amount of code, but just about all of it is fulfilling the goal of organizing, writing, and reading responses from the cache. Very little of the code is related to the ceremony of managing our cache server. That code lives elsewhere, in our supervisor.
Let’s try it out in IEx:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ ​<em class="string">:timer</em>​.tc(InfoSys, ​<em class="string">:compute</em>​, [​<em class="string">"</em>​​<em class="string">how old is the universe?"</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{1306573,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"> [</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   %InfoSys.Result{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">     backend: InfoSys.Wolfram,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">     score: 95,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">     text: "1.4×10^10 a (Julian years)\n(time elapsed since the Big Bang)",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"> ]}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ ​<em class="string">:timer</em>​.tc(InfoSys, ​<em class="string">:compute</em>​, [​<em class="string">"</em>​​<em class="string">how old is the universe?"</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{53,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"> [</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   %InfoSys.Result{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">     backend: InfoSys.Wolfram,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">     score: 95,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">     text: "1.4×10^10 a (Julian years)\n(time elapsed since the Big Bang)",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"> ]}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ ​<em class="string">:timer</em>​.tc(InfoSys, ​<em class="string">:compute</em>​, [​<em class="string">"</em>​​<em class="string">1 + 1"</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{1121249,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"> [</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   %InfoSys.Result{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">     backend: InfoSys.Wolfram,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">     score: 95,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">     text: "2",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"> ]}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">iex&gt;</span>​ ​<em class="string">:timer</em>​.tc(InfoSys, ​<em class="string">:compute</em>​, [​<em class="string">"</em>​​<em class="string">1 + 1"</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{47,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"> [</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   %InfoSys.Result{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">     backend: InfoSys.Wolfram,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">     score: 95,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">     text: "2",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"> ]}</td></tr></table>
<p id="calibre_link-1950" class="calibre19">



We used <span class="cf">:timer.tc</span> to measure the execution time in microseconds to run the given module, function and arguments. We can see our first call returned in 1.3s, while our second identical query returned in 53 microseconds. Issuing a new query of “1 + 1”, yielded a similar result. The first query was uncached, and had to make the remote hop to WolframAlpha, taking just over one second. The next call hit the cache and returned in 47 microseconds. Not bad!</p>
<p id="calibre_link-1951" class="calibre19">If you want to see the cache sweeping in action, wait 60 seconds, and re-issue one of our cached queries. You’ll see higher latency since our Cache clear operation is doing what it should. That wraps up our service. All that remains is to tie it into our channels.




</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-236"><div id="calibre_link-1952" class="calibre2"><h2 id="calibre_link-149" class="calibre20">Integrating OTP Services with Channels</h2>
<p id="calibre_link-1953" class="calibre19">



Now that we have a complete information system, let’s integrate it with our web frontend. Our goal is to call into our information system any time a user adds an annotation to a video, to see if we have relevant results to add to that user’s conversation.</p>
<p id="calibre_link-1954" class="calibre19">First let’s make sure <span class="cf">rumbl_web</span> depends on <span class="cf">info_sys</span>. Open up <span class="cf">apps/rumbl_web/mix.exs</span> and add this entry under <span class="cf">deps</span>:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{:info_sys, in_umbrella: true},</td></tr></table>
<p id="calibre_link-1955" class="calibre19">
Note how we were able to build and test <span class="cf">info_sys</span> in complete isolation and now we can introduce it as a dependency to any of the sibling applications that need it. If an application doesn’t need <span class="cf">info_sys</span>, then it doesn’t have to depend on it either.</p>
<p id="calibre_link-1956" class="calibre19">Next let’s integrate <span class="cf">InfoSys</span> with the <span class="cf">VideoChannel</span>. Whenever we receive a new annotation in <span class="cf">handle_in</span>, we want to invoke the <span class="cf">compute</span> function. Since the <span class="cf">compute</span> function is a blocking call, we want to make it asynchronous in our channel so our user gets the annotation broadcast right away. Let’s first use a task to spawn a function call for our <span class="cf">InfoSys</span> computation by making the following changes to your <span class="cf">lib/rumbl_web/channels/video_channel.ex</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/otp/listings/rumbl_umbrella/apps/rumbl_web/lib/rumbl_web/channels/video_channel.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">otp/listings/rumbl_umbrella/apps/rumbl_web/lib/rumbl_web/channels/video_channel.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ handle_in(​<em class="string">"</em>​​<em class="string">new_annotation"</em>​, params, user, socket) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">case</strong>​ Multimedia.annotate_video(user, socket.assigns.video_id, params) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, annotation} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      broadcast_annotation(socket, user, annotation) </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">      Task.start(​<strong class="kw">fn</strong>​ -&gt; compute_additional_info(annotation, socket) ​<strong class="kw">end</strong>​) </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      {​<em class="string">:reply</em>​, ​<em class="string">:ok</em>​, socket}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    {​<em class="string">:error</em>​, changeset} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      {​<em class="string">:reply</em>​, {​<em class="string">:error</em>​, %{​<em class="string">errors:</em>​ changeset}}, socket}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">defp</strong>​ broadcast_annotation(socket, user, annotation) ​<strong class="kw">do</strong>​  </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  broadcast!(socket, ​<em class="string">"</em>​​<em class="string">new_annotation"</em>​, %{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline">    ​<em class="string">id:</em>​ annotation.id,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<em class="string">user:</em>​ RumblWeb.UserView.render(​<em class="string">"</em>​​<em class="string">user.json"</em>​, %{​<em class="string">user:</em>​ user}),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<em class="string">body:</em>​ annotation.body,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<em class="string">at:</em>​ annotation.at</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  })</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">20:&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1957" class="calibre19">





On line 4, we extract our broadcast to a shared <span class="cf">broadcast_annotation</span> function so our information system can make use of it when it has relevant results to share. Next, we spawn a task on line 5 to asynchronously call a new <span class="cf">compute_additional_info</span> function, which we’ll write in a moment. We use <span class="cf">T</span><span class="cf">ask.start</span> because we don’t care about the task result nor if it fails. It’s important that we use a task here so we don’t block on any particular messages arriving to the channel.</p>
<p id="calibre_link-1958" class="calibre19">Now, let’s write <span class="cf">compute_additional_info</span> to ask our <span class="cf">InfoSys</span> for relevant results:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/otp/listings/rumbl_umbrella/apps/rumbl_web/lib/rumbl_web/channels/video_channel.change1.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">otp/listings/rumbl_umbrella/apps/rumbl_web/lib/rumbl_web/channels/video_channel.change1.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defp</strong>​ compute_additional_info(annotation, socket) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  for result &lt;-</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    InfoSys.compute(annotation.body, ​<em class="string">limit:</em>​ 1, ​<em class="string">timeout:</em>​ 10_000) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    backend_user = Accounts.get_user_by(​<em class="string">username:</em>​ result.backend.name())</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    attrs = %{​<em class="string">body:</em>​ result.text, ​<em class="string">at:</em>​ annotation.at}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">case</strong>​ Multimedia.annotate_video(</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      backend_user, annotation.video_id, attrs) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      {​<em class="string">:ok</em>​, info_ann} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">        broadcast_annotation(socket, backend_user, info_ann)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      {​<em class="string">:error</em>​, _changeset} -&gt; ​<em class="string">:ignore</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1959" class="calibre19">
First, we call into our information system, asking for only one result. Our service returns the best information it has, given our query. We tell it we are willing to wait ten seconds for an answer. Next, we use a comprehension to grab the backend user from our <span class="cf">Accounts</span> context, get the relevant attributes and annotate our video with that information. Finally we call <span class="cf">broadcast_annotation</span> on line 13 to report the new annotation to all subscribers on this topic. The integration is tight and smooth, and it’s done. Our code is extremely efficient with our caching layer. Imagine an active chat of users watching a sports game or chanting the same message. Our service won’t waste any cycles recomputing values.</p>
<p id="calibre_link-1960" class="calibre19">


We need to seed our database with a <span class="cf">wolfram</span> user to post annotations along with our real user conversations. Create a <span class="cf">priv/repo/backend_seeds.exs</span>, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/otp/listings/rumbl_umbrella/apps/rumbl/priv/repo/backend_seeds.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">otp/listings/rumbl_umbrella/apps/rumbl/priv/repo/backend_seeds.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">{​<em class="string">:ok</em>​, _} = Rumbl.Accounts.create_user(%{​<em class="string">name:</em>​ ​<em class="string">"</em>​​<em class="string">Wolfram"</em>​, ​<em class="string">username:</em>​ ​<em class="string">"</em>​​<em class="string">wolfram"</em>​})</td></tr></table>
<p id="calibre_link-1961" class="calibre19">Now, you can run these seeds with <span class="cf">mix run</span>, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">cd</strong>​​<strong class="kw"> </strong>​​<strong class="kw">apps/rumbl</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">run</strong>​​<strong class="kw"> </strong>​​<strong class="kw">priv/repo/backend_seeds.exs</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[debug] QUERY OK db=0.8ms</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">begin []</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[debug] QUERY OK db=80.9ms</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">INSERT INTO "users" ("name","username","inserted_at", ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[debug] QUERY OK db=7.5ms</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">commit []</td></tr></table>
<p id="calibre_link-1962" class="calibre19">Note we’re using our internal <span class="cf">create_user</span> function instead of the user-facing <span class="cf">register_user</span> function. The context function perfectly fits this scenario and allows us to not mix up end-user code paths with the path for internal users. Let’s try it out on the frontend:</p><div class="praise"><img id="calibre_link-1963" class="border5" src="images/000020.png" alt="images/src/otp/erlang-the-movie.png" width="720" height="430" /></div>
<p id="calibre_link-1964" class="calibre19">It works!</p>
<p id="calibre_link-1965" class="calibre19">
At this point, you can use this template to add services to our information system. Bing has an API that you might use to retrieve search results for linking. You could also build your own service. The important thing is that you have a framework to add services to.</p>
<p id="calibre_link-1966" class="calibre19">We’re at a convenient breaking point. It’s time to wrap up.








</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-265"><div id="calibre_link-1967" class="calibre2"><h2 id="calibre_link-150" class="calibre20">Wrapping Up</h2>
<p id="calibre_link-1968" class="calibre19">In this chapter dedicated to OTP services, we first took our time so you could build a solid understanding of how OTP uses concurrency and message passing to safely encapsulate state without implicit state, or instance or global variables. Then, we built an information system for our annotations. Along the way:</p><ul class="calibre28"><li class="calibre29">
<p id="calibre_link-1969" class="calibre31">We created a new child app under our umbrella.</p></li><li class="calibre29">
<p id="calibre_link-1970" class="calibre31">We built a counter that demonstrates how some OTP behaviours work.</p></li><li class="calibre29">
<p id="calibre_link-1971" class="calibre31">You looked at several OTP supervision and restart strategies.</p></li><li class="calibre29">
<p id="calibre_link-1972" class="calibre31">You saw examples of a full OTP service as <span class="cf1">GenServer</span>.</p></li><li class="calibre29">
<p id="calibre_link-1973" class="calibre31">You learned how tasks wrap behavior and agents encapsulate state.</p></li><li class="calibre29">
<p id="calibre_link-1974" class="calibre31">You implemented an ETS backed cache, with GenServer powered cache expiration.</p></li><li class="calibre29">
<p id="calibre_link-1975" class="calibre31">We implemented an information system abstract frontend with concrete backends.</p></li><li class="calibre29">
<p id="calibre_link-1976" class="calibre31">You learned to fetch WolframAlpha results from an HTTP service and share them with our channels.</p></li></ul>
<p id="calibre_link-1977" class="calibre19">In the next chapter, we’ll look at how to test your applications. You’ll see how to test channels and OTP, and also how our umbrella project will help us manage all of it. Don’t stop now&mdash;you’re almost done!</p>

<div class="footnotes">
<h4 class="calibre24">Footnotes</h4>
<dl class="calibre25">
<dt class="footnote-number"><a id="calibre_link-323" href="#calibre_link-266" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[32]</a></dt><dd class="calibre26">
<p id="calibre_link-1978" class="calibre27"><a href="https://hexdocs.pm/elixir/Supervisor.html#module-child_spec-1" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://hexdocs.pm/elixir/Supervisor.html#module-child_spec-1</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-193" href="#calibre_link-267" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[33]</a></dt><dd class="calibre26">
<p id="calibre_link-1979" class="calibre27"><a href="https://developer.wolframalpha.com/portal/signup.html" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://developer.wolframalpha.com/portal/signup.html</a></p></dd></dl></div>
<div class="copyright">Copyright © 2020, The Pragmatic Bookshelf.</div>




</div>



  </div>


<div class="calibre1" id="calibre_link-306"><div id="calibre_link-1980" class="calibre2"><h1 class="pcalibre6 chapter-title" id="calibre_link-45"><span class="chapter-number">
            Chapter
            13</span><br class="calibre18" /><span class="chapter-name">Testing Channels and OTP</span></h1>

<p id="calibre_link-1981" class="calibre19">The last few chapters were packed with new features. We’ve spent quite a bit of time and effort establishing new features that are interactive, compelling, and fast. Our information system uses an external API with flexible backends. Our channels-based API offers real-time web support for a rich user interface, one extremely sensitive to good server performance. Our channels allow peer-to-peer messaging. We’re missing only one thing. Tests.</p>
<p id="calibre_link-1982" class="calibre19">In this chapter, you’ll see how to test OTP processes in isolation. You’ll learn to use the Phoenix helpers to simplify channels testing. Before we dive in, let’s briefly talk about what you can expect.</p>
<p id="calibre_link-1983" class="calibre19">Recall that in Part I, the test cases for our controllers used Phoenix test helpers in <span class="cf">ConnCase</span>. We tested our HTTP-backed features, the router, controller, and views. Our integrated tests also hit the database. We used helpers such as <span class="cf">html_response</span> to remove some of the boilerplate from our typical tests.</p>
<p id="calibre_link-1984" class="calibre19">In Part II, our code stack is fundamentally different. The MVC code gave way to channels and OTP. Still, the basic approach will be the same. We’ll build tests that hit a single channel call, one that integrates everything down to the database.</p>
<p id="calibre_link-1985" class="calibre19">









We’ll draw the line at the external requests. Since we want to run our integration tests within our sphere of control, we’ll want our usual test stack to focus on everything we’ve built <span class="calibre4">except our external HTTP request to WolframAlpha</span>. We’ll want to isolate our tests from that piece of code.</p>
<p id="calibre_link-1986" class="calibre19">Let’s start our testing process with our information system.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-20"><div id="calibre_link-1987" class="calibre2"><h2 id="calibre_link-151" class="calibre20">Testing the Information System</h2>
<p id="calibre_link-1988" class="calibre19">

To warm up, we’re going to start our tests with our independent caching layer. Since our cache is made up of a standalone genserver, we can test it in isolation. It’s a good place to start because our cache can do two things: fetch and put.</p><h3 class="calibre22">Testing Our Cache</h3>
<p id="calibre_link-1989" class="calibre19">






For the most part, testing our cache will work like testing any other service. We’ll create a cache and try some fetches and puts. Then we’ll use asserts to check what actually happened against our expectations. Let’s begin with a few basic tests and then we can handle corner cases for timeouts and shutdown. Shift into the <span class="cf">apps/info_sys</span> directory and then make <span class="cf">tests/cache_test.exs</span> look like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_otp/listings/rumbl_umbrella/apps/info_sys/test/cache_test.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_otp/listings/rumbl_umbrella/apps/info_sys/test/cache_test.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ InfoSysTest.CacheTest ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ ExUnit.Case, ​<em class="string">async:</em>​ true</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  alias InfoSys.Cache</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  @moduletag ​<em class="string">clear_interval:</em>​ 100</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  setup %{​<em class="string">test:</em>​ name, ​<em class="string">clear_interval:</em>​ clear_interval} ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, pid} = Cache.start_link(​<em class="string">name:</em>​ name, ​<em class="string">clear_interval:</em>​ clear_interval)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, ​<em class="string">name:</em>​ name, ​<em class="string">pid:</em>​ pid}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1990" class="calibre19">




We’re creating a test, and including the usual ceremony. We have a module tag to specify the interval for clearing a cache. We’ll use that feature to customize the cache expiration during our tests.</p>
<p id="calibre_link-1991" class="calibre19">We also set up the tests by creating a simple GenServer by calling the <span class="cf">start_link</span> for our cache, passing in the shortened interval. Then we return the pid in the test context.</p>
<p id="calibre_link-1992" class="calibre19">
Now, we’re ready to run a couple of tests. One will check puts and fetches, and the other will check nonexistent keys:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_otp/listings/rumbl_umbrella/apps/info_sys/test/cache_test.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_otp/listings/rumbl_umbrella/apps/info_sys/test/cache_test.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  test ​<em class="string">"</em>​​<em class="string">key value pairs can be put and fetched from cache"</em>​, %{​<em class="string">name:</em>​ name} ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    assert ​<em class="string">:ok</em>​ = Cache.put(name, ​<em class="string">:key1</em>​, ​<em class="string">:value1</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    assert ​<em class="string">:ok</em>​ = Cache.put(name, ​<em class="string">:key2</em>​, ​<em class="string">:value2</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    assert Cache.fetch(name, ​<em class="string">:key1</em>​) == {​<em class="string">:ok</em>​, ​<em class="string">:value1</em>​}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    assert Cache.fetch(name, ​<em class="string">:key2</em>​) == {​<em class="string">:ok</em>​, ​<em class="string">:value2</em>​}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  test ​<em class="string">"</em>​​<em class="string">unfound entry returns error"</em>​, %{​<em class="string">name:</em>​ name} ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    assert Cache.fetch(name, ​<em class="string">:notexists</em>​) == ​<em class="string">:error</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1993" class="calibre19">The first test puts a couple of keys and verifies an <span class="cf">:ok</span> result, and then verifies both with fetches. The next test checks a simple fetch of a nonexistent key, and verifies an <span class="cf">:error</span>.</p>
<p id="calibre_link-1994" class="calibre19">If you’d like, you can run the test. You’ll find it clean and green:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">$ mix test test/cache_test.exs</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">.</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Finished in 0.02 seconds</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">1 test, 0 failures</td></tr></table>
<p id="calibre_link-1995" class="calibre19">


The tests are dead simple so far, but we should check out a couple of corner cases. We must make sure the GenServer shuts down cleanly and also make sure we handle error conditions like timeouts. We’re going to need a couple of test helper functions to assist us for each one. Above the test <span class="cf">setup</span> function, key this in:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_otp/listings/rumbl_umbrella/apps/info_sys/test/cache_test.change1.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_otp/listings/rumbl_umbrella/apps/info_sys/test/cache_test.change1.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defp</strong>​ assert_shutdown(pid) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ref = Process.monitor(pid)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Process.unlink(pid)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Process.​<strong class="kw">exit</strong>​(pid, ​<em class="string">:kill</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assert_receive {​<em class="string">:DOWN</em>​, ^ref, ​<em class="string">:process</em>​, ^pid, ​<em class="string">:killed</em>​}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defp</strong>​ eventually(func) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">if</strong>​ func.() ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    true</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">else</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    Process.sleep(10)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    eventually(func)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1996" class="calibre19">






That’s a bit more meaty. Let’s talk through those helpers. The first one will serve as a custom set of assertions to verify a server shuts down cleanly. We start a monitor and then unlink the process. We remove the link, otherwise killing the server would make our test process also crash. Next we kill the process and make sure we get a <span class="cf">:DOWN</span> message on the monitor. We break this code into its own function because we’ll use it twice in the tests that follow.</p>
<p id="calibre_link-1997" class="calibre19">The second helper is a small helper, to prevent tests from having to sleep for long periods while the test waits on an expected result. Ideally, we want to have our tests react only to messages. But when that’s not enough, we will execute some function until it eventually returns <span class="cf">true</span>. Let’s see how these two helpers work in the context of our tests. Add these tests to the bottom of <span class="cf">cache_test.exs</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_otp/listings/rumbl_umbrella/apps/info_sys/test/cache_test.change1.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_otp/listings/rumbl_umbrella/apps/info_sys/test/cache_test.change1.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">test ​<em class="string">"</em>​​<em class="string">clears all entries after clear interval"</em>​, %{​<em class="string">name:</em>​ name} ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assert ​<em class="string">:ok</em>​ = Cache.put(name, ​<em class="string">:key1</em>​, ​<em class="string">:value1</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assert Cache.fetch(name, ​<em class="string">:key1</em>​) == {​<em class="string">:ok</em>​, ​<em class="string">:value1</em>​}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assert eventually(​<strong class="kw">fn</strong>​ -&gt; Cache.fetch(name, ​<em class="string">:key1</em>​) == ​<em class="string">:error</em>​ ​<strong class="kw">end</strong>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">@tag ​<em class="string">clear_interval:</em>​ 60_000</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">test ​<em class="string">"</em>​​<em class="string">values are cleaned up on exit"</em>​, %{​<em class="string">name:</em>​ name, ​<em class="string">pid:</em>​ pid} ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assert ​<em class="string">:ok</em>​ = Cache.put(name, ​<em class="string">:key1</em>​, ​<em class="string">:value1</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assert_shutdown(pid)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {​<em class="string">:ok</em>​, _cache} = Cache.start_link(​<em class="string">name:</em>​ name)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assert Cache.fetch(name, ​<em class="string">:key1</em>​) == ​<em class="string">:error</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-1998" class="calibre19">
Nice! The first test puts a key into the cache and then uses the <span class="cf">eventually</span> function to check whether the values eventually clear. Recall that the <span class="cf">@moduletag</span> at the top of the test module sets the <span class="cf">clear_interval</span> to 100 milliseconds. After that waiting period, the cache should be cleared and our test will pass. If all is well, the test runs as quickly as it can. If not, ExUnit will time out the test after 60 seconds and we can fix the problem.</p>
<p id="calibre_link-1999" class="calibre19">
In the second test we verify that shutting down the cache actually erases all cached entries. To do so, we use <span class="cf">@tag</span> to set the <span class="cf">clear_interval</span> to a high value, overriding the value set in <span class="cf">@moduletag</span>. We do this to ensure <span class="cf">clear_interval</span> won’t interfere with our tests since we want to check that the shutdown of the cache erases all values, and not <span class="cf">clear_interval</span>. We do so by writing a key and shutting down the server. The test awaits for the <span class="cf">:DOWN</span> message, which is only delivered once the cache process exits. The test then checks to make sure the key is not present.</p>
<p id="calibre_link-2000" class="calibre19">You can see that testing GenServers is a bit trickier than testing pure functions, but it’s not too bad. Our InfoSys has a new set of challenges, though, since it’s pulling data from an external source. It’s time to attack that challenge.




</p><h3 class="calibre22">Testing the InfoSys</h3>
<p id="calibre_link-2001" class="calibre19">We’ll move on to perhaps our most significant testing challenge, the InfoSys. Since this information system interacts with an external interface, we have some decisions to make. We also have quite a bit of behavior to cover, such as timeouts and forced backend termination. You’ll be surprised at how quickly we can cover all this functionality with a few short and sweet test cases. Let’s get started.</p>
<p id="calibre_link-2002" class="calibre19">A natural first step for testing our <span class="cf">InfoSys</span> is to simply look for successful results. Create a new <span class="cf">rumbl_umbrella/apps/info_sys/test/info_sys_test.exs</span> with the following code:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_otp/listings/rumbl_umbrella/apps/info_sys/test/info_sys_test.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_otp/listings/rumbl_umbrella/apps/info_sys/test/info_sys_test.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ InfoSysTest ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ ExUnit.Case</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  alias InfoSys.Result</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">defmodule</strong>​ TestBackend ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">def</strong>​ name(), ​<strong class="kw">do</strong>​: ​<em class="string">"</em>​​<em class="string">Wolfram"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">def</strong>​ compute(​<em class="string">"</em>​​<em class="string">result"</em>​, _opts) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      [%Result{​<em class="string">backend:</em>​ __MODULE__, ​<em class="string">text:</em>​ ​<em class="string">"</em>​​<em class="string">result"</em>​}]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">def</strong>​ compute(​<em class="string">"</em>​​<em class="string">none"</em>​, _opts) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      []</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">def</strong>​ compute(​<em class="string">"</em>​​<em class="string">timeout"</em>​, _opts) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline">      Process.sleep(​<em class="string">:infinity</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">def</strong>​ compute(​<em class="string">"</em>​​<em class="string">boom"</em>​, _opts) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      ​<strong class="kw">raise</strong>​ ​<em class="string">"</em>​​<em class="string">boom!"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">20:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2003" class="calibre19">The top of the file has the typical module declaration and aliases. Then we move to our first problem, how to isolate our test code from the internet requests.</p>
<p id="calibre_link-2004" class="calibre19">
We solve this isolation problem by defining a stub called <span class="cf">TestBackend</span> on line 5. This module will act like our Wolfram backend, returning a response in the format that we expect. Since we don’t use the URL query string to do actual work, we can use this string to identify specific types of results we want our test backend to fetch:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_otp/listings/rumbl_umbrella/apps/info_sys/test/info_sys_test.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_otp/listings/rumbl_umbrella/apps/info_sys/test/info_sys_test.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">test ​<em class="string">"</em>​​<em class="string">compute/2 with backend results"</em>​ ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">2:&nbsp;</span></td><td class="codeline">  assert [%Result{​<em class="string">backend:</em>​ TestBackend, ​<em class="string">text:</em>​ ​<em class="string">"</em>​​<em class="string">result"</em>​}] =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">3:&nbsp;</span></td><td class="codeline">         InfoSys.compute(​<em class="string">"</em>​​<em class="string">result"</em>​, ​<em class="string">backends:</em>​ [TestBackend])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">4:&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">6:&nbsp;</span></td><td class="codeline">test ​<em class="string">"</em>​​<em class="string">compute/2 with no backend results"</em>​ ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">7:&nbsp;</span></td><td class="codeline">  assert [] = InfoSys.compute(​<em class="string">"</em>​​<em class="string">none"</em>​, ​<em class="string">backends:</em>​ [TestBackend])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">8:&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2005" class="calibre19">With our stub in place, the tests will be remarkably simple. We define a test case for computing successful results. We pass a query string of <span class="cf">"result"</span>, signaling our backend to send fake results. Then we assert that the result set is what we expect. Next, we use the same approach to handle empty datasets.</p>
<p id="calibre_link-2006" class="calibre19">That takes care of the cases in which backends properly report results. Next, we need to cover the edge cases, like backend timeouts.</p><div class="xxxsays"><div class="heading"><div class="persons-picture"><img src="images/000048.png" alt="Chris says:" class="calibre40" /></div><div class="label">Chris says:</div><div class="title">What’s the Difference Between a Stub and a Mock?</div></div><div class="praise">
<p id="calibre_link-2007" class="calibre14">


Stubs and mocks are both testing fixtures that replace real-world implementations. A <span class="calibre4">stub</span> replaces real-world libraries with simpler, predictable behavior. With a stub, a programmer can bypass code that would otherwise be difficult to test. Other than that, the stub has nothing to say about whether a test passes or fails. For example, a <span class="cf">http_send</span> stub might always return a fixed JSON response. In other words, a stub is just a simple scaffold implementation standing in for a more complex real-world implementation.
</p>
<p id="calibre_link-2008" class="calibre14">
A <span class="calibre4">mock</span> is similar, but it has a greater role. It replaces real-world behavior just as a stub does, but it does so by allowing a programmer to specify expectations and results, playing back those results at runtime. A mock will fail a test if the test code doesn’t receive the expected function calls. For example, a programmer might create a mock for <span class="cf">http_send</span> that expects the <span class="cf">test</span> argument, returning the value <span class="cf">:ok</span>, followed by the <span class="cf">test2</span> argument, returning <span class="cf">:ok</span>. If the test code doesn’t call the mock first with the value <span class="cf">test</span> and next with the value <span class="cf">test2</span>, it’ll fail. In other words, a mock is an implementation that records expected behavior at definition time and plays it back at runtime, enforcing those expectations.
</p></div></div><h3 class="calibre22">Incorporating Timeouts in Our Tests</h3>
<p id="calibre_link-2009" class="calibre19">


A backend might time out. To test timeouts, we need a way to simulate a backend taking longer than expected. We also need to be able to make sure that the information system terminates the backend in such cases, as we expect it to. We want to do all of this in a fast test. Fortunately, with our testing structure, it’s a simple job:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_otp/listings/rumbl_umbrella/apps/info_sys/test/info_sys_test.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_otp/listings/rumbl_umbrella/apps/info_sys/test/info_sys_test.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">  test ​<em class="string">"</em>​​<em class="string">compute/2 with timeout returns no results"</em>​ ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">2:&nbsp;</span></td><td class="codeline">    results = InfoSys.compute(​<em class="string">"</em>​​<em class="string">timeout"</em>​, ​<em class="string">backends:</em>​ [TestBackend], ​<em class="string">timeout:</em>​ 10)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">3:&nbsp;</span></td><td class="codeline">    assert results == []</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">4:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2010" class="calibre19">

We want our test to be fast, so we shorten the timeout interval to 10 milliseconds. We simply call the correct stub and it sleeps forever. We assert that we get an empty result. Mission accomplished.</p>
<p id="calibre_link-2011" class="calibre19">Now we can shift to our last corner case. We need to check exceptions. It’s a relatively easy job but we’ll need one tiny trick. To keep our tests from printing out a bunch of noisy log messages when the exception fires we need to capture the log. With that in mind, key this last test in:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_otp/listings/rumbl_umbrella/apps/info_sys/test/info_sys_test.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_otp/listings/rumbl_umbrella/apps/info_sys/test/info_sys_test.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">@tag ​<em class="string">:capture_log</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">test ​<em class="string">"</em>​​<em class="string">compute/2 discards backend errors"</em>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assert InfoSys.compute(​<em class="string">"</em>​​<em class="string">boom"</em>​, ​<em class="string">backends:</em>​ [TestBackend]) == []</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2012" class="calibre19">The test is short and, um, suite. We capture the log in a test tag. Then we assert that no results are returned. Believe it or not, that’s all the testing we need to do at this level. We are ready to fire our test up:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">$ mix test test/info_sys_test.exs</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">....</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Finished in 0.06 seconds</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">4 tests, 0 failures</td></tr></table>
<p id="calibre_link-2013" class="calibre19">Nice. It all works perfectly. Our new tests are nice and tidy, just like we want them. We’ve done pretty well with our generic information system, but there’s still some supporting Wolfram code that we’d like to test. Since that code has an external interface, it’s better to test that part in isolation.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-178"><div id="calibre_link-2014" class="calibre2"><h2 id="calibre_link-152" class="calibre20">Isolating Wolfram</h2>
<p id="calibre_link-2015" class="calibre19">







We’d like to keep our Wolfram tests isolated, but we have a problem. Our code makes an HTTP request to the WolframAlpha API, which isn’t something we want to perform within our test suite. You might be thinking, “Let’s write a bunch of mocks!”</p>
<p id="calibre_link-2016" class="calibre19">
Within the Elixir community, we want to avoid mocking whenever possible. Most mocking libraries, including dynamic stubbing libraries, end up changing global behavior&mdash;for example, by replacing a function in the HTTP client library to return some particular result. <span class="calibre4">These function replacements are global</span>, so a change in one place would change all code running at the same time. That means <span class="calibre4">tests written in this way can no longer run concurrently</span>. These kinds of strategies can snowball, requiring more and more mocking until the dependencies among components are completely hidden.</p>
<p id="calibre_link-2017" class="calibre19">




The better strategy is to identify code that’s difficult to test live, and to build a configurable, replaceable testing implementation rather than a dynamic mock. We’ll make our HTTP service pluggable. Our development and production code will use our simple <span class="cf">:httpc</span> client, and our testing code can instead use a stub that we’ll call as part of our tests.  Let’s update our Wolfram backend to accept an HTTP client from the application configuration, or a default of <span class="cf">:httpc</span>. Update <span class="cf">rumbl_umbrella/apps/info_sys/lib/info_sys/wolfram.ex</span> with this code:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys/wolfram.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_otp/listings/rumbl_umbrella/apps/info_sys/lib/info_sys/wolfram.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">@http Application.get_env(​<em class="string">:info_sys</em>​, ​<em class="string">:wolfram</em>​)[​<em class="string">:http_client</em>​] || ​<em class="string">:httpc</em>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">2:&nbsp;</span></td><td class="codeline">​<strong class="kw">defp</strong>​ fetch_xml(query) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">3:&nbsp;</span></td><td class="codeline">  {​<em class="string">:ok</em>​, {_, _, body}} = @http.request(String.to_charlist(url(query)))</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">4:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">  body</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">6:&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2018" class="calibre19">

We have made only a minor change to this file. First, we look up an <span class="cf">:http_client</span> module from our mix configuration and default it to the <span class="cf">:httpc</span> module. We bake that module into an <span class="cf">@http</span> module attribute at compile time for speedy runtime use. Next, we replace our <span class="cf">:httpc.request</span> call with an <span class="cf">@http.request</span> invocation.</p>
<p id="calibre_link-2019" class="calibre19">The result is simple and elegant. We simply call the function as before, using our environment’s HTTP client instead of hardcoding the HTTP client. This way, our behavior remains unchanged from before, but we can now stub our HTTP client as desired.</p>
<p id="calibre_link-2020" class="calibre19">Now let’s update our test configuration to use our stubbed client. Update the <span class="cf">config/test.exs</span> file at the umbrella root, like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_otp/listings/rumbl_umbrella/config/test.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_otp/listings/rumbl_umbrella/config/test.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">config ​<em class="string">:info_sys</em>​, ​<em class="string">:wolfram</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="string">app_id:</em>​ ​<em class="string">"</em>​​<em class="string">1234"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="string">http_client:</em>​ InfoSys.Test.HTTPClient</td></tr></table>
<p id="calibre_link-2021" class="calibre19">This bit of configuration sets two configuration keys for Wolfram. One key is the as-yet unwritten module for our test backend. The other is a fake configuration key that we can replace if we need to do some direct testing&mdash;for example, as we’re creating data for our stub.</p>
<p id="calibre_link-2022" class="calibre19">



Now on to the tests. To test our stubbed WolframAlpha API results, we need an example XML payload. Wolfram conveniently includes an API explorer<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-8" href="#calibre_link-179">[34]</a></sup> that accepts a search query and displays the XML response. We’ve grabbed a result for you for a query of <span class="cf">"1 + 1"</span>. Keep in mind that this file is incomplete. You will need to use the Wolfram service to build your own or copy our version from the sample code for our book. Either way, place the entire XML response into a new <span class="cf">rumbl_umbrella/apps/info_sys/test/fixtures/</span> directory and save it as <span class="cf">wolfram.xml</span>:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment">&lt;?xml version='1.0' encoding='UTF-8'?&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">&lt;queryresult success=​<em class="string">'true'</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    error=​<em class="string">'false'</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    numpods=​<em class="string">'6'</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">...</strong>​</td></tr></table>
<p id="calibre_link-2023" class="calibre19">With our fixture in place, now we need a stubbed HTTP client, one that returns fake XML results using our fixture. Create a new <span class="cf">rumbl_umbrella/apps/info_sys/test/backends/</span> directory and add the following module to a new <span class="cf">rumbl_umbrella/apps/info_sys/</span><span class="cf">test/backends/http_client.exs</span> file:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_otp/listings/rumbl_umbrella/apps/info_sys/test/backends/http_client.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_otp/listings/rumbl_umbrella/apps/info_sys/test/backends/http_client.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ InfoSys.Test.HTTPClient ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  @wolfram_xml File.read!(​<em class="string">"</em>​​<em class="string">test/fixtures/wolfram.xml"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ request(url) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    url = to_string(url)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">cond</strong>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      String.contains?(url, ​<em class="string">"</em>​​<em class="string">1+%2B+1"</em>​) -&gt; {​<em class="string">:ok</em>​, {[], [], @wolfram_xml}}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      true -&gt; {​<em class="string">:ok</em>​, {[], [], ​<em class="string">"</em>​​<em class="string">&lt;queryresult&gt;&lt;/queryresult&gt;"</em>​}}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2024" class="calibre19">
We define an <span class="cf">InfoSys.Test.HTTPClient</span> module that stubs our <span class="cf">request</span> function and returns fake Wolfram results. We cheat as we did before. We check the fetched <span class="cf">url</span> for the URI-encoded <span class="cf">"1 + 1"</span> string. If it matches, we simply return the XML contents of our <span class="cf">wolfram.xml</span> fixture. For any other case, we return a fake request for empty XML results.</p>
<p id="calibre_link-2025" class="calibre19">


Our goal isn’t to test the Wolfram service, but make sure we can parse the data Wolfram provides. This code elegantly lets us write tests at any time that return a result. To confirm our <span class="cf">HTTPClient</span> module is loaded before our tests, add the following line to the top of your <span class="cf">rumbl_umbrella/apps/info_sys/test/test_helper.exs</span>:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_otp/listings/rumbl_umbrella/apps/info_sys/test/test_helper.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_otp/listings/rumbl_umbrella/apps/info_sys/test/test_helper.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Code.require_file ​<em class="string">"</em>​​<em class="string">../../info_sys/test/backends/http_client.exs"</em>​, __DIR__</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">ExUnit.start()</td></tr></table>
<p id="calibre_link-2026" class="calibre19">With our HTTP client in place, create a new <span class="cf">rumbl_umbrella/apps/info_sys/test/backends/wolfram_test.exs</span> file with the following contents:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_otp/listings/rumbl_umbrella/apps/info_sys/test/backends/wolfram_test.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_otp/listings/rumbl_umbrella/apps/info_sys/test/backends/wolfram_test.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ InfoSys.Backends.WolframTest ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ ExUnit.Case, ​<em class="string">async:</em>​ true</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  test ​<em class="string">"</em>​​<em class="string">makes request, reports results, then terminates"</em>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    actual = hd InfoSys.compute(​<em class="string">"</em>​​<em class="string">1 + 1"</em>​, [])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    assert actual.text == ​<em class="string">"</em>​​<em class="string">2"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  test ​<em class="string">"</em>​​<em class="string">no query results reports an empty list"</em>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    assert InfoSys.compute(​<em class="string">"</em>​​<em class="string">none"</em>​, [])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2027" class="calibre19">Since we’ve put in the hard work for testing the cache and generic <span class="cf">InfoSys</span> this test will be light, and that’s exactly how we want tests that must consider external interfaces. Using our stubbed HTTP client, we add test cases to handle requests with and without results.</p>
<p id="calibre_link-2028" class="calibre19">Now let’s run the test:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">..</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Finished in 0.2 seconds (0.1s on load, 0.09s on tests)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">5 tests, 0 failures</td></tr></table>
<p id="calibre_link-2029" class="calibre19">And they pass. Since we’re handling the rest of the edge cases in our base info_sys tests, that should wrap up the Wolfram tests!</p><div class="xxxsays"><div class="heading"><div class="persons-picture"><img src="images/000024.png" alt="José says:" class="calibre41" /></div><div class="label">José says:</div><div class="title">At What Level Should We Apply Our Stubs/Mocks?</div></div><div class="praise">
<p id="calibre_link-2030" class="calibre14">


For the WolframAlpha API case, we chose to create a stub that replaces the <span class="cf">:httpc</span> module. However, you might not be comfortable with skipping the whole HTTP stack during the test. You’ll have to decide the best place to stub the HTTP layer. No single strategy works for every case. It depends on your team’s confidence and the code being tested. For example, if the communication with the endpoint requires passing headers and handling different responses, you might want to make sure that all of those parameters are sent correctly.
</p>
<p id="calibre_link-2031" class="calibre14">


One possible solution is the Bypass<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-9" href="#calibre_link-180">[35]</a></sup> project. Bypass allows us to create a mock HTTP server that our code can access during tests without resorting to dynamic mocking techniques that introduce global changes and complicate the testing stack.
</p></div></div>
<p id="calibre_link-2032" class="calibre19">Our tests are all green, and they’ll be consistently green because we make sure that our measurements await the completion of our tests.</p>
<p id="calibre_link-2033" class="calibre19">You may have noticed that these tests are more involved than the typical single-process tests you might be used to. But by using the specific helpers that <span class="cf">ExUnit</span> provides and thinking through possible outcomes and orderings, you’ll quickly get the hang of writing tests that aren’t too much more difficult than synchronous ones. When you’re done, you’ll have one major advantage. Your tests will run concurrently, meaning they’ll finish much more quickly than their synchronous counterparts.

</p>
<p id="calibre_link-2034" class="calibre19">With our Wolfram backend covered, it’s time to move on to the last part of our application: the channels. We’re ready to use the testing tools from <span class="cf">Phoenix.ChannelTest</span> to set up your tests and finish out the rest of our tests.









</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-230"><div id="calibre_link-2035" class="calibre2"><h2 id="calibre_link-153" class="calibre20">Adding Tests to Channels</h2>
<p id="calibre_link-2036" class="calibre19">



We started this chapter by testing our information system, including unit-testing our supporting code for the Wolfram backend. Now it’s time to test our channels code. Remember that underneath, channels are also OTP servers. Phoenix includes the <span class="cf">Phoenix.ChannelTest</span> module, which will simplify your testing experience. With it, you can make several types of common assertions. For example, you can assert that your application pushes messages to a client, replies to a message, or sends broadcasts. Let’s look at some code.</p>
<p id="calibre_link-2037" class="calibre19">
The <span class="cf">rumbl_umbrella/apps/rumbl_web/test/support/channel_case.ex</span> is a file that was generated by Mix when we generated the <span class="cf">rumbl</span> application. You’ve already seen a couple of similar test cases with <span class="cf">data_case</span> and <span class="cf">conn_case</span> in  Chapter 8, <a href="#calibre_link-114" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">​<em class="calibre4">Testing MVC</em>​</a>.</p>
<p id="calibre_link-2038" class="calibre19">Let’s take a deeper look at how those files work. Crack it open now:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_otp/rumbl_umbrella/apps/rumbl_web/test/support/channel_case.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_otp/rumbl_umbrella/apps/rumbl_web/test/support/channel_case.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ RumblWeb.ChannelCase ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  @moduledoc ​<em class="string">"""</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">  This module defines the test case to be used by</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">  channel tests.</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">  Such tests rely on `Phoenix.ChannelTest` and also</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">  import other functionality to make it easier</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">  to build common data structures and query the data layer.</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">  Finally, if the test case interacts with the database,</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">  it cannot be async. For this reason, every test runs</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">  inside a transaction which is reset at the beginning</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">  of the test unless the test case is marked as async.</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">  """</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ ExUnit.CaseTemplate</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  using ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">quote</strong>​ ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<em class="comment"># Import conveniences for testing with channels</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<strong class="kw">use</strong>​ Phoenix.ChannelTest</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<em class="comment"># The default endpoint for testing</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      @endpoint RumblWeb.Endpoint</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr></table><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  setup tags ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">:ok</em>​ = Ecto.Adapters.SQL.Sandbox.checkout(Rumbl.Repo)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">unless</strong>​ tags[​<em class="string">:async</em>​] ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      Ecto.Adapters.SQL.Sandbox.mode(Rumbl.Repo, {​<em class="string">:shared</em>​, self()})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">:ok</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2039" class="calibre19">




Knowing what’s happening here in basic broad strokes is enough. First you see <span class="cf">use ExUnit.CaseTemplate</span>, which establishes this file as a test case. Next is a <span class="cf">using</span> block to start an inline macro, and a <span class="cf">quote</span> to specify the template for the code that we want to inject. The <span class="cf">use Phoenix.ChannelTest</span> statement establishes <span class="cf">Phoenix.ChannelTest</span> as the foundation for our test file. Then, we do a few imports and aliases for convenience, and so on.</p>
<p id="calibre_link-2040" class="calibre19">
The result is a file that prepares your tests for the features you’re most likely to use in your channel tests. Our application has just one channel: the <span class="cf">VideoChannel</span>, which supports features like real-time annotations and integration with our <span class="cf">InfoSys</span> layer. All of our tests go through a single endpoint.</p>
<p id="calibre_link-2041" class="calibre19">Before we test the <span class="cf">VideoChannel</span>, let’s start where the channel process begins by testing the <span class="cf">UserSocket</span> module.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-253"><div id="calibre_link-2042" class="calibre2"><h2 id="calibre_link-154" class="calibre20">Authenticating a Test Socket</h2>
<p id="calibre_link-2043" class="calibre19">



Most of our channels code relies on an authenticated user. We’ll start our tests with the socket authentication. Let’s do that now.</p>
<p id="calibre_link-2044" class="calibre19">Create a <span class="cf">rumbl_umbrella/apps/rumbl_web/test/channels/user_socket_test.exs</span> file containing:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_otp/listings/rumbl_umbrella/apps/rumbl_web/test/rumbl_web/channels/user_socket_test.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_otp/listings/rumbl_umbrella/apps/rumbl_web/test/rumbl_web/channels/user_socket_test.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ RumblWeb.Channels.UserSocketTest ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ RumblWeb.ChannelCase, ​<em class="string">async:</em>​ true</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  alias RumblWeb.UserSocket</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">  test ​<em class="string">"</em>​​<em class="string">socket authentication with valid token"</em>​ ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    token = Phoenix.Token.sign(@endpoint, ​<em class="string">"</em>​​<em class="string">user socket"</em>​, ​<em class="string">"</em>​​<em class="string">123"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    assert {​<em class="string">:ok</em>​, socket} = connect(UserSocket, %{​<em class="string">"</em>​​<em class="string">token"</em>​ =&gt; token}) </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    assert socket.assigns.user_id == ​<em class="string">"</em>​​<em class="string">123"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  test ​<em class="string">"</em>​​<em class="string">socket authentication with invalid token"</em>​ ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    assert ​<em class="string">:error</em>​ = connect(UserSocket, %{​<em class="string">"</em>​​<em class="string">token"</em>​ =&gt; ​<em class="string">"</em>​​<em class="string">1313"</em>​})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    assert ​<em class="string">:error</em>​ = connect(UserSocket, %{})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2045" class="calibre19">




On line 5, we make sure that a user with a valid token can open a new socket connection. The test is pretty simple. We generate a valid token, use the <span class="cf">connect</span> helper to simulate a <span class="cf">UserSocket</span> connection, and ensure that the connection succeeds. That’s not enough. We also make sure that the socket’s <span class="cf">user_id</span> is placed into the socket. With the happy path tested, we can move on to the negative condition.</p>
<p id="calibre_link-2046" class="calibre19">


On line 12, we test the opposite case. We first try to log in with a nonexistent token. Next, we test a simple edge condition, attempting to connect with no token at all. Since these tests don’t require side effects such as database calls, they can run independently and concurrently. In the <span class="cf">use</span> line, we set <span class="cf">:async</span> to <span class="cf">true</span>, and we can feel a little happier inside. Our tiny test saves milliseconds, but when we aggregate thousands of tests, we’ll be saving full minutes or more. These tiny savings can add up to hours every day.</p>
<p id="calibre_link-2047" class="calibre19">We can see the finish line. It’s finally time to test our video channel.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-290"><div id="calibre_link-2048" class="calibre2"><h2 id="calibre_link-155" class="calibre20">Communicating with a Test Channel</h2>
<p id="calibre_link-2049" class="calibre19">


Let’s see how easy it is to test our <span class="cf">VideoChannel</span> features. Our plan is simple. We’re going to set up some data to share across our tests and then sign the user in within our setup block. Then, we can write some independent tests against that live connection.</p>
<p id="calibre_link-2050" class="calibre19">First we’ll need a few helper functions to make it easier to create users and videos. Make the file <span class="cf">test/support/test_helpers.ex</span> look like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_otp/listings/rumbl_umbrella/apps/rumbl_web/test/support/test_helpers.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_otp/listings/rumbl_umbrella/apps/rumbl_web/test/support/test_helpers.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ RumblWeb.TestHelpers ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">defp</strong>​ default_user() ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    %{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<em class="string">name:</em>​ ​<em class="string">"</em>​​<em class="string">Some User"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<em class="string">username:</em>​ ​<em class="string">"</em>​​<em class="string">user</em>​​<em class="string">#{</em>​System.unique_integer([​<em class="string">:positive</em>​])​<em class="string">}</em>​​<em class="string">"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<em class="string">password:</em>​ ​<em class="string">"</em>​​<em class="string">supersecret"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ insert_user(attrs \\ %{}) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, user} =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      attrs</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      |&gt; Enum.into(default_user())</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      |&gt; Rumbl.Accounts.register_user</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    user</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2051" class="calibre19">The first part creates users. For convenience, we start with a default user and then merge in keywords so a user can specify as many or few users as they want. The context work we did earlier makes this easy.
Next, we need to do the same for videos.</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_otp/listings/rumbl_umbrella/apps/rumbl_web/test/support/test_helpers.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_otp/listings/rumbl_umbrella/apps/rumbl_web/test/support/test_helpers.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defp</strong>​ default_video() ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  %{</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">url:</em>​ ​<em class="string">"</em>​​<em class="string">test@example.com"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">description:</em>​ ​<em class="string">"</em>​​<em class="string">a video"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">body:</em>​ ​<em class="string">"</em>​​<em class="string">body"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ insert_video(user, attrs \\ %{}) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  video_fields = Enum.into(attrs, default_video())</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {​<em class="string">:ok</em>​, video} = Rumbl.Multimedia.create_video(user, video_fields)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  video</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2052" class="calibre19">


Easy enough. We do the same thing. We start by creating a default video, then merge in defaults, create a video, pattern match it out and finally return the video to the user. Now all that remains is a quick helper to log a user in:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_otp/listings/rumbl_umbrella/apps/rumbl_web/test/support/test_helpers.ex" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_otp/listings/rumbl_umbrella/apps/rumbl_web/test/support/test_helpers.ex</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ login(%{​<em class="string">conn:</em>​ conn, ​<em class="string">login_as:</em>​ username}) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    user = insert_user(​<em class="string">username:</em>​ username)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {Plug.Conn.assign(conn, ​<em class="string">:current_user</em>​, user), user}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ login(%{​<em class="string">conn:</em>​ conn}), ​<strong class="kw">do</strong>​: {conn, ​<em class="string">:logged_out</em>​}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2053" class="calibre19">We insert a user and then merge the user into the <span class="cf">conn</span>. If there’s no user, we just log the user out. Now we can put these functions to use.</p>
<p id="calibre_link-2054" class="calibre19">Create a new <span class="cf">rumbl_umbrella/apps/rumbl_web/test/channels/video_channel_test.exs</span> file that looks like this:</p><div class="livecodelozenge"><a href="http://media.pragprog.com/titles/phoenix14/code/testing_otp/listings/rumbl_umbrella/apps/rumbl_web/test/rumbl_web/channels/video_channel_test.exs" class="pcalibre pcalibre7 pcalibre1 calibre39 pcalibre2">testing_otp/listings/rumbl_umbrella/apps/rumbl_web/test/rumbl_web/channels/video_channel_test.exs</a></div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ RumblWeb.Channels.VideoChannelTest ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ RumblWeb.ChannelCase</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">import</strong>​ RumblWeb.TestHelpers</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">  setup ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    user = insert_user(​<em class="string">name:</em>​ ​<em class="string">"</em>​​<em class="string">Gary"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    video = insert_video(user, ​<em class="string">title:</em>​ ​<em class="string">"</em>​​<em class="string">Testing"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    token = Phoenix.Token.sign(@endpoint, ​<em class="string">"</em>​​<em class="string">user socket"</em>​, user.id)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, socket} = connect(RumblWeb.UserSocket, %{​<em class="string">"</em>​​<em class="string">token"</em>​ =&gt; token})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, ​<em class="string">socket:</em>​ socket, ​<em class="string">user:</em>​ user, ​<em class="string">video:</em>​ video}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  test ​<em class="string">"</em>​​<em class="string">join replies with video annotations"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline">       %{​<em class="string">socket:</em>​ socket, ​<em class="string">video:</em>​ vid, ​<em class="string">user:</em>​ user} ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    for body &lt;- ​<strong class="kw">~</strong>​w(one two) ​<strong class="kw">do</strong>​ </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      Rumbl.Multimedia.annotate_video(user, vid.id, %{​<em class="string">body:</em>​ body, ​<em class="string">at:</em>​ 0})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, reply, socket} = subscribe_and_join(socket, ​<em class="string">"</em>​​<em class="string">videos:</em>​​<em class="string">#{</em>​vid.id​<em class="string">}</em>​​<em class="string">"</em>​, %{})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">20:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    assert socket.assigns.video_id == vid.id</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    assert %{​<em class="string">annotations:</em>​ [%{​<em class="string">body:</em>​ ​<em class="string">"</em>​​<em class="string">one"</em>​}, %{​<em class="string">body:</em>​ ​<em class="string">"</em>​​<em class="string">two"</em>​}]} = reply</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2055" class="calibre19">
On line 5, we add a <span class="cf">setup</span> block to prepare our tests with a user and video. Next, we use <span class="cf">connect</span> to start a simulated socket connection. We can use that connection for each of our tests. We put the <span class="cf">user</span>, the <span class="cf">video</span>, and the connected <span class="cf">socket</span> into our test context, one that we’ll be able to match for individual tests.</p>
<p id="calibre_link-2056" class="calibre19">





Note we haven’t passed the <span class="cf">async: true</span> flag to the <span class="cf">ChannelCase</span> as we did to other cases. Here’s why. In Ecto’s <span class="cf">Sandbox</span> mode, every process has its own connection. That’s not a problem in applications that limit database access to a single process. The test case starts a transaction, modifies the database, asserts results and then rolls back the transaction when the test completes.</p>
<p id="calibre_link-2057" class="calibre19"><span class="calibre4">This</span> application is different. It has two or more processes talking to the database at the same time, in the same test. Because processes might need to acces <span class="calibre4">the same data</span>, the only way for them to share data in the sandbox mode is to share the same connection. To maintain isolation for each test, we can’t run tests concurrently. That means we can’t set <span class="cf">async</span>. It’s not ideal, but since the rest of the tests run in <span class="cf">async</span> mode, we won’t fret too much.</p>
<p id="calibre_link-2058" class="calibre19">




In the test, the function head matches the connected <span class="cf">socket</span> and <span class="cf">video</span>, so our test can take advantage of the setup work we’ve done. We then proceed to create two annotations that we expect to be sent as a reply on <span class="cf">join</span>. We call the <span class="cf">subscribe_and_join</span> test helper to attempt to join the channel responsible for the <span class="cf">"videos:#{vid.id}"</span> topic. If the join is successful, this helper function returns <span class="cf">{:ok, reply, socket}</span>. An unsuccessful join fails the match and forces an error for our test. Then we assert the socket has a <span class="cf">user_id</span> assigned and the <span class="cf">join</span> reply contains the previously creatrd annotations.</p>
<p id="calibre_link-2059" class="calibre19">Let’s try this much:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">$ </span>​​<strong class="kw">mix</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test</strong>​​<strong class="kw"> </strong>​​<strong class="kw">test/rumbl_web/channels/video_channel_test.exs</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...</span>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Finished in 0.2 seconds (0.1s on load, 0.09s on tests)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">3 tests, 0 failures</td></tr></table>
<p id="calibre_link-2060" class="calibre19">No problem! Our tests pass, and we know the following:</p><ul class="calibre28"><li class="calibre29">Our user can successfully connect.</li><li class="calibre29">Our user successfully joined a topic.</li><li class="calibre29">The topic is the correct one.</li><li class="calibre29">The reply has all of the annotations in the video.</li></ul>
<p id="calibre_link-2061" class="calibre19">That’s a good start. Now that we’ve tested that we can join the <span class="cf">VideoChannel</span>, we can test a conversation with the client. Let’s test the incoming <span class="cf">new_annotation</span> event. We want to simulate the creation of a new annotation, and we want to make sure we correctly augment the state in the socket.</p>
<p id="calibre_link-2062" class="calibre19">Code the new test in <span class="cf">rumbl_umbrella/apps/rumbl_web/test/channels/video_channel_test.exs</span>, like this:</p><div class="livecodelozenge">testing_otp/listings/rumbl_umbrella/apps/rumbl_ … umbl_web/channels/video_channel_test.change1.exs</div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">test ​<em class="string">"</em>​​<em class="string">inserting new annotations"</em>​, %{​<em class="string">socket:</em>​ socket, ​<em class="string">video:</em>​ vid} ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {​<em class="string">:ok</em>​, _, socket} = subscribe_and_join(socket, ​<em class="string">"</em>​​<em class="string">videos:</em>​​<em class="string">#{</em>​vid.id​<em class="string">}</em>​​<em class="string">"</em>​, %{})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ref = push socket, ​<em class="string">"</em>​​<em class="string">new_annotation"</em>​, %{​<em class="string">body:</em>​ ​<em class="string">"</em>​​<em class="string">the body"</em>​, ​<em class="string">at:</em>​ 0}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assert_reply ref, ​<em class="string">:ok</em>​, %{}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assert_broadcast ​<em class="string">"</em>​​<em class="string">new_annotation"</em>​, %{}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2063" class="calibre19">

As before, our function head matches the <span class="cf">video</span> and <span class="cf">socket</span> we created in <span class="cf">setup</span>. Like last time, we subscribe and join with our helper. This time, we use the <span class="cf">push</span> helper function to push a new event to the channel. We use <span class="cf">assert_reply</span> to make sure we get a <span class="cf">:ok</span> response. We could also pass in additional key/value pairs to assert on specific parts of the reply, but we don’t need to do so in this case, so we pass an empty map.</p>
<p id="calibre_link-2064" class="calibre19">



Finally, we use the <span class="cf">assert_broadcast</span> function to make sure that our annotation were broadcast to subscribers. The <span class="cf">assert_reply</span> and <span class="cf">assert_broadcast</span> functions are provided by Phoenix and built on top of the <span class="cf">assert_receive</span> function that we used in the previous section.</p>
<p id="calibre_link-2065" class="calibre19">
Notice how our test process works as a client of the channel, because we were able to establish a test connection using <span class="cf">subscribe_and_join</span>. In the same way, the browser is a channel client. That’s why we can assert that we’ve received some particular reply. The test process also subscribes to the same topic as its channel, explaining why we can assert that something was broadcast.</p>
<p id="calibre_link-2066" class="calibre19">Let’s test the integration with our information system. Crack your test open once again, and add this test to the end:</p><div class="livecodelozenge">testing_otp/listings/rumbl_umbrella/apps/rumbl_ … umbl_web/channels/video_channel_test.change1.exs</div><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">test ​<em class="string">"</em>​​<em class="string">new annotations triggers InfoSys"</em>​, %{​<em class="string">socket:</em>​ socket, ​<em class="string">video:</em>​ vid} ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  insert_user(</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">username:</em>​ ​<em class="string">"</em>​​<em class="string">wolfram"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">password:</em>​ ​<em class="string">"</em>​​<em class="string">supersecret"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  )</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {​<em class="string">:ok</em>​, _, socket} = subscribe_and_join(socket, ​<em class="string">"</em>​​<em class="string">videos:</em>​​<em class="string">#{</em>​vid.id​<em class="string">}</em>​​<em class="string">"</em>​, %{})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ref = push socket, ​<em class="string">"</em>​​<em class="string">new_annotation"</em>​, %{​<em class="string">body:</em>​ ​<em class="string">"</em>​​<em class="string">1 + 1"</em>​, ​<em class="string">at:</em>​ 123}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assert_reply ref, ​<em class="string">:ok</em>​, %{}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assert_broadcast ​<em class="string">"</em>​​<em class="string">new_annotation"</em>​, %{​<em class="string">body:</em>​ ​<em class="string">"</em>​​<em class="string">1 + 1"</em>​, ​<em class="string">at:</em>​ 123}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assert_broadcast ​<em class="string">"</em>​​<em class="string">new_annotation"</em>​, %{​<em class="string">body:</em>​ ​<em class="string">"</em>​​<em class="string">2"</em>​, ​<em class="string">at:</em>​ 123}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2067" class="calibre19">
We first need to insert the Wolfram user into the database because our <span class="cf">compute_</span><span class="cf">additional_info</span> needs to have a user named <span class="cf">wolfram</span> to post the additional info.</p>
<p id="calibre_link-2068" class="calibre19">Then our function head picks off the things our test needs, just as we did in the previous test. We subscribe and join, push a new annotation, and check the response. This time, use the special stubbed <span class="cf">"1 + 1"</span> query to return fake answers. We verify that the original response and the <span class="cf">InfoSys</span> annotation are both broadcast successfully.</p>
<p id="calibre_link-2069" class="calibre19">Let’s switch to the top-level directory and try our tests.</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">$ ➔ cd ../..</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">$ mix test</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">==&gt; rumbl_web</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Compiling 1 file (.ex)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">==&gt; info_sys</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">..........</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Finished in 0.2 seconds</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">10 tests, 0 failures</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Randomized with seed 292879</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">==&gt; rumbl</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">.................</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Finished in 0.1 seconds</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">17 tests, 0 failures</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Randomized with seed 292879</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">==&gt; rumbl_web</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">........................</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Finished in 0.1 seconds</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">24 tests, 0 failures</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">Randomized with seed 292879</td></tr></table>
<p id="calibre_link-2070" class="calibre19">Everything passes!</p>
<p id="calibre_link-2071" class="calibre19">As you can see, Phoenix provides plenty of support for testing your channels code. These testing features are first-class features for our ecosystem. It’s a good time to see how far we’ve come.
















</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-7"><div id="calibre_link-2072" class="calibre2"><h2 id="calibre_link-156" class="calibre20">Wrapping Up</h2>
<p id="calibre_link-2073" class="calibre19">Amazingly, this is the last chapter dealing with our Rumbl application! In this chapter, we tested the most sophisticated features in our entire application stack. You probably noticed that the functional nature of Phoenix made testing the application much easier than you might have expected. Our tests run quickly, and they’re compact, thanks to the helpers that abstract concepts like <span class="cf">assert_reply</span>, <span class="cf">assert_broadcast</span>, and <span class="cf">assert_receive</span>. Here’s what we accomplished:</p><ul class="calibre28"><li class="calibre29">
<p id="calibre_link-2074" class="calibre31">We tested our OTP layer for our <span class="cf1">InfoSys</span> OTP application.</p></li><li class="calibre29">
<p id="calibre_link-2075" class="calibre31">We split out an independent caching layer for performance.</p></li><li class="calibre29">
<p id="calibre_link-2076" class="calibre31">We built a specific backend rather than a dynamic stub or mock to keep our tests isolated, as our unit and integration tests should be.</p></li><li class="calibre29">
<p id="calibre_link-2077" class="calibre31">We tested our sockets authentication code.</p></li><li class="calibre29">
<p id="calibre_link-2078" class="calibre31">We used the Phoenix testing support to test our channels.</p></li></ul>
<p id="calibre_link-2079" class="calibre19">



By no means is this testing story complete. We didn’t cover user acceptance testing. Nor did we cover performance testing. We did accomplish quite a bit in a short time. These kinds of concurrent, interactive applications can be notoriously difficult to test.</p>
<p id="calibre_link-2080" class="calibre19">In the next chapter, we’ll wrap up. We’ll cover some features that didn’t make it into our application such as internationalization. We will also cover the newest Phoenix library, LiveView, and learn how you can build whole pages without MVC-style controllers or JavaScript. Then, we’ll take a brief look at what’s next for the Phoenix team.</p>
<p id="calibre_link-2081" class="calibre19">We’re not quite done. Let’s go!



</p>
<p id="calibre_link-2082" class="calibre19">

































</p>

<div class="footnotes">
<h4 class="calibre24">Footnotes</h4>
<dl class="calibre25">
<dt class="footnote-number"><a id="calibre_link-179" href="#calibre_link-8" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[34]</a></dt><dd class="calibre26">
<p id="calibre_link-2083" class="calibre27"><a href="http://products.wolframalpha.com/api/explorer.html" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">http://products.wolframalpha.com/api/explorer.html</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-180" href="#calibre_link-9" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[35]</a></dt><dd class="calibre26">
<p id="calibre_link-2084" class="calibre27"><a href="https://github.com/PSPDFKit-labs/bypass" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://github.com/PSPDFKit-labs/bypass</a></p></dd></dl></div>
<div class="copyright">Copyright © 2020, The Pragmatic Bookshelf.</div>




</div>



  </div>


<div class="calibre1" id="calibre_link-56"><div id="calibre_link-2085" class="calibre2"><h1 class="pcalibre6 chapter-title" id="calibre_link-157"><span class="chapter-number">
            Chapter
            14</span><br class="calibre18" /><span class="chapter-name">What’s Next?</span></h1>

<p id="calibre_link-2086" class="calibre19">We hope you’ve enjoyed reading this book as much as we’ve enjoyed putting it together for you. The Phoenix story is an incredible one, and the telling is nowhere near done. If you’ve coded along with us, you should have a better handle on how the bits of your code fit together to form interactive, scalable, reliable applications. Let’s review what we’ve done so far.</p>
<p id="calibre_link-2087" class="calibre19">First, we built a toy application so you could learn where to put each piece of code. You worked with the Phoenix router. You learned how connections flowed through plugs to controllers and views. You built a trivial controller and a simple view that rendered a template.</p>
<p id="calibre_link-2088" class="calibre19">Next, we started working on our <span class="cf">rumbl</span> application, one that you used throughout the rest of the book. We created a controller, and rather than integrating a full database right away, we defined the context as the API to our business domain so we could focus on the controller. We then created a couple of actions, and some views and templates to render our results.</p>
<p id="calibre_link-2089" class="calibre19">With that out of the way, we dove into Ecto to integrate our context with a full database-backed repository. Initially, we focused on the initial schema for users. We built a migration and a changeset to help us manage change. In the next few chapters, we improved our context to support iterations on the frontend. We created a plug to help integrate authentication in our application, and then we built some more sophisticated schemas and contexts with relationships. Then, we tested the work we’d done so far.</p>
<p id="calibre_link-2090" class="calibre19">Next, we moved into Part II. We built a channel to handle the real-time features of our application. We learned that the Phoenix Channels allows us to build applications with state, but without the performance penalties you generally see with similar frameworks. We used these features to deliver real-time features, allowing users to comment on a playing video in real time. We worked on the server in Elixir and paired it with an ES6 JavaScript client. We used channels to let users post messages, and then broadcast those messages to all other interested users. Then, we extended our authentication system, adopting token-based authentication. We also built in Channel Presence to detect when users come and go.</p>
<p id="calibre_link-2091" class="calibre19">We then started to get more familiar with the underlying principles of building applications in Elixir and converted our <span class="cf">rumbl</span> app into an umbrella project. Along the way, we used Observer to get a full picture of what was happening with our application in real time. The umbrella project let us isolate the development and testing of individual applications.</p>
<p id="calibre_link-2092" class="calibre19">Once our umbrella project was ready, we crafted an information system service as a brand new application. We learned how to add state to our applications with concurrency, message passing, and recursive functions. We also learned to use supervisors to keep our system reliable and take action when things break.</p>
<p id="calibre_link-2093" class="calibre19">We tried to build a broad and exciting application, but it was impossible to cover all of the useful projects happening in the language, the Phoenix project, or the community. Here are some of the things you can explore.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-207"><div id="calibre_link-2094" class="calibre2"><h2 id="calibre_link-158" class="calibre20">Other Interesting Features</h2>
<p id="calibre_link-2095" class="calibre19">In any successful development ecosystem, a tension always exists between currency and stability. We’ve tried to walk as closely to currency as we could without stepping over. Still, exciting things are happening, many of which weren’t ready to include in this text. These are some exciting features you may want to use in your next project.</p><h3 class="calibre22">Supporting Internationalization with Gettext</h3>
<p id="calibre_link-2096" class="calibre19">


In version v1.1, Phoenix added integration with Gettext, an internationalization (i18n) and localization (l10n) system commonly used for writing multilingual programs. Gettext can automatically extract translations from your source code, reducing the burden on the developer. Furthermore, since the Gettext standard is used by so many communities, you can take advantage of a rich set of tooling for both developers and translators.</p>
<p id="calibre_link-2097" class="calibre19">

When you ran <span class="cf">mix phx.new rumbl</span>, Phoenix generated a <span class="cf">RumblWeb.Gettext</span> module at <span class="cf">lib/rumbl_web/gettext.ex</span>. You can see it in use in the <span class="cf">lib/rumbl_web/views/error_helpers.ex</span> file, used to translate the error messages coming from Ecto. Since programmers often organize translations into namespaces called domains, Phoenix places Ecto messages in the <span class="cf">errors</span> domain by default.</p>
<p id="calibre_link-2098" class="calibre19">
The translations for different languages are in the <span class="cf">priv/gettext</span> directory. There you’ll find a default template for Ecto messages called <span class="cf">errors.pot</span>. A translation for each language is placed in directories such as <span class="cf">priv/gettext/en/LC_MESSAGES</span>.</p>
<p id="calibre_link-2099" class="calibre19">


To learn more about the integration between Phoenix and Gettext, we recommend this fantastic article by Rebecca Skinner entitled “Internationalization using Gettext in the Phoenix framework.”<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-29" href="#calibre_link-208">[36]</a></sup> For general information, check out the Gettext documentation.<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-30" href="#calibre_link-209">[37]</a></sup></p>
<p id="calibre_link-2100" class="calibre19">



Next, we’ll move from internationalization to <span class="cf">intercept</span> and <span class="cf">handle</span>, a couple of functions that make it easier to manage channel messages.</p><h3 class="calibre22">Intercepting on Phoenix Channels</h3>
<p id="calibre_link-2101" class="calibre19">


When you broadcast a message, Phoenix sends it to the Publish and Subscribe (PubSub) system, which then broadcasts it directly to all user sockets. We call this approach <span class="calibre4">fastlaning</span> because it completely bypasses the channel, allowing us to encode the message once. Phoenix Channels also provide a feature called <span class="cf">intercept</span>, which allows channels to intercept a broadcast message before it’s sent to the user.</p>
<p id="calibre_link-2102" class="calibre19">



For example, maybe we’d like to let the video’s creator edit all of its annotations. For such a feature, we could append an <span class="cf">is_editable</span> field to the annotation map when we broadcast it so the frontend can adapt accordingly. Using <span class="cf">intercept</span>, we could build this feature like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">intercept [​<em class="string">"</em>​​<em class="string">new_annotation"</em>​]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment"># For every new_annotation broadcast,</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment"># append an is_editable value for client metadata.</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ handle_out(​<em class="string">"</em>​​<em class="string">new_annotation"</em>​, msg, socket) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  %{​<em class="string">video:</em>​ video, ​<em class="string">user_id:</em>​ user_id} = socket.assigns</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  push socket, ​<em class="string">"</em>​​<em class="string">new_annotation"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">       Map.merge(msg, %{​<em class="string">is_editable:</em>​ video.user_id == user_id})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {​<em class="string">:noreply</em>​, socket}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2103" class="calibre19">

For each event that we specify in <span class="cf">intercept</span>, we must define a <span class="cf">handle_out</span> clause to handle the intercepted event. You can also intercept an event and choose not to push it at all, in case you want to make sure that some clients don’t receive specific events.</p>
<p id="calibre_link-2104" class="calibre19">
<span class="cf">intercept</span> is a nice feature, but you need to be careful. Imagine that you have 10,000 users watching a video at the same time. Instead of using <span class="cf">intercept</span>, you could write a few extra lines of code to include a <span class="cf">:video_user_id</span> field in the message, letting the client decide whether the message is editable.  For that implementation, Phoenix would encode the broadcast once and send the message to all sockets.</p>
<p id="calibre_link-2105" class="calibre19">With the <span class="cf">intercept</span> implementation, Phoenix would send the message to the first 10,000 channel processes, one for each client. While processing the <span class="cf">intercept</span>, each channel would independently modify the intercepted message and push it to the socket to be encoded and sent. The cost of <span class="cf">intercept</span> is 10,000 extra messages, one per channel, as well as encoding those messages 9,999 times&mdash;again, once per channel&mdash;compared to the one-time encoding of the implementation without <span class="cf">intercept</span>. For those reasons, we recommend using <span class="cf">intercept</span> with care.</p>
<p id="calibre_link-2106" class="calibre19">On the other hand, <span class="cf">intercept</span> can be tremendously useful when we’re evolving code. Imagine building a new version of the annotations feature in the future, with new frontend and backend code, including a different payload when new annotations are broadcast. However, imagine that you also have old clients that can take a while to migrate. You could use the new annotation-broadcast format throughout the new code and use <span class="cf">intercept</span> to retrofit the <span class="cf">new_annotation</span> broadcast into the old one. For these cases, <span class="cf">intercept</span> would be an ideal solution. You’d pay a temporary performance price to make your code easier to build and understand.</p>
<p id="calibre_link-2107" class="calibre19">
For more information on <span class="cf">intercept</span> and <span class="cf">handle</span>, check the Phoenix documentation on channels.<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-31" href="#calibre_link-210">[38]</a></sup> Next, we’ll move on to live code reload.</p><h3 class="calibre22">Understanding Phoenix Live Reload</h3>
<p id="calibre_link-2108" class="calibre19">





One of the features we used throughout the entire book was Phoenix Live Reload, which allows us to see changes propagated to the browser as soon as we save them to the filesystem. Phoenix Live Reload is composed of:
</p><ul class="calibre28"><li class="calibre29">
<p id="calibre_link-2109" class="calibre31">A dependency called <span class="cf1">file_system</span> that watches the filesystem for changes</p></li><li class="calibre29">
<p id="calibre_link-2110" class="calibre31">A channel that receives events from the <span class="cf1">file_system</span> application and converts them into broadcasts</p></li><li class="calibre29">
<p id="calibre_link-2111" class="calibre31">A plug that injects the live-reload iframe on every request and serves the iframe content for web requests</p></li></ul>
<p id="calibre_link-2112" class="calibre19">There isn’t much to Live Reload, and that’s exactly why we recommend that you to study its source code to learn more about how simple it is to extend Phoenix. If the feature is something you might want to customize, consider reading more or even following the project. You can find the source code in our Phoenix Live Reload GitHub project.<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-32" href="#calibre_link-211">[39]</a></sup>

</p>
<p id="calibre_link-2113" class="calibre19">While we’re on the subject of customization, let’s see how you might customize the Phoenix PubSub adapter.</p><h3 class="calibre22">Phoenix PubSub Adapter</h3>
<p id="calibre_link-2114" class="calibre19">




By default, Phoenix PubSub uses distributed Erlang to ensure that broadcasts work across multiple nodes. This requires all machines to be connected together according to the Erlang Distribution Protocol. Setting up distributed Erlang is straightforward, but it might not be directly supported in some deployment platforms.</p>
<p id="calibre_link-2115" class="calibre19">
You needn’t worry, though. Phoenix PubSub is extensible&mdash;it supports multiple adapters. One is the Redis adapter,<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-33" href="#calibre_link-212">[40]</a></sup> maintained by the Phoenix team, which empowers the PubSub system by using Redis as its message-distribution mechanism. You can use one of these options or even write your own.</p>
<p id="calibre_link-2116" class="calibre19">You’ve seen how to customize Phoenix messaging on the server side. Some interesting things are happening on the client side too.</p><h3 class="calibre22">Phoenix Clients for Other Platforms</h3>
<p id="calibre_link-2117" class="calibre19">




In our channels chapter, you saw how we customized the Phoenix
transport to work with our ES6 code. Phoenix Channels support the
nearly ubiquitous JavaScript and also a wide range of other clients
and platforms, including C#, Java, Objective-C, and
Swift.<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-34" href="#calibre_link-213">[41]</a></sup></p>
<p id="calibre_link-2118" class="calibre19">
All these clients use WebSockets, but don’t forget that Phoenix Channels are transport agnostic. If you have special requirements, as in embedded software or working on special platforms, you can always use a custom protocol to talk to Phoenix.</p>
<p id="calibre_link-2119" class="calibre19">The Phoenix project has surpassed our expectations in its first few years, but we’re even more excited about what’s coming next. In the next few sections, we offer a preview, listing those we expect the soonest first. Be careful, though. We offer no guarantees!</p>
<p id="calibre_link-2120" class="calibre19">By far the most anticipated change is Phoenix Liveview. Let’s take a peek.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-243"><div id="calibre_link-2121" class="calibre2"><h2 id="calibre_link-159" class="calibre20">Phoenix LiveView</h2>
<p id="calibre_link-2122" class="calibre19">
As the base infrastructure for channels matures, we’re seeing an acceleration of higher level libraries that take advantage of them. LiveView is the perfect example. In essence, it’s a library for building interactive, rich applications, that are bi-directional. That much is not new. Throughout the second half of this book, we’ve done very much the same thing with channels.</p>
<p id="calibre_link-2123" class="calibre19">Here’s the best part, though. What if you could do the same thing without writing custom JavaScript? In this short section, we’ll walk you through how you can do exactly that. Don’t get us wrong. We love working with the Phoenix toolchain including JavaScript, but juggling fewer frameworks means more brainpower is available to attack the business problem.</p>
<p id="calibre_link-2124" class="calibre19">Let’s look at how it all works. Conceptually, LiveView:




</p><ul class="calibre28"><li class="calibre29">Represents a web page as a function over web state</li><li class="calibre29">Establishes messages and callbacks to change that state</li><li class="calibre29">Allows browser events such as mouse clicks, form submits, and key presses to send events</li></ul>
<p id="calibre_link-2125" class="calibre19">Though it’s a young library, LiveView users are already pushing the boundaries of what can be done without writing JavaScript. It is excellent for a wide variety of scenarios from form validation and autocompletion to handling communication triggered by links and keystrokes. We’re not going to show you an exhaustive list of LiveView use cases, but we’d love to show you how some of the most important ones work.</p>
<p id="calibre_link-2126" class="calibre19">To show the interplay of routes and events, we’ll walk you through a couple of simple examples and then show progressively more complex scenarios.</p>
<p id="calibre_link-2127" class="calibre19">We’ll start with a static page and progressively move to more advanced examples. So that we can start with a foundation that’s going to stay up to date, we’ll walk you through the Phoenix LiveView Example.<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-35" href="#calibre_link-244">[42]</a></sup></p><h3 class="calibre22">Establishing a Static LiveView</h3>
<p id="calibre_link-2128" class="calibre19">
To get things started, let’s build our own LiveView. For the simplest of examples, all of our code can live in two places: the router and the live view. First, let’s start with the router.</p>
<p id="calibre_link-2129" class="calibre19">We’ve set up LiveView according to the project instructions. It takes about fifteen minutes or so the first few times. Once we’re done, we can add routes to <span class="cf">router.ex</span>, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">import</strong>​ Phoenix.LiveView.Router</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">live ​<em class="string">"</em>​​<em class="string">/welcome"</em>​, WelcomeLive</td></tr></table>
<p id="calibre_link-2130" class="calibre19">
We import the LiveView router code and use one of the imports, the <span class="cf">live</span> function, to create a new route that points the <span class="cf">/welcome</span> route to a module holding a live view. Now we’re ready to create the live view. We’ll put it in <span class="cf">lib/demo_web/live/welcome_live.ex</span>, and make it look like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ DemoWeb.WelcomeLive ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ Phoenix.LiveView</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ render(assigns) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">~</strong>​L​<em class="string">"""</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">    &lt;div&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">      &lt;h2&gt;Welcome to LiveView, from Chris, José and Bruce&lt;/h2&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">    &lt;/div&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">    """</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ mount(_session, socket) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, socket}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2131" class="calibre19">



In every case, <span class="cf">render/1</span> is a pure function that takes <span class="cf">socket.assigns</span> as its lone argument. This structure is functional programming at its finest. Because every LiveView page is a simple pure function, debugging is much easier than you might find in alternatives. We’ll unlock some complexity over time. For now, point your browser to our route, <span class="cf">http://localhost:4000/welcome</span>. You’ll see the message  “Welcome to LiveView, from Chris, José and Bruce.”</p>
<p id="calibre_link-2132" class="calibre19">
Let’s shed some light on what’s happening after Phoenix calls the route. LiveView is a Phoenix Channels implementation so the live view for each end user will run in its own process. When <span class="cf">router.ex</span> has a <span class="cf">live</span> route, it will call the <span class="cf">mount/2</span> function on that live view. The <span class="cf">mount</span> function’s job is to establish the initial state of the live view. Dutifully, our function returns an <span class="cf">:ok</span> tuple with an empty socket.</p>
<p id="calibre_link-2133" class="calibre19">
That’s not all, though. This function is analogous to an <span class="cf">init</span> function in an OTP GenServer. When that’s done, LiveView will render the initial view. We’ll simply render the HTML directly inline using the <span class="cf">~L"""</span> sigil. As you might expect, this sigil does everything necessary to render a LiveView.</p>
<p id="calibre_link-2134" class="calibre19">What we’ve built is not a one-time render. It actually starts a process and will loop over messages, calling <span class="cf">render/1</span> each time there’s a new event.</p>
<p id="calibre_link-2135" class="calibre19">Since pure HTML is not too interesting, let’s spice things up a little bit. Let’s set some state in the <span class="cf">socket</span> within our <span class="cf">mount</span>, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ DemoWeb.WelcomeLive ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ Phoenix.LiveView</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ render(assigns) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">~</strong>​L​<em class="string">"""</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">    &lt;div&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">      &lt;h2&gt;&lt;%= @salutation %&gt;&lt;/h2&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">    &lt;/div&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">    """</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ mount(_session, socket) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    salutation = ​<em class="string">"</em>​​<em class="string">Welcome to LiveView, from the Programming Phoenix team!"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, assign(socket, ​<em class="string">salutation:</em>​ salutation)}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2136" class="calibre19">We moved the changing text to the socket, and added a substitution to the LiveView. Now, you can get a better look at how we’ll encorporate changing state in the LiveView. We can simply define fields in <span class="cf">socket.assigns</span>, and access those directly to do substitutions in LiveView. Whenever that state changes, Phoenix LiveView will use channels to make sure that the changes (and only the changes) to our state make it down to the client.</p>
<p id="calibre_link-2137" class="calibre19">So the initial lifecycle for a LiveView before we consider events looks like this:</p><table class="processedcode1"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   live(url, LiveView)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; mount</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; render</td></tr></table>
<p id="calibre_link-2138" class="calibre19">You’ve already seen the basics so it’s time to add some interaction. Let’s take a look at an example with some interaction, a clock.


</p><h3 class="calibre22">Processing Events in a Clock</h3>
<p id="calibre_link-2139" class="calibre19">
Now that you know how to handle an inbound route with the <span class="cf">live</span> macro, let’s go to the <span class="cf">ClockLive</span> view within the Phoenix LiveView example project for help with the next example. We’ll look at a clock. To keep things simple, we’ll strip out a few of the bells and whistles.</p>
<p id="calibre_link-2140" class="calibre19">
In this case, we’ll use the Erlang <span class="cf">:timer</span> module to send periodic messages to the end user’s live view process. Here’s how it works.</p>
<p id="calibre_link-2141" class="calibre19">First, establish a route in <span class="cf">lib/demo_web/router.ex</span>, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">live ​<em class="string">"</em>​​<em class="string">/clock"</em>​, ClockLive</td></tr></table>
<p id="calibre_link-2142" class="calibre19">
We create a route that will go to our live view. Now, let’s take a look at a live view. For reference, if you are looking at the example, the file is in <span class="cf">lib/demo_web/live/clock_live.ex</span>. It won’t look exactly like this one, but it will be close:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ DemoWeb.ClockLive ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ Phoenix.LiveView</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">import</strong>​ Calendar.Strftime</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ render(assigns) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">~</strong>​L​<em class="string">"""</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">    &lt;div&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">      &lt;h2&gt;It's &lt;%= strftime!(@date, "%r") %&gt;&lt;/h2&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">    &lt;/div&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">    """</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2143" class="calibre19">



That’s easy enough. We render a view, with just a little bit of dynamic data, a <span class="cf">@date</span> field in <span class="cf">assigns</span>. We’ll initialize that value when we mount, and also trigger a periodic message to our process like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ mount(_session, socket) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">if</strong>​ connected?(socket), ​<strong class="kw">do</strong>​: ​<em class="string">:timer</em>​.send_interval(1000, self(), ​<em class="string">:tick</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {​<em class="string">:ok</em>​, put_date(socket)}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defp</strong>​ put_date(socket) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  assign(socket, ​<em class="string">date:</em>​ ​<em class="string">:calendar</em>​.local_time())</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2144" class="calibre19">


In the <span class="cf">mount</span> function, we call <span class="cf">:timer.send_interval</span> to send a simple <span class="cf">:tick</span> message every 1000 milliseconds to the <span class="cf">self()</span> PID, the id for our process. Then, we call a private function called <span class="cf">put_date</span> that uses <span class="cf">assign</span> to initialize the <span class="cf">@date</span> field in <span class="cf">socket.assigns</span> to the current date and time,so LiveView can render it after we mount.</p>
<p id="calibre_link-2145" class="calibre19">We still have one more job to do. We need to handle the <span class="cf">:tick</span> message, like this: </p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ handle_info(​<em class="string">:tick</em>​, socket) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:noreply</em>​, put_date(socket)}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2146" class="calibre19">

Marvelous! Handling the <span class="cf">:tick</span> message is a simple <span class="cf">handle_info</span>. That’s because under the hood, this LiveView is a GenServer! Straight process messages come in through <span class="cf">handle_info</span>.</p>
<p id="calibre_link-2147" class="calibre19">
The only thing we need to do is to call our existing <span class="cf">put_date(socket)</span> to update the socket with the current timestamp.</p>
<p id="calibre_link-2148" class="calibre19">Browse on over to <span class="cf">http://localhost:4000/clock</span> and you’ll see the counting date! Keep in mind that we didn’t have to create any custom JavaScript. Phoenix is sending down only the parts of the page that need to change.</p>
<p id="calibre_link-2149" class="calibre19">Let’s see how LiveView handles incoming events from the web page. Let’s build a simple counter.
</p><h3 class="calibre22">Handling Links in a Counter</h3>
<p id="calibre_link-2150" class="calibre19">



Let’s say you had a web page and a few links on it for interacting with some server side content. We could build a Phoenix MVC application. We’d have to establish a separate route for each link and form. We’d then need to add in a controller, a view, and we’d need to render HTML, either with functions or via a template. We’d also possibly need some backend logic, fronted by a context.</p>
<p id="calibre_link-2151" class="calibre19">Alternatively, we could build a channel and make all communication flow over a channel. We’d segregate all backend code in the context, just as we do for MVC apps. That’s a drastic improvement in user experience, and the only cost is that we have to commit to working in two languages, JavaScript and Elixir. Still, we can do better.</p>
<p id="calibre_link-2152" class="calibre19">With LiveView, for the simplest of scenarios, all of our code can live in two files, the live view and the route. Once we get to the point where we need to segregate code, we are still free to break backend code into a context, and frontend code into functions or templates.  Let’s take a look.</p>
<p id="calibre_link-2153" class="calibre19">In <span class="cf">lib/demo_web/router.ex</span>, you’ll see the familiar <span class="cf">live</span> route, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">live ​<em class="string">"</em>​​<em class="string">/counter"</em>​, CounterLive</td></tr></table>
<p id="calibre_link-2154" class="calibre19">Next, let’s look at the live view. First, here’s the counter code we’re rendering from the example in <span class="cf">lib/demo_web/live/counter.ex</span>:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ DemoWeb.CounterLive ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ Phoenix.LiveView</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ render(assigns) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">~</strong>​L​<em class="string">"""</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">    &lt;div&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">      &lt;h1&gt;The count is: &lt;%= @val %&gt;&lt;/h1&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">      &lt;button phx-click="boom" class="alert-danger"&gt;BOOM&lt;/button&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">      &lt;button phx-click="dec"&gt;-&lt;/button&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">      &lt;button phx-click="inc"&gt;+&lt;/button&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">    &lt;/div&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">    """</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2155" class="calibre19">

This <span class="cf">render</span> function is starting to have some real meat on the bones. After the initial ceremony that defines the module and the <span class="cf">use LiveView</span> directive to announce our intention to use LiveView directives, we do the work to render our page. First we have a heading with our count, <span class="cf">@val</span>.</p>
<p id="calibre_link-2156" class="calibre19">After the initial heading, we have three buttons. One calls an unsupported message called <span class="cf">boom</span>. The other two operate our counter. The only difference from pure HTML is that they support data attributes called <span class="cf">phx-click</span>. This attribute signals the JavaScript code on the client to send a Phoenix Channels message to the client!</p>
<p id="calibre_link-2157" class="calibre19">You can already imagine what the rest of the app looks like. Here’s the initial mount:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ mount(_session, socket) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {​<em class="string">:ok</em>​, assign(socket, ​<em class="string">:val</em>​, 0)}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2158" class="calibre19">

We must initialize every <span class="cf">assigns</span> field so our <span class="cf">mount</span> function establishes the initial value of our counter, a <span class="cf">:val</span> of <span class="cf">0</span>. Then, we build the functions to handle our events and update the server, like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ handle_event(​<em class="string">"</em>​​<em class="string">inc"</em>​, _, socket) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:noreply</em>​, update(socket, ​<em class="string">:val</em>​, &amp;(&amp;1 + 1))}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ handle_event(​<em class="string">"</em>​​<em class="string">dec"</em>​, _, socket) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:noreply</em>​, update(socket, ​<em class="string">:val</em>​, &amp;(&amp;1 - 1))}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2159" class="calibre19">
These are custom LiveView events, but they work just like messages. The channel process for a given user will get a <span class="cf">handle_event</span> message each time that user clicks on an element with a <span class="cf">phx-click</span> data attribute. In this case, we have events for <span class="cf">inc</span> and <span class="cf">dec</span>. They both work the same, so let’s look at just the <span class="cf">inc</span> message.</p>
<p id="calibre_link-2160" class="calibre19">We send a <span class="cf">:noreply</span> tuple, updating the <span class="cf">:val</span> field in <span class="cf">socket</span> with an anonymous function to increment a counter, and…</p>
<p id="calibre_link-2161" class="calibre19">we’re done! There’s no additional route for each action, no custom JavaScript to parse the result, no work to determine which pieces of the page change and which stay the same. LiveView <span class="calibre4">handles it all</span>.</p>
<p id="calibre_link-2162" class="calibre19">Typically, the <span class="cf">handle_event</span> will update the state in some way, but it doesn’t have to. Let’s take a look at a third use case, command-line completion.</p>
<p id="calibre_link-2163" class="calibre19">Here’s what the pipeline looks like for an arbitrary event:</p><table class="processedcode1"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   handle_event(event, data, socket)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">   |&gt; render</td></tr></table>
<p id="calibre_link-2164" class="calibre19">While we’re here, open up your browser and navigate to the <span class="cf">counter</span> page. Increment the counter a couple of times and you’ll see the count update. Notice that it’s extremely snappy! It will usually remain so once you deploy it live.</p>
<p id="calibre_link-2165" class="calibre19">Let’s try one more thing. Remember, channels is built on OTP, and it wouldn’t be an OTP demo without some kind of a crash. Click the <span class="cf">boom</span> button. We haven’t implemented <span class="cf">boom</span> yet, so when you flip over to your Phoenix server tab, you’ll see a stack trace like this one:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">[error] GenServer ​<em class="comment">#PID&lt;0.568.0&gt; terminating</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">** (FunctionClauseError) no function clause matching in</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    DemoWeb.CounterLive.handle_event/3</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    (demo) lib/demo_web/live/counter_live.ex:24:</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">       DemoWeb.CounterLive.handle_event("boom", "",</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">       %Phoenix.LiveView.Socket{assigns: %{val: 2},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">       changed: nil, connected?: true, ...})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<span class="coprompt">...</span>​</td></tr></table>
<p id="calibre_link-2166" class="calibre19">
Since we’re on OTP, our supervisor will start again! You’ll see a brief reloading indicator. Then, you can go back to your browser to see the counter, restarted to zero. Click it a few times. It still works:</p><div class="praise"><img id="calibre_link-2167" class="calibre51" src="images/000043.png" alt="images/src/wrapping_up/counter.png" width="270" height="118" /></div>
<p id="calibre_link-2168" class="calibre19">Now that we can process links, we are ready to take the next step. Let’s take an interactive use case for forms, autocomplete.



</p><h3 class="calibre22">Implementing Autocomplete Forms</h3>
<p id="calibre_link-2169" class="calibre19">


Command-line completion is typically a tedious use case that is a headache to implement but also tremendously useful for users. This is what it looks like with LiveView.</p>
<p id="calibre_link-2170" class="calibre19">Rather than show you <span class="calibre4">all</span> of the example, let’s look at the bits that do the most work.</p>
<p id="calibre_link-2171" class="calibre19">First, here’s the view:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ render(assigns) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">~</strong>​L​<em class="string">"</em>​​<em class="string">"</em>​​<em class="string">"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">  &lt;form phx-change="</em>​suggest​<em class="string">"</em>​​<em class="string"> phx-submit="</em>​search​<em class="string">"</em>​​<em class="string">&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">    &lt;input type="</em>​text​<em class="string">"</em>​​<em class="string"> name="</em>​q​<em class="string">"</em>​​<em class="string"> value="</em>​&lt;%= @query %&gt;​<em class="string">"</em>​​<em class="string"> list="</em>​matches​<em class="string">"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">          placeholder="</em>​Search...​<em class="string">"</em>​​<em class="string"> &lt;%= if @loading, do: "</em>​readonly​<em class="string">"</em>​​<em class="string"> %&gt;/&gt;</em>​</td></tr></table>
<p id="calibre_link-2172" class="calibre19">

As you might expect, the form is a pure HTML form. We tag the form with two attributes. <span class="cf">phx-change</span> triggers an event when anything on the form changes and <span class="cf">phx-submit</span> triggers an event whenever a user submits a form.</p>
<p id="calibre_link-2173" class="calibre19">
Note that we also introduce a <span class="cf">@loading</span> field so we can disable the <span class="cf">text</span> field when we’re loading results.</p>
<p id="calibre_link-2174" class="calibre19">Next, let’s look at the real HTML work, the rendering of the results.</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    &lt;datalist id=​<em class="string">"</em>​​<em class="string">matches"</em>​&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      &lt;%= for match &lt;- @matches ​<strong class="kw">do</strong>​ %&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">        &lt;option value=​<em class="string">"</em>​​<em class="string">&lt;%= match %&gt;"</em>​​<strong class="kw">&gt;</strong>​&lt;%= match %​<strong class="kw">&gt;</strong>​&lt;/option&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      &lt;% ​<strong class="kw">end</strong>​ %&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    &lt;/datalist&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    &lt;%= ​<strong class="kw">if</strong>​ @result ​<strong class="kw">do</strong>​ %​<strong class="kw">&gt;</strong>​&lt;pre​<strong class="kw">&gt;</strong>​&lt;%= @result %​<strong class="kw">&gt;</strong>​&lt;/pre​<strong class="kw">&gt;</strong>​&lt;% ​<strong class="kw">end</strong>​ %&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  &lt;/form&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="string">"</em>​​<em class="string">"</em>​​<em class="string">"</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="string">end</em>​</td></tr></table>
<p id="calibre_link-2175" class="calibre19">

We present the results in two pieces: the <span class="cf">@matches</span> that we return on <span class="cf">phx-change</span> and the <span class="cf">@result</span> we return on <span class="cf">phx-submit</span>.</p>
<p id="calibre_link-2176" class="calibre19">We use <span class="cf">for</span> to produce an option for each of the <span class="cf">@matches</span>.  We then conditionally display a <span class="cf">@result</span> if one exists.</p>
<p id="calibre_link-2177" class="calibre19">Here’s the cool part. LiveView will only send down the parts of the page that need to change! If any typing triggers no change, the user’s browser will not get an update command!</p>
<p id="calibre_link-2178" class="calibre19">
Here’s the <span class="cf">handle_event</span> that processes the <span class="cf">suggest</span> message that we asked for with the <span class="cf">phx-change</span> data attribute:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ handle_event(​<em class="string">"</em>​​<em class="string">suggest"</em>​, %{​<em class="string">"</em>​​<em class="string">q"</em>​ =&gt; query}, socket)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">when</strong>​ byte_size(query) &lt;= 100 ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {words, _} =</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    System.cmd(​<em class="string">"</em>​​<em class="string">grep"</em>​, [​<em class="string">"</em>​​<em class="string">^</em>​​<em class="string">#{</em>​query​<em class="string">}</em>​​<em class="string">.*"</em>​, ​<em class="string">"</em>​​<em class="string">-m"</em>​, ​<em class="string">"</em>​​<em class="string">5"</em>​, ​<em class="string">"</em>​​<em class="string">/usr/share/dict/words"</em>​])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {​<em class="string">:noreply</em>​, assign(socket, ​<em class="string">matches:</em>​ String.split(words, ​<em class="string">"</em>​​<em class="string">\n"</em>​))}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2179" class="calibre19">Note that this command is specific to Unix! This code simply calls an OS shell command to look for results in a system dictionary and sets the state based on the results.</p>
<p id="calibre_link-2180" class="calibre19">Now, let’s look at a form submit:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ handle_event(​<em class="string">"</em>​​<em class="string">search"</em>​, %{​<em class="string">"</em>​​<em class="string">q"</em>​ =&gt; query}, socket)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<strong class="kw">when</strong>​ byte_size(query) &lt;= 100 ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  send(self(), {​<em class="string">:search</em>​, query})</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    ​<em class="string">:noreply</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    assign( socket,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<em class="string">query:</em>​ query,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<em class="string">result:</em>​ ​<em class="string">"</em>​​<em class="string">Searching..."</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<em class="string">loading:</em>​ true,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      ​<em class="string">matches:</em>​ [])</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  }</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ handle_info({​<em class="string">:search</em>​, query}, socket) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ... ​<strong class="kw">do</strong>​ search ...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2181" class="calibre19">
We send an asynchronous message to ourselves so that we can report back to the user while the system loads the results. As this application gets more robust, we can break out the <span class="cf">search</span> and <span class="cf">autocomplete</span> business logic into its own context.</p>
<p id="calibre_link-2182" class="calibre19">

If you’d like, you can open up the developer’s tools for your browser. In Chrome, you can do so by inspecting an element on the page and then clicking on the <span class="cf">network</span> tab. Type a few characters and you’ll see that LiveView is sending down only the precise parts of the page that change!</p>
<p id="calibre_link-2183" class="calibre19">We’ve touched on a basic form submission. Let’s take on a more complex problem, form validation.
</p><h3 class="calibre22">Validating Forms</h3>
<p id="calibre_link-2184" class="calibre19">



You have seen the main two LiveView events. <span class="cf">phx-change</span> fires on each form change and <span class="cf">phx-submit</span> fires on submit. Form validation is an especially tedious use case for most web applications, but they are tremendously useful to users.</p>
<p id="calibre_link-2185" class="calibre19">When a user’s head space can stay in one place, a live view, the problem gets much easier to solve. Once again, we’ll go to the LiveView  examples to find the <span class="cf">user_live</span> demonstration.</p>
<p id="calibre_link-2186" class="calibre19">In this file, you’ll find a more practical production code organization. In <span class="cf">lib/demo/context</span>, you’ll find an <span class="cf">accounts</span> context much like the one we built for Rumbl. We’ll use a few of these throughout the demo.</p>
<p id="calibre_link-2187" class="calibre19">In <span class="cf">lib/demo_web/live/user_live</span>, you’ll find live views for various use cases. We’re going to focus on <span class="cf">new.ex</span>.</p>
<p id="calibre_link-2188" class="calibre19">
First, let’s look at the <span class="cf">mount</span> function:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ mount(_session, socket) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {​<em class="string">:ok</em>​, assign(socket, ​<em class="string">changeset:</em>​ Accounts.change_user(%User{}))}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2189" class="calibre19">Notice that we’re calling into our <span class="cf">Accounts</span> context to get a changeset for a <span class="cf">User</span>. Otherwise, the <span class="cf">mount</span> looks exactly like the other examples you’ve seen.</p>
<p id="calibre_link-2190" class="calibre19">
Next, let’s look at the <span class="cf">render</span>. It may surprise you:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ render(assigns) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Phoenix.View.render(DemoWeb.UserView, ​<em class="string">"</em>​​<em class="string">new.html"</em>​, assigns)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2191" class="calibre19">For the first time in one of these examples, you see us render a template directly. We can also render other live views, but this one is similar to the simple template Phoenix generates for a new generated resource. It’s a skinny wrapper that in turn renders a form with fields that look like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment">&lt;%=</em>​ f = form_for @changeset,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">                 ​<em class="string">"</em>​​<strong class="kw">#</strong>​​<em class="string">"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">                 [​<em class="string">phx_change:</em>​ ​<em class="string">:validate</em>​, ​<em class="string">phx_submit:</em>​ ​<em class="string">:save</em>​] ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">...</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment">&lt;%=</em>​ label f, ​<em class="string">:username</em>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment">&lt;%=</em>​ text_input f, ​<em class="string">:username</em>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<em class="comment">&lt;%=</em>​ error_tag f, ​<em class="string">:username</em>​ ​<em class="comment">%&gt;</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">...</td></tr></table>
<p id="calibre_link-2192" class="calibre19">


There are no surprises here. We simply add the data attributes for <span class="cf">phx_change</span> and <span class="cf">phx_submit</span>. The main thing to note for the rest of the form is that we have the <span class="cf">error_tag</span> fields that will show messages for a changeset when errors are present. Again, this code is not LiveView specific. These look exactly as they would for any other MVC style template.</p>
<p id="calibre_link-2193" class="calibre19">Let’s see what happens when a user submits a form:
</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">def</strong>​ handle_event(​<em class="string">"</em>​​<em class="string">save"</em>​, %{​<em class="string">"</em>​​<em class="string">user"</em>​ =&gt; user_params}, socket) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">case</strong>​ Accounts.create_user(user_params) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:ok</em>​, user} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      {​<em class="string">:stop</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">       socket</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">       |&gt; put_flash(​<em class="string">:info</em>​, ​<em class="string">"</em>​​<em class="string">user created"</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">       |&gt; redirect(​<em class="string">to:</em>​ Routes.live_path(socket, UserLive.Show, user))}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">    {​<em class="string">:error</em>​, %Ecto.Changeset{} = changeset} -&gt;</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">      {​<em class="string">:noreply</em>​, assign(socket, ​<em class="string">changeset:</em>​ changeset)}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2194" class="calibre19">This code is remarkably simple. We use our context to create the user. Based on the results, we either redirect directly to another live view, or we assign the <span class="cf">:changeset</span> with errors to our existing socket.</p>
<p id="calibre_link-2195" class="calibre19">That’s <span class="calibre4">all we need to do</span> to get full validation! If you type a partial email address, you’ll get an error code until the email you type is valid, like this:</p><div class="praise"><img id="calibre_link-2196" class="calibre46" src="images/000025.png" alt="images/src/wrapping_up/validation.png" width="450" height="481" /></div>
<p id="calibre_link-2197" class="calibre19">We’ve just coded validation with a full interactive experience, but with less effort than we would put into an old school MVC application. The end result is snappy, highly interactive, and easy to code.



</p><h3 class="calibre22">Learning More</h3>
<p id="calibre_link-2198" class="calibre19">We’ve just scratched the surface. LiveView can process other kinds of events too, including keystrokes. It’s not built for games but it’s fluid and efficient enough to build them easily. Let’s briefly highlight some of the LiveView features you have not seen yet.


</p><ul class="calibre28"><li class="calibre29">
<p id="calibre_link-2199" class="calibre31">Live views can render other live views like this: <span class="cf1">live_render(@socket, DemoWeb.ImageLive)</span></p></li><li class="calibre29">
<p id="calibre_link-2200" class="calibre31">When LiveView sends down new content for a page, it sends down <span class="calibre4">only changes since the last render</span>.  If there are no changes, nothing is sent.</p></li><li class="calibre29">
<p id="calibre_link-2201" class="calibre31">LiveView can handle other kinds of events too, including keystroke events for both key up and key down.</p></li><li class="calibre29">
<p id="calibre_link-2202" class="calibre31">It works seamlessly with Phoenix PubSub. Therefore, you can push changes down to the page at any time, like we did with channels.</p></li></ul>
<p id="calibre_link-2203" class="calibre19">You can see how LiveView might reshape how we write many of the web applications that we develop every day. With it, you get three huge wins. You’ll write much less code to solve a given problem; you won’t have to become a JavaScript expert to build a nice interactive application; and you don’t need to think about sending data between the client and the server. Removing those burdens will represent tremendous gains for the typical Phoenix developer.</p>
<p id="calibre_link-2204" class="calibre19">Now that you’ve seen what’s happening in LiveView, it’s time to move on to one of the foundational libraries that makes Phoenix click, the PubSub layer.


</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-275"><div id="calibre_link-2205" class="calibre2"><h2 id="calibre_link-160" class="calibre20">Phoenix PubSub 2.0</h2>
<p id="calibre_link-2206" class="calibre19"></p>
<p id="calibre_link-2207" class="calibre19">
Phoenix PubSub is the heart of real-time Phoenix. It powers both Phoenix Channels, via the <span class="cf">Phoenix.PubSub</span> module, and Channel Presence, via <span class="cf">Phoenix.Tracker</span>. Originally, Phoenix PubSub was written as part of Phoenix, and then extracted as its own project. Since then, many companies have contributed to the project, especially to ensure that its implementation scales to potentially millions of users.</p>
<p id="calibre_link-2208" class="calibre19">For the upcoming Phoenix PubSub version, the Phoenix team is working mostly on simplifying the implementation, streamlining the code and making custom adapters easier to implement. On the Phoenix side of things, one important change is also coming: Phoenix will no longer start the Phoenix PubSub as part of the endpoint. Instead, you will need to explicitly start Phoenix PubSub in your supervision tree.</p>
<p id="calibre_link-2209" class="calibre19">

In other words, the supervision tree that Phoenix generates in <span class="cf">lib/rumbl/application.ex</span> will probably look something like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">children = [</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="comment"># Start the Ecto repository</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  Rumbl.Repo,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="comment"># Start the PubSub system</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  {Phoenix.PubSub, ​<em class="string">name:</em>​ Rumbl.PubSub, ​<em class="string">adapter:</em>​ Phoenix.PubSub.PG2},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="comment"># Start the Endpoint when the application starts</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  RumblWeb.Endpoint,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="comment"># Starts a Worker by calling: Rumbl.Worker.start_link(arg)</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">  ​<em class="comment"># {Rumbl.Worker, arg},</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">&nbsp;</span></td><td class="codeline">]</td></tr></table>
<p id="calibre_link-2210" class="calibre19">
This change is particularly important for umbrella projects, which probably want to start <span class="cf">Rumbl.PubSub</span> as part of their non-web applications. (e.g. <span class="cf">rumbl</span>), while consuming from <span class="cf">Rumbl.PubSub</span> in the web application (e.g. <span class="cf">rumbl_web</span>). With this small tweak, you’ll be able to do exactly that.</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-324"><div id="calibre_link-2211" class="calibre2"><h2 id="calibre_link-161" class="calibre20">Phoenix and Telemetry Integration</h2>
<p id="calibre_link-2212" class="calibre19">

As companies started using Phoenix production, there was a growing need to get data out of their Phoenix applications. Because the Erlang VM provides a huge amount of insight about the running system, developers had to reimplement the infrastructure that collects metrics over and over again, and write the integration with their preferred metrics platforms.</p>
<p id="calibre_link-2213" class="calibre19">


Other teams would choose Application Performance Monitoring tools, such as AppSignal,<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-36" href="#calibre_link-325">[43]</a></sup> Scout App,<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-37" href="#calibre_link-326">[44]</a></sup> New Relic,<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-38" href="#calibre_link-327">[45]</a></sup> and others. However, when it came to tracking app specific data, each of those tools would have distinct APIs which you would need to learn.</p>
<p id="calibre_link-2214" class="calibre19">The Elixir community decided to tackle this challenge by implementing the Telemetry toolset. With Telemetry, developers have a unified API for dispatching metrics and instrumentation.<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-39" href="#calibre_link-328">[46]</a></sup> Telemetry also provides a mechanism for collecting built-in VM metrics<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-40" href="#calibre_link-329">[47]</a></sup> and a shared vocabulary for consuming and reporting those metrics.<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-41" href="#calibre_link-330">[48]</a></sup></p>
<p id="calibre_link-2215" class="calibre19">You might wonder what all of this means for Phoenix developers. In future Phoenix versions, we will probably have a new <span class="cf">lib/rumbl_web/telemetry.ex</span> file that outlines all the metrics you may want to extract from your system and how they should be reported. At the moment, we don’t have all details in place, but the file may look like this:</p><table class="processedcode"><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">1:&nbsp;</span></td><td class="codeline">​<strong class="kw">defmodule</strong>​ RumblWeb.Telemetry ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">use</strong>​ Supervisor</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">import</strong>​ Telemetry.Metrics</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">5:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ start_link(arg) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    Supervisor.start_link(__MODULE__, arg, ​<em class="string">name:</em>​ __MODULE__)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">def</strong>​ init(_arg) ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">10:&nbsp;</span></td><td class="codeline">    children = [</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      {​<em class="string">:telemetry_poller</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">       ​<em class="string">measurements:</em>​ periodic_measurements(),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">       ​<em class="string">period:</em>​ 10_000},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      {Telemetry.StatsD, ​<em class="string">metrics:</em>​ metrics()} </td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">15:&nbsp;</span></td><td class="codeline">    ]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    Supervisor.init(children, ​<em class="string">strategy:</em>​ ​<em class="string">:one_for_one</em>​)</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">20:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">defp</strong>​ metrics ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    [</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      ​<em class="comment"># VM Metrics</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      last_value(​<em class="string">"</em>​​<em class="string">vm.memory.total"</em>​, ​<em class="string">unit:</em>​ ​<em class="string">:byte</em>​),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      last_value(​<em class="string">"</em>​​<em class="string">vm.total_run_queue_lengths.total"</em>​),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">25:&nbsp;</span></td><td class="codeline">      last_value(​<em class="string">"</em>​​<em class="string">vm.total_run_queue_lengths.cpu"</em>​),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      last_value(​<em class="string">"</em>​​<em class="string">vm.total_run_queue_lengths.io"</em>​),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      last_value(​<em class="string">"</em>​​<em class="string">rumbl.worker.memory"</em>​, ​<em class="string">unit:</em>​ ​<em class="string">:byte</em>​),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      last_value(​<em class="string">"</em>​​<em class="string">rumbl.worker.message_queue_len"</em>​),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">30:&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      ​<em class="comment"># Database Time Metrics</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      summary(​<em class="string">"</em>​​<em class="string">rumbl.repo.query.total_time"</em>​, ​<em class="string">unit:</em>​ {​<em class="string">:native</em>​, ​<em class="string">:millisecond</em>​}),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      summary(​<em class="string">"</em>​​<em class="string">rumbl.repo.query.decode_time"</em>​, ​<em class="string">unit:</em>​ {​<em class="string">:native</em>​, ​<em class="string">:millisecond</em>​}),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      summary(​<em class="string">"</em>​​<em class="string">rumbl.repo.query.query_time"</em>​, ​<em class="string">unit:</em>​ {​<em class="string">:native</em>​, ​<em class="string">:millisecond</em>​}),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">35:&nbsp;</span></td><td class="codeline">      summary(​<em class="string">"</em>​​<em class="string">rumbl.repo.query.queue_time"</em>​, ​<em class="string">unit:</em>​ {​<em class="string">:native</em>​, ​<em class="string">:millisecond</em>​}),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      ​<em class="comment"># Phoenix Time Metrics</em>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      summary(​<em class="string">"</em>​​<em class="string">phoenix.endpoint.stop.duration"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">              ​<em class="string">unit:</em>​ {​<em class="string">:native</em>​, ​<em class="string">:millisecond</em>​}),</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">40:&nbsp;</span></td><td class="codeline">      summary(</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">        ​<em class="string">"</em>​​<em class="string">phoenix.route_dispatch.stop.duration"</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">        ​<em class="string">unit:</em>​ {​<em class="string">:native</em>​, ​<em class="string">:millisecond</em>​},</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">        ​<em class="string">tags:</em>​ [​<em class="string">:plug</em>​]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">      )</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">45:&nbsp;</span></td><td class="codeline">    ]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline"></td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">  ​<strong class="kw">defp</strong>​ periodic_measurements ​<strong class="kw">do</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    [</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">50:&nbsp;</span></td><td class="codeline">      {​<em class="string">:process_info</em>​,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">       ​<em class="string">event:</em>​ [​<em class="string">:rumbl</em>​, ​<em class="string">:worker</em>​],</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">       ​<em class="string">name:</em>​ Rumbl.Worker,</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">       ​<em class="string">keys:</em>​ [​<em class="string">:message_queue_len</em>​, ​<em class="string">:memory</em>​]}</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">    ]</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">55:&nbsp;</span></td><td class="codeline">  ​<strong class="kw">end</strong>​</td></tr><tr class="calibre30"><td class="codeinfo">​<span class="codeprefix">-&nbsp;</span></td><td class="codeline">​<strong class="kw">end</strong>​</td></tr></table>
<p id="calibre_link-2216" class="calibre19">


The new file starts by defining a supervisor. The supervisor has two children. The first is a <span class="cf">:telemetry_poller</span> child that executes a list of measurements every 10 seconds. The second is a StatsD<sup class="calibre23"><a class="pcalibre footnote pcalibre3 pcalibre1 pcalibre2" id="calibre_link-42" href="#calibre_link-331">[49]</a></sup> reporter on line 14. In this case, StatsD is just an example for a metric aggregation tool. You may add others or you may completely replace it. As the community and more companies rely on Telemetry, we expect integration with many other reporters in the future.</p>
<p id="calibre_link-2217" class="calibre19">



You can also see two private functions in the module. The supervisor will invoke them when starting the supervision children as part of the <span class="cf">init</span> function. In the <span class="cf">metrics</span> function, we list all of the metrics we want the reporter to publish. These include VM metrics, such as memory usage and the run queue length&mdash;which shows how busy the machine is while performing I/O and CPU tasks. Then we list time measurements for database queries and Phoenix operations.</p>
<p id="calibre_link-2218" class="calibre19">


Finally, in the <span class="cf">periodic_measurements</span> function, we define all periodic measurements for a process. For example, you can collect information such as memory usage and message queue length from any process in the system. Other custom measurements, such as <span class="cf">ets_info</span>, may be available in the future. This can be useful to track memory usage per table, such as the ETS table used by the InfoSys system.</p>
<p id="calibre_link-2219" class="calibre19">Though the final API may change a little or a lot, the goal of integrating Phoenix and Telemetry remains clear: help developers, teams, and companies extract the maximum amount of insight possible from their production systems.

</p>
</div>



  </div>


<div class="calibre1" id="calibre_link-28"><div id="calibre_link-2220" class="calibre2"><h2 id="calibre_link-162" class="calibre20">Good Luck!</h2>
<p id="calibre_link-2221" class="calibre19">That’s a brief taste of what’s happening in the Phoenix ecosystem right now. With the continuous growth in this space, we hope and fully expect the community to contribute ideas faster than we can write about them. We also expect that you, our readers, will use the ideas in this book to change the way the world thinks about what’s possible.</p>
<p id="calibre_link-2222" class="calibre19">We’re excited to see what you do with Phoenix. Thanks for taking this journey with us!</p>

<div class="footnotes">
<h4 class="calibre24">Footnotes</h4>
<dl class="calibre25">
<dt class="footnote-number"><a id="calibre_link-208" href="#calibre_link-29" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[36]</a></dt><dd class="calibre26">
<p id="calibre_link-2223" class="calibre27"><a href="http://sevenseacat.net/2015/12/20/i18n-in-phoenix-apps.html" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">http://sevenseacat.net/2015/12/20/i18n-in-phoenix-apps.html</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-209" href="#calibre_link-30" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[37]</a></dt><dd class="calibre26">
<p id="calibre_link-2224" class="calibre27"><a href="http://hexdocs.pm/gettext" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">http://hexdocs.pm/gettext</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-210" href="#calibre_link-31" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[38]</a></dt><dd class="calibre26">
<p id="calibre_link-2225" class="calibre27"><a href="http://hexdocs.pm/phoenix/Phoenix.Channel.html" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">http://hexdocs.pm/phoenix/Phoenix.Channel.html</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-211" href="#calibre_link-32" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[39]</a></dt><dd class="calibre26">
<p id="calibre_link-2226" class="calibre27"><a href="http://github.com/phoenixframework/phoenix_live_reload" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">http://github.com/phoenixframework/phoenix_live_reload</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-212" href="#calibre_link-33" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[40]</a></dt><dd class="calibre26">
<p id="calibre_link-2227" class="calibre27"><a href="https://github.com/phoenixframework/phoenix_pubsub_redis" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://github.com/phoenixframework/phoenix_pubsub_redis</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-213" href="#calibre_link-34" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[41]</a></dt><dd class="calibre26">
<p id="calibre_link-2228" class="calibre27"><a href="https://github.com/livehelpnow/CSharpPhoenixClient" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://github.com/livehelpnow/CSharpPhoenixClient</a>,
     <a href="https://github.com/eoinsha/JavaPhoenixChannels" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://github.com/eoinsha/JavaPhoenixChannels</a>,
     <a href="https://github.com/livehelpnow/ObjCPhoenixClient" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://github.com/livehelpnow/ObjCPhoenixClient</a>, and
     <a href="https://github.com/davidstump/SwiftPhoenixClient" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://github.com/davidstump/SwiftPhoenixClient</a>.</p></dd>
<dt class="footnote-number"><a id="calibre_link-244" href="#calibre_link-35" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[42]</a></dt><dd class="calibre26">
<p id="calibre_link-2229" class="calibre27"><a href="https://github.com/chrismccord/phoenix_live_view_example" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://github.com/chrismccord/phoenix_live_view_example</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-325" href="#calibre_link-36" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[43]</a></dt><dd class="calibre26">
<p id="calibre_link-2230" class="calibre27"><a href="https://appsignal.com/elixir" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://appsignal.com/elixir</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-326" href="#calibre_link-37" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[44]</a></dt><dd class="calibre26">
<p id="calibre_link-2231" class="calibre27"><a href="https://scoutapm.com/elixir-monitoring" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://scoutapm.com/elixir-monitoring</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-327" href="#calibre_link-38" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[45]</a></dt><dd class="calibre26">
<p id="calibre_link-2232" class="calibre27"><a href="https://newrelic.com/" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://newrelic.com/</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-328" href="#calibre_link-39" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[46]</a></dt><dd class="calibre26">
<p id="calibre_link-2233" class="calibre27"><a href="https://github.com/beam-telemetry/telemetry" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://github.com/beam-telemetry/telemetry</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-329" href="#calibre_link-40" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[47]</a></dt><dd class="calibre26">
<p id="calibre_link-2234" class="calibre27"><a href="https://github.com/beam-telemetry/telemetry_poller" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://github.com/beam-telemetry/telemetry_poller</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-330" href="#calibre_link-41" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[48]</a></dt><dd class="calibre26">
<p id="calibre_link-2235" class="calibre27"><a href="https://github.com/beam-telemetry/telemetry_metrics" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://github.com/beam-telemetry/telemetry_metrics</a></p></dd>
<dt class="footnote-number"><a id="calibre_link-331" href="#calibre_link-42" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">[49]</a></dt><dd class="calibre26">
<p id="calibre_link-2236" class="calibre27"><a href="https://github.com/statsd/statsd" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://github.com/statsd/statsd</a></p></dd></dl></div>
<div class="copyright">Copyright © 2020, The Pragmatic Bookshelf.</div>

</div>



  </div>


<div class="calibre1" id="calibre_link-194"><div id="calibre_link-2237" class="calibre2"><br class="about-pb" /><div class="backmatter-cover">Thank you!
<p id="calibre_link-2238" class="calibre14">
   How did you enjoy this book? Please let us know. Take a moment and email us at support@pragprog.com with your feedback. Tell us your story and you could win free ebooks. Please use the subject line “Book Feedback.”
   </p>
<p id="calibre_link-2239" class="calibre14">
   Ready for your next great Pragmatic Bookshelf book? Come on over to <a href="https://pragprog.com" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2">https://pragprog.com</a> and use the coupon code BUYANOTHER2019 to save 30% on your next ebook.
   </p>
<p id="calibre_link-2240" class="calibre14">
   Void where prohibited, restricted, or otherwise unwelcome. Do not use ebooks near water. If rash persists, see a doctor. Doesn’t apply to <span class="calibre4">The Pragmatic Programmer</span> ebook because it’s older than the Pragmatic Bookshelf itself. Side effects may include increased knowledge and skill, increased marketability, and deep satisfaction. Increase dosage regularly.
   </p>
<p id="calibre_link-2241" class="calibre14">
   And thank you for your continued support,
   </p>
<p id="calibre_link-2242" class="calibre14">
   Andy Hunt, Publisher
   </p><div class="praise"><img id="calibre_link-2243" class="calibre52" src="images/000011.png" alt="images/Coupon.png" /></div></div>
</div>



  </div>


<div class="calibre1" id="calibre_link-237"><div id="calibre_link-2244" class="calibre2"><h2 class="calibre20">You May Be Interested In…</h2><p class="calibre19"><em class="calibre4">Select a cover for more information</em></p><div class="praise"><div class="backmatter-cover"><h3 class="calibre22">Real-Time Phoenix</h3><div class="cover-image"><a href="http://pragmaticprogrammer.com/titles/sbsockets" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2"><img src="images/000033.jpg" alt="" class="calibre53" /></a></div><p class="calibre14">
      Give users the real-time experience they expect, by using Elixir and Phoenix Channels to build applications that instantly react to changes and reflect the application’s true state. Learn how Elixir and Phoenix make it easy and enjoyable to create real-time applications that scale to a large number of users. Apply system design and development best practices to create applications that are easy to maintain. Gain confidence by learning how to break your applications before your users do. Deploy applications with minimized resource use and maximized performance.
    </p><p class="calibre14">Stephen Bussey</p><p class="calibre14">(250 pages) ISBN: 9781680507195 $45.95</p></div><div class="backmatter-cover"><h3 class="calibre22">Designing Elixir Systems with OTP</h3><div class="cover-image"><a href="http://pragmaticprogrammer.com/titles/jgotp" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2"><img src="images/000021.jpg" alt="" class="calibre53" /></a></div><p class="calibre14">
      You know how to code in Elixir; now learn to think in it. Learn to design libraries with intelligent layers that shape the right data structures, flow from one function into the next, and present the right APIs. Embrace the same OTP that’s kept our telephone systems reliable and fast for over 30 years. Move beyond understanding the OTP functions to knowing what’s happening under the hood, and why that matters. Using that knowledge, instinctively know how to design systems that deliver fast and resilient services to your users, all with an Elixir focus.
    </p><p class="calibre14">James Edward Gray, II and Bruce A. Tate</p><p class="calibre14">(246 pages) ISBN: 9781680506617 $41.95</p></div><div class="backmatter-cover"><h3 class="calibre22">Programming Ecto</h3><div class="cover-image"><a href="http://pragmaticprogrammer.com/titles/wmecto" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2"><img src="images/000018.jpg" alt="" class="calibre53" /></a></div><p class="calibre14">
      Languages may come and go, but the relational database endures. Learn how to use Ecto, the premier database library for Elixir, to connect your Elixir and Phoenix apps to databases. Get a firm handle on Ecto fundamentals with a module-by-module tour of the critical parts of Ecto. Then move on to more advanced topics and advice on best practices with a series of recipes that provide clear, step-by-step instructions on scenarios commonly encountered by app developers. Co-authored by the creator of Ecto, this title provides all the essentials you need to use Ecto effectively.
    </p><p class="calibre14">Darin Wilson and Eric Meadows-Jönsson</p><p class="calibre14">(242 pages) ISBN: 9781680502824 $45.95</p></div><div class="backmatter-cover"><h3 class="calibre22">Property-Based Testing with PropEr, Erlang, and Elixir</h3><div class="cover-image"><a href="http://pragmaticprogrammer.com/titles/fhproper" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2"><img src="images/000016.jpg" alt="" class="calibre53" /></a></div><p class="calibre14">
      Property-based testing helps you create better, more solid tests with little code. By using the PropEr framework in both Erlang and Elixir, this book teaches you how to automatically generate test cases, test stateful programs, and change how you design your software for more principled and reliable approaches. You will be able to better explore the problem space, validate the assumptions you make when coming up with program behavior, and expose unexpected weaknesses in your design. PropEr will even show you how to reproduce the bugs it found. With this book, you will be writing efficient property-based tests in no time.
    </p><p class="calibre14">Fred Hebert</p><p class="calibre14">(374 pages) ISBN: 9781680506211 $45.95</p></div><div class="backmatter-cover"><h3 class="calibre22">Craft GraphQL APIs in Elixir with Absinthe</h3><div class="cover-image"><a href="http://pragmaticprogrammer.com/titles/wwgraphql" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2"><img src="images/000041.jpg" alt="" class="calibre53" /></a></div><p class="calibre14">
      Your domain is rich and interconnected, and your API should be too. Upgrade your web API to GraphQL, leveraging its flexible queries to empower your users, and its declarative structure to simplify your code. Absinthe is the GraphQL toolkit for Elixir, a functional programming language designed to enable massive concurrency atop robust application architectures. Written by the creators of Absinthe, this book will help you take full advantage of these two groundbreaking technologies. Build your own flexible, high-performance APIs using step-by-step guidance and expert advice you won’t find anywhere else.
    </p><p class="calibre14">Bruce Williams and Ben Wilson</p><p class="calibre14">(302 pages) ISBN: 9781680502558 $47.95</p></div><div class="backmatter-cover"><h3 class="calibre22">Functional Web Development with Elixir, OTP, and Phoenix</h3><div class="cover-image"><a href="http://pragmaticprogrammer.com/titles/lhelph" class="pcalibre pcalibre3 calibre5 pcalibre1 pcalibre2"><img src="images/000019.jpg" alt="" class="calibre53" /></a></div><p class="calibre14">
      Elixir and Phoenix are generating tremendous excitement as an unbeatable platform for building modern web applications. For decades OTP has helped developers create incredibly robust, scalable applications with unparalleled uptime. Make the most of them as you build a stateful web app with Elixir, OTP, and Phoenix. Model domain entities without an ORM or a database. Manage server state and keep your code clean with OTP Behaviours. Layer on a Phoenix web interface without coupling it to the business logic. Open doors to powerful new techniques that will get you thinking about web development in fundamentally new ways.
    </p><p class="calibre14">Lance Halvorsen</p><p class="calibre14">(218 pages) ISBN: 9781680502435 $45.95</p></div></div><hr class="backmatter-end" />
</div>



  </div>


</body></html>